import os
import stat
import gzip
import time
import socket
import fcntl
import struct
import formencode
import calendar
import copy
import tornado.web
import funcy
import glob
import math
import datetime
import boto

import deepy.cfg
import deepy.util
import deepy.status
import deepy.validators
import deepy.deepy_redis
import deepy.log as log

import deepy.redis_queue
import redis

import base
import auth_static_handler
import util
import config_positions
from deepy.ui_celery.async_decorator import make_async
from deepy.jobs_daemon import jobs_add, setup_queues

import config_setup

import json

try: import ujson
except ImportError: import json as ujson

# TEMP DOWNLOAD PAGE HANDLERS
class DownloadPageStaticHandler(auth_static_handler.AuthenticatableStaticFileHandler):
    required_permissions = ['download']

class DownloadPageHandler(base.TileHandler):
    required_permissions = ['download']

    wrapper_template = 'templates/ui_wrapper.html'
    template = 'templates/download.html'
    href = '/download'
    download_path = None
    download_url_path = '/download'
    template_args = {'title': 'Download Area'}
    mtime_format = '%b %d %Y %I:%M %p'

    def initialize(self, path=None, download_url=None):
        if path != None:
            self.download_path = path
        elif self.download_path == None:
            self.download_path = os.path.join(deepy.cfg.home_dir, 'download')

        if download_url != None:
            self.download_url_path = download_url

    def get(self, *path_args, **path_kwargs):
        download_items = self.__get_download_names()
        self.template_args['items_json'] = base.json_encode(download_items)
        super(DownloadPageHandler, self).get(*path_args, **path_kwargs)

    def __get_download_names(self):
        files = []
        # be defensive in case the path doesnt exist
        if os.path.isdir(self.download_path):
            path = os.path.join(self.download_path, '*.*')
            for f in glob.iglob(path):
                files.append({
                        'name': os.path.basename(f),
                        'href': os.path.join(self.download_url_path, \
                                             os.path.basename(f)),
                        # i don't really like calling stat() twice, but this
                        # looks cleaner and this page is rarely accessed
                        'size': self.__get_human_file_size(f),
                        'mtime': self.__get_human_mtime(f)
                    })
        return files

    def __get_human_file_size(self, filename):
        try:
            stat_data = os.stat(filename)
            size = stat_data.st_size
            si_unit = ['B', 'K', 'M', 'G', 'T', 'Y', 'E']
            idx = 0
            while(True):
                if size >= 1024 or si_unit[idx] == 'E':
                    size = size / 1024.0
                    idx += 1
                else:
                    break
            return str(math.ceil(size * 10) / 10.0) + si_unit[idx]
        except:
            return 'Unknown'

    def __get_human_mtime(self, filename):
        try:
            stat_data = os.stat(filename)
            return datetime.datetime.fromtimestamp(int(stat_data.st_mtime)).strftime(self.mtime_format)
        except:
            return 'Unknown'


# /view_as/[username] --> turn on for [username]
class ViewAsHandler(base.ApiHandler):
    required_permissions = ['view_as']
    def post(self, path=""):
        if not self.get_secure_cookie("euid"):
            self.set_secure_cookie("euid", path)

    def check_xsrf_cookie(self):
        pass

# /view_as_off --> turn off
class ViewAsOffHandler(base.ApiHandler):
    required_permissions = []
    def post(self):
        if self.get_secure_cookie("euid"):
            self.clear_cookie("euid")

    def check_xsrf_cookie(self):
        pass


# /api/statusqueues
class StatusQueueApiHandler(base.ApiHandler):
    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self):

        # Redis queue status
        cache = {'queues': {}}
        try:
            r_server = redis.Redis("localhost")
            cache['queues']['h5flow'] = r_server.llen("queue:h5flow")
            cache['queues']['h5dns'] = r_server.llen("queue:h5dns")
            cache['queues']['h5classify'] = r_server.llen("queue:h5classify")
            cache['queues']['h5cube'] = r_server.llen("queue:h5cube")
        except:
            pass

        # SQS Job queue status
        queues = setup_queues(deepy.cfg.vm_config)
        count = 0
        for name, queue in queues.items():
            q = deepy.aws.get_sqs_queue(queue.name)
            if name == 'local':
                continue
            count += q.count()
        cache['queues']['jobs'] = count
        cache['queues']['jobs'] = 0

        self.finish(cache)


# /api/status
class StatusApiHandler(base.ApiHandler):
    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self):
        cache = yield make_async(get_status_cache)

        # Redis queue status
        #cache['queues'] = {}
        #try:
        #    r_server = redis.Redis("localhost")
        #    cache['queues']['h5flow'] = r_server.llen("queue:h5flow")
        #    cache['queues']['h5dns'] = r_server.llen("queue:h5dns")
        #    cache['queues']['h5classify'] = r_server.llen("queue:h5classify")
        #    cache['queues']['h5cube'] = r_server.llen("queue:h5cube")
        #except:
        #    pass

        # SQS Job queue status
        #queues = setup_queues(deepy.cfg.vm_config)
        #count = 0
        #for name, queue in queues.items():
        #    q = deepy.aws.get_sqs_queue(queue.name)
        #    if name == 'local':
        #        continue
        #    count += q.count()
        #cache['queues']['jobs'] = count
        #cache['queues']['jobs'] = 0

        self.finish(cache)

def get_status_cache():
    aws_path = "status/status_new.json.gz"
    local_path = deepy.cfg.cache_dir + "/" + aws_path

    if (os.path.exists(local_path) and (time.time() - os.stat(local_path).st_mtime) < (60*10)):
        cache = json.load(gzip.open(local_path))
    else:
        # A temporary hack for s3 connection resilience
        try:
            cache = deepy.store.simple_load_json(local_path)
        except boto.exception.AWSConnectionError:
            # if there is some error (if we can't connect to s3, use local, even if its stale)
            cache = json.load(gzip.open(local_path))

    if not cache:
        return {}

    # Update license days remaining
    if 'license' in cache and cache['license']:
        # Change 'demo' to 'trial' so that new dynamic type field stays the same for existing deployments.
        if 'type' in cache['license'] and cache['license']['type'] == 'demo':
            cache['license']['type'] = 'trial'

        if 'expires' in cache['license']:
            # TODO: Convert this to use deepy.timerange
            expires = cache['license']['expires']
            try:
                c = time.strptime(expires,"%Y-%m-%d")
                sec = calendar.timegm(c) - time.time()
                cache['license']['days_remaining'] = int(sec / (60*60*24))
            except ValueError:
                log.error("bad-license-expires-format {}".format(expires))
                cache['license']['days_remaining'] = 0

    # Add connectors
    connectors = deepy.util.vm_or_slice_config_get("connectors")
    if connectors:
        cache['connectors'] = connectors

    # Add alerts
    alerts = {}
    for vm_id, vm in cache['vms'].iteritems():
        vm_heartbeat = vm.get('heartbeat')
        if vm_heartbeat is None: continue
        alerts[vm_id] = deepy.status.check_for_alerts(vm_heartbeat)
    cache['alerts'] = alerts

    # Limit the maximum number of alerts of any given type
    max_alerts = deepy.cfg.slice_config.get('max_alerts', 100)
    max_message_length = deepy.cfg.slice_config.get('max_message_length', 500)
    _trim_number_of_alerts = lambda alert_list: alert_list[:max_alerts]
    def _trim_alerts(alert_set):
        if alert_set is None:
            return
        for alert_id in alert_set:
            if isinstance(alert_set[alert_id], list):
                alert_set[alert_id] = _trim_number_of_alerts(alert_set[alert_id])
        # Trim msg length too
        msgs = alert_set.get('msgs') or {}
        for msg_id in msgs:
            message_set = msgs[msg_id]
            if isinstance(message_set, (str, unicode)):
                msgs[msg_id] = message_set[:max_message_length]
            elif isinstance(message_set, list):
                for i in xrange(len(message_set)):
                    msg = message_set[i]
                    if isinstance(msg, (str, unicode)):
                        message_set[i] = msg[:max_message_length]


    vms = cache.get('vms') or {}
    for vm_id in vms:
        vm = vms.get(vm_id)
        if vm:
            _trim_alerts(vm.get('alerts') or {})
            _trim_alerts((vm.get('heartbeat') or {}).get('alerts') or {})

    alerts = cache.get('alerts') or {}
    for vm_id in alerts:
        _trim_alerts(alerts.get(vm_id) or {})

    # Trim syslog in particular
    for vm_id in vms:
        vm = vms.get(vm_id) or {}
        heartbeat = vm.get('heartbeat') or {}
        heartbeat['syslog'] = _trim_number_of_alerts(heartbeat.get('syslog') or [])

    return cache

class ConfigConnectorsApiHandler(base.ApiHandler):

    required_permissions = ['system_config']

    def get(self):
        scripts_dir = deepy.cfg.cache_connectors_dir + '/scripts'
        keys_info = deepy.store.ls_dir_remote(deepy.cfg.cache_connectors_dir,
                dir_mtimes=True)

        conns = {}
        statuses = {}
        for ki in keys_info:
            base, ext = os.path.splitext(os.path.basename(ki['name']))
            if scripts_dir in ki['name']:
                continue
            elif ki['name'].endswith('status.json'):
                base = base.replace('.status', '')
                status = deepy.store.simple_load_json(ki['name'])
                statuses[base] = {'status': status,
                        'last_modified': ki['mtime']}
            elif base and ext == '.json':
                conn = deepy.store.simple_load_json(ki['name'])
                if conn is None:
                    log.warn('bad-connector {}'.format(base))
                else:
                    tmp = conns.get(base, {})
                    tmp.update(conn)
                    if 'name' not in tmp:
                        tmp['name'] = base
                    conns[base] = tmp
            else:
                log.warn('unexpected-connector-file {}'.format(base))

        #only add status if connector exists
        for k,v in statuses.items():
            if conns.has_key(k):
                tmp = conns.get(k, {})
                tmp.update(v)
                conns[k] = tmp

        out_json = json.dumps(conns.values())

        self.finish(out_json)

class ConfigSnmpJsonApiHandler(base.ApiHandler):
    def get(self):
        self.set_header("Content-Disposition", "attachment;")
        snmp_json = deepy.store.simple_load_json('{}/{}'.format(deepy.cfg.snmp_dir, 'snmp.json.gz'))
        if snmp_json is None:
            snmp_json = {}
        self.write_json(snmp_json, compress=True)
        return

class ConfigInterfaceRegExpHandler(base.ApiHandler):
    def post(self):
        ire = json.loads(self.request.body)
        deepy.store.simple_save_json(ire, deepy.cfg.interfaces_regexp_file,
            audit_string=self.get_current_user())

    def check_xsrf_cookie(self):
        pass

class ConfigHandler(base.TileHandler):
    wrapper_template = 'static/build/templates/ui_wrapper.html'
    template = 'templates/config.html'
    href = '/config'
    tile_id = 'tile_config'
    template_args = {'title': 'Configuration'}


class ConfigApiHandler(base.ApiHandler):
    def get(self):
        config_tiles = self.get_config_tiles()
        self.finish(json.dumps(list(set(config_tiles))))
        return

class ConfigSetupHandler(base.TileHandler):

    required_permissions = ['system_config']

    wrapper_template = 'static/build/templates/ui_wrapper.html'
    template = 'templates/config_setup.html'
    href = '/config/setup'
    tile_id = 'tile_config_setup'
    template_args = {'title': 'Setup'}


class ServicesApiHandler(base.ApiHandler):

    required_permissions = ['system_config']

    def get(self):
        print base.services_config
        self.set_header("Content-Type", "application/json; charset=UTF-8")
        self.finish(json.dumps(base.services_config))


class MinedPeersApiHandler(base.ApiHandler):
    def get(self):
        resp = None
        self.set_header("Content-Type", "application/json; charset=UTF-8")
        try:
            print "LOAD", deepy.cfg.peers_dimension_db_file
            resp = json.load(gzip.open(deepy.cfg.peers_dimension_db_file))

        except Exception, e:
            print 'Cannot load dimension db file: ', deepy.cfg.peers_dimension_db_file, str(e)

        if resp is None:
            resp = '{}'

        self.finish(resp)


class GeoipLatLonApiHandler(base.ApiHandler):
    def get(self):
        resp = None
        self.set_header("Content-Type", "application/json; charset=UTF-8")
        try:
            resp = json.load(open(deepy.cfg.geoip_latlon_db_file))
            print "FOUND", deepy.cfg.geoip_latlon_db_file
        except:
            print "NOT FOUND", deepy.cfg.geoip_latlon_db_file

        if resp is None:
            resp = "{}"

        self.finish(resp)

class CubeQueryHandler(base.TileHandler):
    wrapper_template = 'static/build/templates/ui_wrapper.html'
    template = 'templates/cube_query.html'
    template_args = {"title": "Cube Query"}

class PlaygroundNaimHandler(base.TileHandler):
    wrapper_template = 'static/build/templates/ui_wrapper.html'
    template = 'templates/playground/naim.html'
    template_args = {"title": "Playground"}

class PlaygroundNaimApiHandler(base.ApiHandler):
    def get(self):
        params = self.get_argument_list_dict()

        if 'fail' in params and params['fail'] == 'soft':
            self.finish({"status": "error"})
        elif 'fail' in params and params['fail'] == 'hard':
            raise tornado.web.HTTPError(500)
        else:
            self.finish({})

    def post(self):
        raise tornado.web.HTTPError(405)

class PlaygroundScottHandler(base.TileHandler):
    wrapper_template = 'static/build/templates/ui_wrapper.html'
    template = 'templates/playground/scott.html'
    template_args = {"title": "Playground"}

class PlaygroundJPHandler(base.TileHandler):
    wrapper_template = 'static/build/templates/ui_wrapper.html'
    template = 'templates/playground/jp.html'
    template_args = {"title": "Playground"}

class PlaygroundDanielHandler(base.TileHandler):
    wrapper_template = 'static/build/templates/ui_wrapper.html'
    template = 'templates/playground/dan.html'
    template_args = {"title": "Playground"}

class PlaygroundOlgaHandler(base.TileHandler):
    wrapper_template = 'static/build/templates/ui_wrapper.html'
    template = 'templates/playground/olga.html'
    template_args = {"title": "Playground"}

class PlaygroundAaronHandler(base.TileHandler):
    wrapper_template = 'static/build/templates/ui_wrapper.html'
    template = 'templates/playground/aaron.html'
    template_args = {"title": "Playground"}

class PlaygroundYogiHandler(base.TileHandler):
    wrapper_template = 'static/build/templates/ui_wrapper.html'
    template = 'templates/playground/yogi.html'
    template_args = {"title": "Playground"}

class PlaygroundPaulHandler(base.TileHandler):
    template = 'templates/playground/paul.html'
    template_args = {"title": "Sunburst"}

class PlaygroundScottApiHandler(base.ApiHandler):
    def get(self):
        config = json.load(open(deepy.cfg.log_cube_config))
        self.finish(config)

    def post(self):
        pass

######## Config Setup

class SetupSchema(deepy.validators.Schema):
    name = formencode.validators.String()   # deployment name
    genome_url = formencode.validators.String(if_missing=False)
    proxy_url = formencode.validators.String(if_missing=False)
    anonymize_subs = formencode.validators.StringBoolean(if_missing=False)
    timezone = formencode.validators.String()

class ConfigIpApiHandler(base.ApiHandler):

    def get(self):
        ret = {'vm_ip': '', 'origin':'default'}

        s = deepy.store.simple_load_json(deepy.cfg.slice_file)
        if 'elastic_ip' in s:
            ret['vm_ip']= s['elastic_ip']
            ret['origin']= 'aws'
        else:
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                ret['vm_ip'] = socket.inet_ntoa(fcntl.ioctl(
                    s.fileno(),
                    0x8915,  # SIOCGIFADDR
                    struct.pack('256s', 'eth0')
                )[20:24])
                ret['origin'] = 'ioctl'
            except IOError:
                # The above ioctl only works on Linux, default to scapy
                # if it fails.
                try:
                    import scapy.all
                    for r in scapy.all.conf.route.routes:
                        if (r[3] == 'eth0') or \
                             ((ret['vm_ip'] is None) and (r[2] != '0.0.0.0')):
                           ret['vm_ip'] = str(r[4])
                    ret['origin'] = 'scapy'
                except:
                    pass

        self.finish(ret)

class ConfigSetupApiHandler(base.ApiHandler):

    required_permissions = ['system_config']

    def get_required_permissions(self):
        if self.request.method == 'POST':
            return self.required_permissions[:]
        return []

    def get(self):
        users_config = deepy.deepy_redis.cache_read_file(deepy.cfg.users_file)
        users = users_config.get('users') or []
        composite_role = None
        email = self.get_effective_user()
        if email is not None:
            user_roles = deepy.user_roles.get_roles_for_user(email, users_config,
                deepy.user_roles.get_user_roles())
            composite_role = self.get_composite_role(user_roles)

        ret = config_setup.get_config(users,
                                      self.get_menus(),
                                      self.get_tiles(),
                                      composite_role,
                                      email
                                      )
        self.write_json(ret)

    def post(self):
        # The name arg isn't used.
        args = self.get_argument_dict()
        try:
            schema = SetupSchema()
            validated = schema.to_python(args)
        except formencode.Invalid as err:
            self.api_error(errors=err.unpack_errors())
            return

        ui_config = deepy.deepy_redis.cache_read_file(deepy.cfg.ui_config_file)
        SetupSchema.update_recursive(ui_config, validated)

        # Save to redis
        deepy.deepy_redis.write_key(deepy.cfg.ui_config_file, ui_config)

class IPsWithNoAppsCsv(base.ApiHandler):
    def get(self):
        deepy.store.cache_load_from_remote(deepy.cfg.cache_dir + '/comcast_datacenters/ips_no_apps.csv')
        try:
            fd = open(deepy.cfg.cache_dir + '/comcast_datacenters/ips_no_apps.csv')
        except IOError:
            self.send_error(404)
            return
        self.set_header("Content-Type", "text/csv; charset=UTF-8")
        self.write(fd.read())

class IPsWithDscp0Csv(base.ApiHandler):
    def get(self):
        deepy.store.cache_load_from_remote(deepy.cfg.cache_dir + '/comcast_datacenters/ips_dscp0.csv')
        try:
            fd = open(deepy.cfg.cache_dir + '/comcast_datacenters/ips_dscp0.csv')
        except IOError:
            self.send_error(404)
            return
        self.set_header("Content-Type", "text/csv; charset=UTF-8")
        self.write(fd.read())

class ConfigSetupNetApiHandler(base.ApiHandler):
    def get_required_permissions(self):
        if self.request.method == 'POST':
            return ['system_config']
        return []

    required_permissions = ['system_config']

    def get(self):
        setup_json = deepy.store.simple_load_json(deepy.cfg.setup_config_file)
        if setup_json:
            ret = dict((k, self.transform_match(v)) for k, v in setup_json.iteritems() if k not in ['version', 'saved_by'])
        else:
            ret = {}

        self.finish(ret)

    to_ui = {
        u'origin_asn': u'origin_as_is',
        u'asn': u'origin_as_is'
    }

    def transform_match(self, val):
        if 'match' in val:
            val['match'] = dict((self.to_ui.get(k, k), v) for k, v in val['match'].iteritems())
        return val

    def post(self):
        setup_json = deepy.store.simple_load_json(deepy.cfg.setup_config_file)

        args = self.get_argument_dict()
        try:
            schema = SetupNetSchema()
            validated = schema.to_python(args)
        except formencode.Invalid as err:
            self.api_error(errors=err.unpack_errors())
            return

        name = validated['tag']['name']
        old_match = setup_json[name]['match']
        new_match = validated['tag']['match']

        config_positions.TagMatchSchema.update_recursive(old_match, new_match)
        setup_json[name]['match'] = new_match

        deepy.store.simple_save_json(setup_json, deepy.cfg.setup_config_file,
            audit_string=self.get_current_user())

class SetupNetTagSchema(deepy.validators.Schema):
    name = formencode.validators.String() # type (e.g. backbone)
    match = config_positions.TagMatchSchema()

class SetupNetSchema(deepy.validators.Schema):
    action = formencode.validators.OneOf(['add', 'update', 'delete',
                                          'accept', 'ignore'], not_empty=True)
    tag = SetupNetTagSchema()


# XXXX this does not appear to be used XXXX
class UNUSEDDimensionsDBApiHandler(base.ApiHandler):

    required_permissions = ['dimension_config']

    def get(self):
        #Load the whole thing
<<<<<<< HEAD
        dimensions_db = deepy.dimensions.DimensionsDB(db_file=deepy.cfg.dimensions_db_file)
=======
        dimensions_db = deepy.dimensions.DimensionsDB(None)
>>>>>>> origin/master
        ret = dimensions_db
        self.finish(ret)

    def post(self):
        pass

class ConfigAPI(base.ApiHandler):
    def get(self, key):
        slice = deepy.store.simple_load_json(deepy.cfg.slice_file)
        out = {key:slice.get(key, None)}
        self.finish(out)

class StartProfiling(base.ApiHandler):
    def get(self):
        import deepy.profile
        deepy.profile.set_profile(True)

class StopProfiling(base.ApiHandler):
    def get(self):
        import deepy.profile
        deepy.profile.set_profile(False)

class Profile(base.ApiHandler):
    def get(self):
        import deepy.profile
        s = deepy.profile.get_profile_string()
        self.set_header("Content-Type", "text/plain; charset=UTF-8")
        self.finish(s)

class TimezonePageHandler(base.TileHandler):
    wrapper_template = 'static/build/templates/ui_wrapper.html'
    template = 'templates/timezones.html'
    template_args = {"title": "Available Timezones"}

class ChecklistPageHandler(base.TileHandler):
    wrapper_template = 'static/build/templates/ui_wrapper.html'
    template = 'templates/checklist.html'
    template_args = {"title": "Onboarding Checklist"}
