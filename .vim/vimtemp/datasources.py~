#!/usr/bin/env python

import base
import deepy.peer_interfaces as dpi
import deepy.deepy_redis
import deepy.dimensions
import deepy.asndb
import deepy.cfg
import deepy.util
import deepy.log
import deepy.redis_queue
import json
import redis

from _mysql_exceptions import OperationalError

class RouterPosition(base.ApiHandler):
    '''
     '997': {'cname': '198.108.93.51:165',
      'description': 'Channelized T3; (MN2/CT3/3)',
      'match': {'snmp': ['198.108.93.51:165']},
      'name': 'sfpop:T1',
      'tag': 'dim:interfaces:198.108.93.51:165:116.997'},
    '''

    def get(self, match_ip):
<<<<<<< HEAD
        db = deepy.dimensions.DimensionsDB(db_file=deepy.cfg.dimensions_db_file, redis_backed=True)
=======
        db = deepy.dimensions.DimensionsDB(None, redis_backed=True)
>>>>>>> origin/master
        intfs = db.get_by_name('interfaces')['positions'] #interfaces

        out = {}
        for pos, val in intfs.items():
            desc = val.get('description', '')
            name = val.get('name', '')
            try:
                ifIndex = \
                  str(val['attributes']['computed']['interface']['ifindex'])
                ip = val['attributes']['computed']['interface']['flow_ip']
            except KeyError:
                continue

            if ip == match_ip:
                out[ifIndex] = (pos, desc, name)

        self.write_json(out)
        self.finish()

class PeerInterfacesPage(base.TileHandler):
    template = 'templates/peer_interfaces.html'
    tile_id = 'tile_peerinterfaces'
    template_args = {'title': 'Peer Interfaces'}

    def get(self, *path_args, **path_kwargs):
        if path_kwargs.has_key('pos'):
            self.tile_id += '_' + path_kwargs['pos']
        else:
            path_kwargs['pos'] = ''

        return super(PeerInterfacesPage, self).get(*path_args, **path_kwargs)

class RouterInterfacesPage(base.TileHandler):
    template = 'templates/peer_interfaces.html'
    tile_id = 'tile_routerinterfaces'
    template_args = {'title': 'Router Interfaces'}

    def get(self, *path_args, **path_kwargs):
        if path_kwargs.has_key('pos'):
            self.tile_id += '_' + path_kwargs['pos']
        else:
            path_kwargs['pos'] = ''

        return super(RouterInterfacesPage, self).get(*path_args, **path_kwargs)

class InterfacePage(base.TileHandler):
    template = 'templates/interface.html'
    tile_id = 'tile_peerinterface'
    template_args = {'title': 'Interface'}

    def get(self, *path_args, **path_kwargs):
        if path_kwargs.has_key('iface'):
            self.tile_id += '_' + path_kwargs['iface']
        else:
            path_kwargs['iface'] = ''

        return super(InterfacePage, self).get(*path_args, **path_kwargs)

class StatPage(base.TileHandler):
    template = 'templates/config_vm_stats.html'
    template_args = {'title': 'VM Stats'}

    def get(self, *path_args, **path_kwargs):
        return super(StatPage, self).get(*path_args, **path_kwargs)

# class PeersPage(base.TileHandler):
#     template = 'templates/peers.html'
#     tile_id = 'tile_peers'
#     template_args = {'title': 'Peers'}

class PeersPage(base.TileHandler):
    template = 'templates/peers.html'
    tile_id = 'tile_peers'
    template_args = {'title': 'Peers'}

    def get(self, *path_args, **path_kwargs):
        return super(PeersPage, self).get(*path_args, **path_kwargs)

class RoutersPage(base.TileHandler):
    template = 'templates/peers.html'
    tile_id = 'tile_routers'
    template_args = {'title': 'Routers'}

    def get(self, *path_args, **path_kwargs):
        return super(RoutersPage, self).get(*path_args, **path_kwargs)


################################################################################
# API Calls
################################################################################

class Peers(base.ApiHandler):
    def get(self):
        '''
        Get all peers, plus number of associated intfs/asns
        Used in peers.html
        '''
<<<<<<< HEAD
        db = deepy.dimensions.DimensionsDB(db_file=deepy.cfg.dimensions_db_file, redis_backed=True)
=======
        db = deepy.dimensions.DimensionsDB(None, redis_backed=True)
>>>>>>> origin/master

        peers = db.get_by_name('peer')
        if peers is not None:
            peers = peers['positions']
            peer_to_ifaces, iface_to_peers = dpi.make_peer_iface_lookups(db)

        out_peers = []
        if peers is not None:
            for pos, val in peers.items():
                pos = int(pos)

                peer_asns = set()
                match = val.get('match')
                if match:
                    asns = match.get('peer_as', [])
                    peer_asns.update(map(int, asns))

                if peer_asns:
                    intfs = peer_to_ifaces.get(pos, [])
                    name = val.get('name')
                    oval = {'name': name,
                            'asns':list(peer_asns),
                            'num_intf': len(intfs),
                            'pos':pos}
                    out_peers.append(oval)

        self.write_json(out_peers)
        self.finish()

class PeerInterfaces(base.ApiHandler):
    def get(self, peer):
        '''
        Get all interfaces for a peer
        Used in peer_interfaces.html
        '''

        try:
            peer_pos = str(int(peer))
        except ValueError:
            self.finish({'error':'could not parse peer'})
            return

<<<<<<< HEAD
        db = deepy.dimensions.DimensionsDB(db_file=deepy.cfg.dimensions_db_file, redis_backed=True)
=======
        db = deepy.dimensions.DimensionsDB(None, redis_backed=True)
>>>>>>> origin/master
        peer_to_ifaces, iface_to_peers = dpi.make_peer_iface_lookups(db)

        # peer
        peer = db.get_by_name('peer')['positions']

        val = peer[peer_pos]
        peer_name = val.get('name')

        interfaces = []
        intfs = peer_to_ifaces.get(int(peer_pos), [])
        for pos, val, meta in intfs:
            desc = val.get('description', '')
            name = val.get('name', '')

            try:
                ifIndex = \
                  str(val['attributes']['computed']['interface']['ifindex'])
                ip = val['attributes']['computed']['interface']['flow_ip']
            except KeyError:
                continue

            peer_as = val.get('peer_as')

            oval = {'name':name, 'desc':desc, 'ip':ip,
                    'ifIndex':ifIndex, 'peer_as':peer_as, 'pos':pos, 'meta':meta}
            interfaces.append(oval)

        out = {'name':peer_name, 'interfaces':interfaces}
        self.write_json(out)
        self.finish()

class InterfacePeer(base.ApiHandler):
    def get(self, iface):
        '''
        Lookup peer from interface
        Used in interface.html
        '''
<<<<<<< HEAD
        db = deepy.dimensions.DimensionsDB(db_file=deepy.cfg.dimensions_db_file, redis_backed=True)
=======
        db = deepy.dimensions.DimensionsDB(None, redis_backed=True)
>>>>>>> origin/master
        peer_to_ifaces, iface_to_peers = dpi.make_peer_iface_lookups(db)

        peers = iface_to_peers.get(int(iface), [])
        peer_pos = [pos for pos, val in peers]

        out = {'peers':peer_pos}
        self.write_json(out)
        self.finish()

def make_ip_to_intfs(db):
    intfs = db.get_by_name('interfaces')['positions']
    ip_to_intfs = {}
    for pos, val in intfs.items():
        pos = int(pos)
        try:
            ifIndex = int(val['attributes']['computed']['interface']['ifindex'])
            ip = val['attributes']['computed']['interface']['flow_ip']
        except KeyError:
            continue
        ip_to_intfs.setdefault(ip, []).append((pos, ifIndex, val))
    return ip_to_intfs

class Routers(base.ApiHandler):
    def get(self):
<<<<<<< HEAD
        db = deepy.dimensions.DimensionsDB(db_file=deepy.cfg.dimensions_db_file, redis_backed=True)
=======
        db = deepy.dimensions.DimensionsDB(None, redis_backed=True)
>>>>>>> origin/master
        ip_to_intfs = make_ip_to_intfs(db)

        out = []
        routers = db.get_by_name('router')['positions']
        for pos, val in routers.items():
            pos = int(pos)
            name = val.get('name')

            firstseen = val.get('firstSeen')
            lastseen = val.get('lastSeen')

            try:
                ip = val['attributes']['computed']['router']['flow_ip']
            except KeyError:
                self.finish({})
            intfs = ip_to_intfs.get(ip, [])

            oval = {'name': name,
                    'firstseen': firstseen,
                    'lastseen': lastseen,
                    'ip': ip,
                    'num_intf': len(intfs),
                    'pos':pos}
            out.append(oval)

        self.write_json(out)
        self.finish()

class RouterInterfaces(base.ApiHandler):
    def get(self, router):
        router_pos = router
<<<<<<< HEAD
        db = deepy.dimensions.DimensionsDB(db_file=deepy.cfg.dimensions_db_file, redis_backed=True)
=======
        db = deepy.dimensions.DimensionsDB(None, redis_backed=True)
>>>>>>> origin/master
        ip_to_intfs = make_ip_to_intfs(db)

        out = []
        routers = db.get_by_name('router')['positions']

        val = routers.get(router_pos)
        name = val.get('name')

        try:
            ip = val['attributes']['computed']['router']['flow_ip']
        except KeyError:
            self.finish({})

        intfs = ip_to_intfs.get(ip, [])

        ointfs = []
        for pos, ifIndex, intf in intfs:
            name = intf.get('name')
            desc = intf.get('description')
            if 'cname' in intf:
                ip, ifIndex = intf.get('cname').split(':')
            else:
                ip = intf.get('router_ip')
                ifIndex = intf.get('ifindex')
            oval = {'name': name,
                    'ip': ip,
                    'ifIndex': ifIndex,
                    'desc':desc,
                    'pos': pos
                    }
            ointfs.append(oval)

        out = {'name':name, 'interfaces':ointfs}
        self.write_json(out)
        self.finish()



class ASNSHandler(base.ApiHandler):
    def get(self):
        params = self.get_argument_list_dict()

        # TODO flag for 'naim-lite' version (asn, name, maybe desc)
        query = params.get('q') or params.get('query')

        try:
            asndb = deepy.asndb.get_default_asndb()
            if query:
                deepy.log.debug("Executing fuzzy match ASN search for '{}'".format(query))
                results = asndb.fuzzy_query(query)
            else:
                deepy.log.debug("Returning all ASNs")
                results = asndb.get_all_asns()
        except OperationalError as e:
            self.api_error("Error when executing query against ASNDB", [e])
            return

        self.write_json(results)
        self.finish()

class ASNHandler(base.ApiHandler):
    def get(self, asn_id):
        try:
            asndb = deepy.asndb.get_default_asndb()
            asn = asndb.get_asn(asn_id)
        except OperationalError as e:
            self.api_error("Error when executing query against ASNDB", [e])
            return
        self.write_json(asn)
        self.finish()



        

class RealTimeDataApiHandler(base.ApiHandler):
    def get(self):

        ret = {}

        self.set_header("Content-Type", "application/json; charset=UTF-8")    

        try:
            r_server = redis.Redis("localhost")
        except:
            self.write(ret)
            self.finish()
            return

        try:
            flow = r_server.get("latest_h5flow")
        except:
            flow = None
            
        #queue = deepy.redis_queue.RedisQueue("h5flow")
        #ret = queue.get(block=False, timeout=1)
        
        #if ret is None:
        #    self.api_error('redis-get-failed')
        #    return
        if flow:
            flow = flow.replace("'", "\"")
            flow = flow.replace("L", "")
            flow = json.loads(flow)
            ret.update(flow)

        try:
            dns = r_server.get("latest_dnsflow")
        except:
            dns = None
            
        if dns:
            dns = dns.replace("'", "\"")
            dns = dns.replace("L", "")
            dns = dns.replace("\\", "")
            dns = deepy.util.to_ascii_printable(dns, replace='')
            dns = json.loads(dns)
            ret.update(dns)
        
        self.write(ret)
        self.finish()



class ConnectorsStatusApiHandler(base.ApiHandler):
    def get(self):

        ret = {}

        self.set_header("Content-Type", "application/json; charset=UTF-8")

        redis_server_name = "localhost"
        if deepy.util.vm_or_slice_config_get("redis_server"):
             redis_server_name = redis_server_name
    
        try:
            r_server = redis.Redis(redis_server_name)
        except:
            self.write(ret)
            self.finish()
            return
            
        #queue = deepy.redis_queue.RedisQueue("h5flow")
        #ret = queue.get(block=False, timeout=1)
        
        #if ret is None:
        #    self.api_error('redis-get-failed')
        #    return
        try:
            netflow = r_server.get("connectors:status:netflow")
        except:
            netflow = None
            
        if netflow:
            netflow = netflow.replace("'", "\"")
            netflow = netflow.replace("L", "")
            netflow = json.loads(netflow)
            ret.update({"netflow": netflow})

        try:
            dnsflow = r_server.get("connectors:status:dnsflow")
        except:
            dnsflow = None
            
        if dnsflow:
            dnsflow = dnsflow.replace("'", "\"")
            dnsflow = dnsflow.replace("L", "")
            dnsflow = json.loads(dnsflow)
            ret.update({"dnsflow": dnsflow})

        self.write(ret)
        self.finish()



class VPNStatusApiHandler(base.ApiHandler):
    def get(self):

        ret = {}

        self.set_header("Content-Type", "application/json; charset=UTF-8")

        local_path = deepy.cfg.cache_dir + "/vpn/users.json.gz"
        tmp = deepy.store.simple_load_json(local_path, force_remote='s3')
        if tmp:
            ret = tmp

        self.write(ret)
        self.finish()


class DDoSStatusApiHandler(base.ApiHandler):
    def get(self):

        ret = {}

        self.set_header("Content-Type", "application/json; charset=UTF-8")    

        try:
            r_server = redis.Redis("localhost")
        except:
            self.write(ret)
            self.finish()
            return
      
        try:
            ddos = r_server.get("ddos:counters")
        except:
            ddos = None
            
        if ddos:
            ddos = ddos.replace("'", "\"")
            ddos = ddos.replace("L", "")
            ddos = json.loads(ddos)
            ret.update(ddos)

        self.write(ret)
        self.finish()
