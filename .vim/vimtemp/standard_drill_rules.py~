import os.path
import deepy.cfg
import deepy.dimensions
import os.path

from make_functions import query, exclude_slice, time_dist, convert_to_names, sort, get_partition_dimensions, set_query_timestep, set_query_bundle_rollup

DRILL_DIR = os.path.join('$(cubes_dir)', 'drill')

def setup_defaults(input_file_glob, partition_dimensions, dim_top, drillname,
                   input_cube_name='drill_small'):
    if input_file_glob is None:
        input_file_glob = os.path.join("$(cubes_dir)", input_cube_name,
                                       'minutes/cube.%Y-%m-%d-%H-%M.h5')

    if drillname is None:
        drillname = dim_top

    if partition_dimensions is None:
        partition_dimensions = get_partition_dimensions()
        drillname_part = drillname + '_part_'

    return input_file_glob, partition_dimensions, drillname, drillname_part

warned_no_index = False

def make_drill_bundles(dim_top, dim_drills, partition_dimensions=None,
                       input_file_glob=None, timestep=300, bundle_type='bundle',
                       drillname=None, input_cube_name='drill_small'):
    '''
    make a whole set of bundles needed to create the comple drill in path
    summary, drill, queries, days, months, etc
    '''

    # SUP-148 must resolve aliases before removing dim_top
    dim_idx = None
    global warned_no_index
    if os.path.exists(deepy.cfg.dimensions_idx_file):
        if dim_idx == None:
            dim_idx = deepy.dimensions.DimensionsIdx()
    if not dim_idx and not warned_no_index:
        warned_no_index = True
        deepy.log.warn('dimension-index-not-available: cannot convert dimension aliases to cnames')

    def dim_name_to_cname(name):
        if not dim_idx:
            return name

        dim_name, suffix = deepy.dimensions.dim_game_split(name)
        dim = dim_idx.get_dim_by_name(dim_name)
        return dim['cname'] + suffix if dim else name

    dim_drills_cnames = map(dim_name_to_cname, dim_drills)
    dim_top_cname = dim_name_to_cname(dim_top)
    dim_drills_no_top = list(set(dim_drills_cnames) - set([dim_top_cname]))

    input_file_glob, partition_dimensions, drillname, drillname_part = \
       setup_defaults(input_file_glob, partition_dimensions, dim_top, drillname,
                   input_cube_name=input_cube_name)

    out = {}

    ####################
    # summary
    name, po = make_bundle_drill_day_summary(drillname, dim_top, input_file_glob, timestep)
    po['type'] = bundle_type
    out[name] = po

    # summary partitioned
    for part_dim in partition_dimensions:
        name, po = make_bundle_drill_day_summary(drillname_part + part_dim, dim_top, input_file_glob, timestep, [part_dim])
        po['type'] = bundle_type
        out[name] = po

    ####################
    # drill in
    name, po = make_bundle_drill_day(drillname, dim_top, dim_drills_no_top, input_file_glob, timestep)
    po['type'] = bundle_type
    out[name] = po

    # drill in partitioned
    for part_dim in partition_dimensions:
        name, po = make_bundle_drill_day(drillname_part + part_dim, dim_top, dim_drills_no_top, input_file_glob, timestep, [part_dim])
        po['type'] = bundle_type
        out[name] = po

    ####################
    # summary query
    name, po = make_bundle_drill_query_summary(drillname, dim_top)
    po['type'] = bundle_type
    out[name] = po

    for part_dim in partition_dimensions:
        name, po = make_bundle_drill_query_summary(drillname_part + part_dim, dim_top)
        po['type'] = bundle_type
        out[name] = po

    ####################
    # drill in query
    name, po = make_bundle_drill_query(drillname, dim_top, dim_drills_no_top)
    po['type'] = bundle_type
    out[name] = po

    for part_dim in partition_dimensions:
        name, po = make_bundle_drill_query(drillname_part + part_dim, dim_top, dim_drills_no_top)
        po['type'] = bundle_type
        out[name] = po

    ####################
    # month summary
    name, po = make_bundle_drill_month_summary(drillname, dim_top)
    po['type'] = bundle_type
    out[name] = po
    out[name]['prev_month_days'] = 7

    # month summary partitioned
    for part_dim in partition_dimensions:
        name, po = make_bundle_drill_month_summary(drillname_part + part_dim, dim_top, [part_dim])
        po['type'] = bundle_type
        out[name] = po
        out[name]['prev_month_days'] = 7

    ####################
    # month drill in
    name, po = make_bundle_drill_month(drillname, dim_top, dim_drills_no_top, input_file_glob, timestep)
    po['type'] = bundle_type
    out[name] = po
    out[name]['prev_month_days'] = 7

    # month drill in partitioned
    for part_dim in partition_dimensions:
        name, po = make_bundle_drill_month(drillname_part + part_dim, dim_top, dim_drills_no_top, input_file_glob, timestep, [part_dim])
        po['type'] = bundle_type
        out[name] = po
        out[name]['prev_month_days'] = 7

    return out

################################################################################
# bundle2 query-compatible bundles
################################################################################

def get_names(dim_tops):
    # FIXME name is divorced from the actual definition below
    names = []
    formats = 'bundle2_drill_{dim_top}1_summary bundle2_drill_{dim_top}1'.split()
    #formats += 'bundle2_drill_{dim_top}1_month_summary bundle2_drill_{dim_top}1_month'.split()

    formats += 'drill_{dim_top}_month_summary'.split()
    formats += 'drill_{dim_top}_summary drill_{dim_top}'.split()

    for d in dim_tops:
        for f in formats:
            names.append(f.format(dim_top=d))
    return names

def make_drill_bundle2(dim_top, one='1'):
    '''
    stubs for backward compatible bundle2
    this allows bundle2 to be queried still but you can't make them
    '''
    out = []
    formats = 'bundle2_drill_{dim_top}{one} bundle2_drill_{dim_top}{one}_summary'.split()

    for f in formats:
        bundle_name = f.format(dim_top=dim_top, one=one)
        dname = 'drill_{}{}'.format(dim_top, one)
        location = '$(bundles2_dir)/{}/months/%Y-%m/'.format(dname)
        if f.endswith('summary'):
            location = os.path.join(location, 'summary/')

        b = {'format_args': {'location':location, 'dim_top': dim_top} }
        out.append((bundle_name, b))

    return out

################################################################################
# day bundles
################################################################################

def day_summary_filename(dim_top):
    def make(fname):
        return os.path.join(DRILL_DIR, dim_top, 'days', fname, 'cube.%Y-%m-%d.h5')
    return make

def make_bundle_drill_day_summary(drillname, dim_top, input_file_glob, timestep, partition_dimensions=None):
    '''
    This make day cubes for either month bundles or multi-day queries
    this function dynamically produces a bunch of queries that target cubes
    that make up "bundles"
    '''
    if partition_dimensions is None:
        partition_dimensions = []

    queries = {}

    mt = day_summary_filename(drillname)

    bundle_name = 'drill_day_{}_summary'.format(drillname)
    target = os.path.join(DRILL_DIR, drillname, 'days', 'markers', 'summary.%Y-%m-%d.marker')
    recipe = 'bundle2.py -M {} -m {} -t %Y-%m-%d'.format(bundle_name, target)
    depends = get_depends_from_file_glob(input_file_glob)
    o = {'make_time_step': 86400, # used in bundle query
         'time_step': timestep, # for building (jobs.py)
         'file_step': '1d',
         'recipe': [recipe],
         'dim_top': dim_top,
         'queries': queries,
         'depends_one_or_more': depends,
         'target': target,
         }


    def aq(*a, **k):
        return query(*a, input_file_glob=input_file_glob, **k)

    exclude_slices = [exclude_slice(dim_top, [None])]
    for pd in partition_dimensions:
        exclude_slices.append(exclude_slice(pd, [None]))

    name = 'summary.' + dim_top
    summary_ds = ['timestamp'] + partition_dimensions
    queries[name] = aq(name, summary_ds, exclude_slices, [time_dist('days')], target=mt('summary'))

    # list for time datatable below
    # NOTE timeseries-stacked-graph is the same as this (same data)
    # timeseries.dim is computed at runtime from list
    name = 'list.' + dim_top
    list_ds = ['timestamp', dim_top] + partition_dimensions
    queries[name] = aq(name, list_ds, exclude_slices, [time_dist('days')], target=mt('list'))

    return bundle_name, o

def day_drill_filename(dim_top, dim_drill):
    def make(fname):
        return os.path.join(DRILL_DIR, dim_top, 'days/drill/{}/{}/cube.%Y-%m-%d.h5'.format(dim_drill, fname))
    return make

def get_depends_from_file_glob(input_file_glob):
    depends = {}
    if 'interface' in input_file_glob:
        depends['cube_interface_5min'] = "5min"
    elif 'drill_small' in input_file_glob:
        depends['cube_drill_small_5min'] = "5min"
    elif 'datacenter' in input_file_glob:
        depends['cube_datacenter_5min'] = "5min"
    elif 'backbone_small' in input_file_glob:
        depends['cube_backbone_small_hour'] = "hour"
    else:
        raise ValueError("Expected either drill_small, datacenter or interface as input to bundles, something is wrong")

    return depends


def make_bundle_drill_day(drillname, dim_top, dim_drills, input_file_glob, timestep, partition_dimensions=None):
    if partition_dimensions is None:
        partition_dimensions = []

    queries = {}
    target = os.path.join(DRILL_DIR, drillname, 'days', 'markers', 'drill.%Y-%m-%d.marker')
    bundle_name = 'drill_day_{}'.format(drillname)
    recipe = 'bundle2.py -M {} -m {} -t %Y-%m-%d'.format(bundle_name, target)

    depends = get_depends_from_file_glob(input_file_glob)

    o = {'recipe': [recipe],
         'make_time_step': 86400,
         'file_step': '1d',
         'time_step': timestep, # for building (jobs.py)
         'queries': queries,
         'dim_top': dim_top,
         'dim_drills': dim_drills,
         'depends_one_or_more': depends,
         'target': target,
         }

    def aq(*a, **k):
        return query(*a, input_file_glob=input_file_glob, **k)

    exclude_slices = [exclude_slice(dim_top, [None])]
    for pd in partition_dimensions:
        exclude_slices.append(exclude_slice(pd, [None]))

    for dim_drill in dim_drills:
        mtd = day_drill_filename(drillname, dim_drill)
        drill_slices = [exclude_slice(dim_drill, [None])] + exclude_slices

        drill_ds = ['timestamp', dim_top] + partition_dimensions
        name = 'summary.{}.{}'.format(dim_top, dim_drill)
        queries[name] = aq(name, drill_ds, drill_slices, applies=[time_dist('days')], target=mtd('summary'))

        drill_ds = ['timestamp', dim_top, dim_drill] + partition_dimensions
        name = 'list.{}.{}'.format(dim_top, dim_drill)
        queries[name] = aq(name, drill_ds, drill_slices, applies=[time_dist('days')], target=mtd('list'))

    return bundle_name, o

################################################################################
# month bundles
################################################################################

def make_bundle_drill_month_summary(drillname, dim_top, partition_dimensions=None):
    '''
    build a month bundle
    built from make_bundle_drill_day_summary cubes

    this will be rolled up via the normal c rollup
    the cubes it uses were rolled up using rollup_bundle/finalize_bundle
    '''

    pd = []
    if partition_dimensions:
        pd = partition_dimensions

    bundle_name = 'drill_month_{}_summary'.format(drillname)
    target = os.path.join(DRILL_DIR, drillname, 'months/markers/summary.%Y-%m.marker')
    recipe = 'bundle2.py -M {} -m {} -t %Y-%m'.format(bundle_name, target)

    summ_name = 'summary'
    summ_fglob = os.path.join(DRILL_DIR, drillname, 'days', summ_name, 'cube.%Y-%m-%d.h5')

    queries = {}
    depends = {}
    depends['drill_day_{}_summary'.format(drillname)] = 'day'
    o = {'make_time_step': 'month',
         'file_step': 'month',
         'time_step': 86400, # for building (jobs.py)
         'recipe': [recipe],
         'dim_top': dim_top,
         'queries': queries,
         'depends_one_or_more': depends,
         'target': target,
         }

    def mt(fname):
        return os.path.join(DRILL_DIR, drillname, 'months', fname, 'cube.%Y-%m.h5')

    name = 'summary'
    fglob = os.path.join(DRILL_DIR, drillname, 'days', name, 'cube.%Y-%m-%d.h5')
    if pd:
        queries[name] = query(name, dimensions=pd, input_file_glob=fglob, target=mt(name))
    else:
        queries[name] = query(name, sum_all=True, input_file_glob=fglob, target=mt(name))
    # use list for source of rest of queries
    list_fglob = os.path.join(DRILL_DIR, drillname, 'days', 'list', 'cube.%Y-%m-%d.h5')
    summary_fglob = os.path.join(DRILL_DIR, drillname, 'days', 'summary', 'cube.%Y-%m-%d.h5')

    name = 'list'
    queries[name] = query(name, dimensions=[dim_top]+pd, input_file_glob=list_fglob, target=mt(name))

    # timeseries
    name = 'timeseries'
    queries[name] = query(name, dimensions=['timestamp']+pd, input_file_glob=summary_fglob, target=mt(name))

    # stacked graph
    name = 'timeseries.dim'
    queries[name] = query(name, dimensions=['timestamp', dim_top]+pd, input_file_glob=list_fglob, target=mt(name))

    # dashboard tile
    name = 'dashboard'
    args = ['avg.total.bps', 'desc', 0, 25]
    if pd:
        args.append(pd[0]) # only one context ...
    applies = [convert_to_names('true'), sort(*args)]
    queries[name] = query(name, [dim_top]+pd, applies=applies, input_file_glob=list_fglob, target=mt(name))

    # timeseries dashboard tile
    name = 'dashboard.timeseries'
    args = ['avg.total.bps', 'desc', 0, 25]
    if pd:
        args.append(pd[0]) # only one context ...
    queries[name] = query(name, ['timestamp']+pd, input_file_glob=list_fglob, target=mt(name))

    set_query_bundle_rollup(queries.values())
    set_query_timestep(queries.values(), 'days')
    return bundle_name, o

def make_bundle_drill_month(drillname, dim_top, dim_drills, input_file_glob, timestep, partition_dimensions=None):
    '''
    built from make_bundle_drill_day cubes
    '''
    if partition_dimensions is None:
        partition_dimensions = []

    queries = {}
    target = os.path.join(DRILL_DIR, drillname, 'months', 'markers', 'drill.%Y-%m.marker')
    bundle_name = 'drill_month_{}'.format(drillname)
    recipe = 'bundle2.py -M {} -m {} -t %Y-%m'.format(bundle_name, target)
    depends = get_depends_from_file_glob(input_file_glob)
    o = {'recipe': [recipe],
         'make_time_step': 'month',
         'file_step': 'month',
         'time_step': timestep, # for building (jobs.py)
         'queries': queries,
         'dim_top': dim_top,
         'dim_drills': dim_drills,
         'depends_one_or_more': depends,
         'target': target,
         }

    exclude_slices = [exclude_slice(dim_top, [None])]
    for pd in partition_dimensions:
        exclude_slices.append(exclude_slice(pd, [None]))

    def mt(fname):
        return os.path.join(DRILL_DIR, drillname, 'months', 'drill', fname, 'cube.%Y-%m.h5')

    # FIXME don't need summary and timeseries
    list_fglob = os.path.join(DRILL_DIR, drillname, 'days', 'list', 'cube.%Y-%m-%d.h5')
    # second level drill
    name = 'summary'
    queries[name] = query(name, dimensions=[dim_top] + partition_dimensions, input_file_glob=list_fglob, target=mt(name), slices=exclude_slices)

    # timeseries
    name = 'timeseries'
    queries[name] = query(name, dimensions=['timestamp', dim_top] + partition_dimensions, input_file_glob=list_fglob, target=mt(name), slices=exclude_slices)

    for dim_drill in dim_drills:

        # We need dim_top in all queries since we will
        # slice on it during query
        #
        # We do not need to slice out dim_drill since the day cubes
        # we are building from already did that

        def mtd(fname):
            return os.path.join(DRILL_DIR, drillname, 'months/drill/{}/{}/cube.%Y-%m.h5'.format(dim_drill, fname))

        #drill_slices = [exclude_slice(dim_drill, [None])] + exclude_slices

        # summary glob
        sum_glob = os.path.join(DRILL_DIR, drillname, 'days/drill/{}/{}/cube.%Y-%m-%d.h5'.format(dim_drill, 'summary'))

        # summary
        name = 'summary.{}'.format(dim_drill)
        queries[name] = query(name, [dim_top] + partition_dimensions, input_file_glob=sum_glob, target=mtd('summary'))

        # timeseries
        name = 'timeseries.{}'.format(dim_drill)
        queries[name] = query(name, ['timestamp', dim_top] + partition_dimensions, input_file_glob=sum_glob, target=mtd('timeseries'))

        # list glob for following
        list_glob = os.path.join(DRILL_DIR, drillname, 'days/drill/{}/{}/cube.%Y-%m-%d.h5'.format(dim_drill, 'list'))

        # list
        drill_ds = [dim_top, dim_drill] + partition_dimensions
        name = 'list.{}'.format(dim_drill)
        queries[name] = query(name, drill_ds, input_file_glob=list_glob, target=mtd('list'))

        # stacked graphs
        drill_ds = [dim_top, dim_drill] + partition_dimensions
        name = 'timeseries.dim.{}'.format(dim_drill)
        queries[name] = query(name, ['timestamp'] + drill_ds, input_file_glob=list_glob, target=mtd('timeseries.dim'))

    set_query_bundle_rollup(queries.values())
    set_query_timestep(queries.values(), 'days')
    return bundle_name, o

################################################################################
# query only bundles
################################################################################

def make_bundle_drill_query_summary(drillname, dim_top):
    '''
    Query only bundle, corresponds to: make_bundle_drill_day_summary

    query over a bunch of days
    setup individual queries to do this

    This is not meant to be executed by a jobs.py or produce a file on disk
    '''

    bundle_name = 'drill_{}_summary'.format(drillname)

    queries = {}
    depends = {}
    depends['drill_day_{}_summary'.format(drillname)] = '1d'
    o = {
         # don't need target/recipe/time_step, for building only by jobs.py/bundle2.py
         'make_time_step': 86400, # used by cube.py:bundle_query()
         'file_step': '1d',
         'dim_top': dim_top,
         'queries': queries,
         'depends': depends
    }

    pat_target = day_summary_filename(drillname)

    name = 'summary'
    queries[name] = query(name, sum_all=True, target=pat_target(name))

    name = 'list'
    queries[name] = query(name, dimensions=[dim_top], target=pat_target(name))

    # source for timeseries/stacked graph queries is list.<dim_top>
    # list has both timestamp and dim_top

    # timeseries
    oname = 'timeseries'
    queries[oname] = query(oname, dimensions=['timestamp'], target=pat_target('summary'))

    # timeseries.dim
    oname = 'timeseries.dim'
    queries[oname] = query(oname, dimensions=['timestamp', dim_top], target=pat_target('list'))

    set_query_bundle_rollup(queries.values())
    return bundle_name, o

def make_bundle_drill_query(drillname, dim_top, dim_drills):
    '''
    Query only bundle, corresponds to make_bundle_drill_day

    query over a bunch of days
    setup individual queries to do this

    This is not meant to be executed by a jobs.py or produce a file on disk
    '''

    bundle_name = 'drill_{}'.format(drillname)

    queries = {}
    depends = {}
    depends['drill_day_{}'.format(drillname)] = '1d'
    o = {
         # don't need target/recipe/time_step, for building only by jobs.py/bundle2.py
         'make_time_step': 86400, # used by cube.py:bundle_query()
         'file_step': '1d',
         'queries': queries,
         'dim_top': dim_top,
         'dim_drills': dim_drills,
         'depends': depends}

    list_pat = os.path.join(DRILL_DIR, drillname, 'days', 'list', 'cube.%Y-%m-%d.h5')

    name = 'summary'
    queries[name] = query(name, dimensions=[dim_top], target=list_pat)

    qname = 'timeseries'
    queries[qname] = query(qname, dimensions=['timestamp', dim_top], target=list_pat)

    for dim_drill in dim_drills:

        # Target is a misnomer in this case, this is what the query will glob.
        # In a normal bundle, it would have been what it produced
        # but this is a query only bundle.
        mtd = day_drill_filename(drillname, dim_drill)

        # summary
        name = 'summary.{}'.format(dim_drill)
        queries[name] = query(name, sum_all=True, target=mtd('summary'))

        name = 'timeseries.{}'.format(dim_drill)
        queries[name] = query(name, ['timestamp'], target=mtd('summary'))

        # source is list which has timestamp, dim_top, dim_drill

        # first-level-drill: top-5-bar-graph blocks
        # second-level-drill: list
        name = 'list.' + dim_drill
        queries[name] = query(name, dimensions=[dim_drill], target=mtd('list'))

        # second-level-drill: stacked graph
        name = 'timeseries.dim.' + dim_drill
        queries[name] = query(name, dimensions=['timestamp', dim_drill], target=mtd('list'))

    set_query_bundle_rollup(queries.values())
    return bundle_name, o

def add_dashboard_query(queries, dim_top, drillname=None):
    if drillname is None:
        drillname = dim_top

    # bar graph
    name = 'dashboard.' + drillname
    target = os.path.join(DRILL_DIR, drillname, 'months', 'dashboard', 'cube.%Y-%m.h5')
    queries[name] = query(name, target=target)

    # timeseries
    name = 'dashboard.timeseries.' + drillname
    target = os.path.join(DRILL_DIR, drillname, 'months', 'dashboard.timeseries', 'cube.%Y-%m.h5')
    queries[name] = query(name, target=target)

def make_dashboard_month_query(dim_tops):
    '''
    query all dashboard tile cubes made in make_bundle_drill_month_summary
    '''
    queries = {}
    depends = {}
    o = {
         # don't need target/recipe/time_step, for building only by jobs.py/bundle2.py
         'make_time_step': 86400, # used by cube.py:bundle_query()
         'file_step': '1d',
         'queries': queries}

    for dim_top in dim_tops:
        add_dashboard_query(queries, dim_top)
    o['depends'] = depends

    name = 'dashboard'
    return name, o

