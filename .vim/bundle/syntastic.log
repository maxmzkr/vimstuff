
chdir(/usr/share/vim)
fchdir() to previous dir
sourcing "$VIM/vimrc"
line 1: " All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by
line 2: " the call to :runtime you can find below.  If you wish to change any of those
line 3: " settings, you should do it in this file (/etc/vim/vimrc), since debian.vim
line 4: " will be overwritten everytime an upgrade of the vim packages is performed.
line 5: " It is recommended to make changes after sourcing debian.vim since it alters
line 6: " the value of the 'compatible' option.
line 7: 
line 8: " This line should not be removed as it ensures that various options are
line 9: " properly set to work with the Vim-related packages available in Debian.
line 10: runtime! debian.vim
Searching for "debian.vim" in "/home/max/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/home/max/.vim/after"
Searching for "/home/max/.vim/debian.vim"
Searching for "/usr/share/vim/vimfiles/debian.vim"
Searching for "/usr/share/vim/vim74/debian.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 10: sourcing "/usr/share/vim/vim74/debian.vim"
line 1: " Debian system-wide default configuration Vim
line 2: 
line 3: set runtimepath=~/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,~/.vim/after
line 4: 
line 5: " Normally we use vim-extensions. If you want true vi-compatibility
line 6: " remove change the following statements
line 7: set nocompatible^I" Use Vim defaults instead of 100% vi compatibility
line 8: set backspace=indent,eol,start^I" more powerful backspacing
line 9: 
line 10: " Now we set some defaults for the editor
line 11: set history=50^I^I" keep 50 lines of command line history
line 12: set ruler^I^I" show the cursor position all the time
line 13: 
line 14: " modelines have historically been a source of security/resource
line 15: " vulnerabilities -- disable by default, even when 'nocompatible' is set
line 16: set nomodeline
line 17: 
line 18: " Suffixes that get lower priority when doing tab completion for filenames.
line 19: " These are files we are not likely to want to edit or read.
line 20: set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc
line 21: 
line 22: " We know xterm-debian is a color terminal
line 23: if &term =~ "xterm-debian" || &term =~ "xterm-xfree86"
line 24:   set t_Co=16
line 25:   set t_Sf=^[[3%dm
line 26:   set t_Sb=^[[4%dm
line 27: endif
line 28: 
line 29: " Some Debian-specific things
line 30: if has("autocmd")
line 31:   " set mail filetype for reportbug's temp files
line 32:   augroup debian
line 33:     au BufRead reportbug-*^I^Iset ft=mail
line 34:   augroup END
line 35: endif
line 36: 
line 37: " Set paper size from /etc/papersize if available (Debian-specific)
line 38: if filereadable("/etc/papersize")
line 39:   let s:papersize = matchstr(readfile('/etc/papersize', '', 1), '\p*')
line 40:   if strlen(s:papersize)
line 41:     exe "set printoptions+=paper:" . s:papersize
line 41: set printoptions+=paper:letter
line 42:   endif
line 43: endif
line 44: 
line 45: if has('gui_running')
line 46:   " Make shift-insert work like in Xterm
line 47:   map <S-Insert> <MiddleMouse>
line 48:   map! <S-Insert> <MiddleMouse>
line 49: endif
finished sourcing /usr/share/vim/vim74/debian.vim
continuing in /usr/share/vim/vimrc
Searching for "/usr/share/vim/vimfiles/after/debian.vim"
Searching for "/home/max/.vim/after/debian.vim"
line 11: 
line 12: " Uncomment the next line to make Vim more Vi-compatible
line 13: " NOTE: debian.vim sets 'nocompatible'.  Setting 'compatible' changes numerous
line 14: " options, so any other options should be set AFTER setting 'compatible'.
line 15: "set compatible
line 16: 
line 17: " Vim5 and later versions support syntax highlighting. Uncommenting the next
line 18: " line enables syntax highlighting by default.
line 19: if has("syntax")
line 20:   syntax on
line 20: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 20: sourcing "/usr/share/vim/vim74/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 04
line 4: 
line 5: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
line 16: endif
line 17: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/syntax/synload.vim"
Searching for "/var/lib/vim/addons/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim74/syntax/synload.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 19: sourcing "/usr/share/vim/vim74/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2012 Sep 25
line 4: 
line 5: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
line 10: if !has("syntax")
line 11:   finish
line 12: endif
line 13: 
line 14: " let others know that syntax has been switched on
line 15: let syntax_on = 1
line 16: 
line 17: " Set the default highlighting colors.  Use a color scheme if specified.
line 18: if exists("colors_name")
line 19:   exe "colors " . colors_name
line 20: else
line 21:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 21: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim
continuing in /usr/share/vim/vim74/syntax/synload.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/after/syntax/syncolor.vim"
line 22: endif
line 23: 
line 24: " Line continuation is used here, remove 'C' from 'cpoptions'
line 25: let s:cpo_save = &cpo
line 26: set cpo&vim
line 27: 
line 28: " First remove all old syntax autocommands.
line 29: au! Syntax
line 30: 
line 31: au Syntax *^I^Icall s:SynSet()
line 32: 
line 33: fun! s:SynSet()
line 61: 
line 62: 
line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL)
line 68: au Syntax c,cpp,cs,idl,php if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 69: 
line 70: 
line 71: " Source the user-specified syntax highlighting file
line 72: if exists("mysyntaxfile") && filereadable(expand(mysyntaxfile))
line 73:   execute "source " . mysyntaxfile
line 74: endif
line 75: 
line 76: " Restore 'cpoptions'
line 77: let &cpo = s:cpo_save
line 78: unlet s:cpo_save
finished sourcing /usr/share/vim/vim74/syntax/synload.vim
continuing in /usr/share/vim/vim74/syntax/syntax.vim
line 20: 
line 21: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
line 24: else
line 25:   filetype on
Searching for "filetype.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/filetype.vim"
Searching for "/var/lib/vim/addons/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim74/filetype.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 25: sourcing "/usr/share/vim/vim74/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2013 Sep 22
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
line 9: endif
line 10: let did_load_filetypes = 1
line 11: 
line 12: " Line continuation is used here, remove 'C' from 'cpoptions'
line 13: let s:cpo_save = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup filetypedetect
line 17: 
line 18: " Ignored extensions
line 19: if exists("*fnameescape")
line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 33: elseif &verbose > 0
line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 35: endif
line 36: 
line 37: " Pattern used to match file names which should not be inspected.
line 38: " Currently finds compressed files.
line 39: if !exists("g:ft_ignore_pat")
line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 41: endif
line 42: 
line 43: " Function used for patterns that end in a star: don't set the filetype if the
line 44: " file name matches ft_ignore_pat.
line 45: func! s:StarSetf(ft)
line 50: 
line 51: " Abaqus or Trasys
line 52: au BufNewFile,BufRead *.inp^I^I^Icall s:Check_inp()
line 53: 
line 54: func! s:Check_inp()
line 73: 
line 74: " A-A-P recipe
line 75: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 76: 
line 77: " A2ps printing utility
line 78: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 79: 
line 80: " ABAB/4
line 81: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 82: 
line 83: " ABC music notation
line 84: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 85: 
line 86: " ABEL
line 87: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 88: 
line 89: " AceDB
line 90: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 91: 
line 92: " Ada (83, 9X, 95)
line 93: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 94: if has("vms")
line 95:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 96: else
line 97:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 98: endif
line 99: 
line 100: " AHDL
line 101: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 102: 
line 103: " AMPL
line 104: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 105: 
line 106: " Ant
line 107: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 108: 
line 109: " Apache style config file
line 110: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')
line 111: 
line 112: " Apache config file
line 113: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 114: 
line 115: " XA65 MOS6510 cross assembler
line 116: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 117: 
line 118: " Applescript
line 119: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 120: 
line 121: " Applix ELF
line 123: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
line 124: 
line 125: " ALSA configuration
line 126: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 127: 
line 128: " Arc Macro Language
line 129: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 130: 
line 131: " APT config file
line 132: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 133: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 134: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
line 135: 
line 136: " Arch Inventory file
line 137: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 138: 
line 139: " ART*Enterprise (formerly ART-IM)
line 140: au BufNewFile,BufRead *.art^I^I^Isetf art
line 141: 
line 142: " AsciiDoc
line 143: au BufNewFile,BufRead *.asciidoc^I^Isetf asciidoc
line 144: 
line 145: " ASN.1
line 146: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 147: 
line 148: " Active Server Pages (with Visual Basic Script)
line 154: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 155: 
line 156: " Active Server Pages (with Perl or Visual Basic Script)
line 164: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 165: 
line 166: " Grub (must be before catch *.lst)
line 167: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 168: 
line 169: " Assembly (all kinds)
line 170: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 171: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall s:FTasm()
line 172: 
line 173: " This function checks for the kind of assembly that is wanted by the user, or
line 174: " can be detected from the first five lines of the file.
line 175: func! s:FTasm()
line 196: 
line 197: func! s:FTasmsyntax()
line 209: 
line 210: " Macro (VAX)
line 211: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 212: 
line 213: " Atlas
line 214: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 215: 
line 216: " Autoit v3
line 217: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 218: 
line 219: " Autohotkey
line 220: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 221: 
line 222: " Automake
line 223: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 224: 
line 225: " Autotest .at files are actually m4
line 226: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 227: 
line 228: " Avenue
line 229: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 230: 
line 231: " Awk
line 232: au BufNewFile,BufRead *.awk^I^I^Isetf awk
line 233: 
line 234: " B
line 235: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 236: 
line 237: " BASIC or Visual Basic
line 238: au BufNewFile,BufRead *.bas^I^I^Icall s:FTVB("basic")
line 239: 
line 240: " Check if one of the first five lines contains "VB_Name".  In that case it is
line 241: " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
line 242: func! s:FTVB(alt)
line 249: 
line 250: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
line 251: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb
line 252: 
line 253: " IBasic file (similar to QBasic)
line 254: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 255: 
line 256: " FreeBasic file (similar to QBasic)
line 257: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic
line 258: 
line 259: " Batch file for MSDOS.
line 260: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch
line 261: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
line 263: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
line 264: 
line 265: " Batch file for 4DOS
line 266: au BufNewFile,BufRead *.btm^I^I^Icall s:FTbtm()
line 267: func! s:FTbtm()
line 274: 
line 275: " BC calculator
line 276: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 277: 
line 278: " BDF font
line 279: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 280: 
line 281: " BibTeX bibliography database file
line 282: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 283: 
line 284: " BibTeX Bibliography Style
line 285: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 286: 
line 287: " BIND configuration
line 288: au BufNewFile,BufRead named.conf,rndc.conf^Isetf named
line 289: 
line 290: " BIND zone
line 291: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 292: au BufNewFile,BufRead *.db^I^I^Icall s:BindzoneCheck('')
line 293: 
line 294: func! s:BindzoneCheck(default)
line 301: 
line 302: " Blank
line 303: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 304: 
line 305: " Blkid cache file
line 306: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 307: 
line 308: " C or lpc
line 309: au BufNewFile,BufRead *.c^I^I^Icall s:FTlpc()
line 310: 
line 311: func! s:FTlpc()
line 324: 
line 325: " Calendar
line 326: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 327: 
line 328: " C#
line 329: au BufNewFile,BufRead *.cs^I^I^Isetf cs
line 330: 
line 331: " CSDL
line 332: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 333: 
line 334: " Cabal
line 335: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 336: 
line 337: " Cdrdao TOC
line 338: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
line 339: 
line 340: " Cdrdao config
line 341: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 342: 
line 343: " Cfengine
line 344: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 345: 
line 346: " ChaiScript
line 347: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 348: 
line 349: " Comshare Dimension Definition Language
line 350: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 351: 
line 352: " Conary Recipe
line 353: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 354: 
line 355: " Controllable Regex Mutilator
line 356: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 357: 
line 358: " Cyn++
line 359: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 360: 
line 361: " Cynlib
line 362: " .cc and .cpp files can be C++ or Cynlib.
line 364: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 366: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 367: 
line 368: " C++
line 369: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 370: if has("fname_case")
line 371:   au BufNewFile,BufRead *.C,*.H setf cpp
line 372: endif
line 373: 
line 374: " .h files can be C, Ch C++, ObjC or ObjC++.
line 375: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 376: " detected automatically.
line 377: au BufNewFile,BufRead *.h^I^I^Icall s:FTheader()
line 378: 
line 379: func! s:FTheader()
line 394: 
line 395: " Ch (CHscript)
line 396: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 397: 
line 398: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 399: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 400: 
line 401: " Cascading Style Sheets
line 402: au BufNewFile,BufRead *.css^I^I^Isetf css
line 403: 
line 404: " Century Term Command Scripts (*.cmd too)
line 405: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 406: 
line 407: " Changelog
line 409: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog
line 410: 
line 416: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 417: 
line 421: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 422: 
line 423: " CHILL
line 424: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 425: 
line 426: " Changes for WEB and CWEB or CHILL
line 427: au BufNewFile,BufRead *.ch^I^I^Icall s:FTchange()
line 428: 
line 429: " This function checks if one of the first ten lines start with a '@'.  In
line 430: " that case it is probably a change file.
line 431: " If the first line starts with # or ! it's probably a ch file.
line 432: " If a line has "main", "include", "//" ir "/*" it's probably ch.
line 433: " Otherwise CHILL is assumed.
line 434: func! s:FTchange()
line 457: 
line 458: " ChordPro
line 459: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 460: 
line 461: " Clean
line 462: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 463: 
line 464: " Clever
line 465: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 466: 
line 467: " Clever or dtd
line 468: au BufNewFile,BufRead *.ent^I^I^Icall s:FTent()
line 469: 
line 470: func! s:FTent()
line 489: 
line 490: " Clipper (or FoxPro; could also be eviews)
line 496: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif
line 497: 
line 498: " Clojure
line 499: au BufNewFile,BufRead *.clj,*.cljs^I^Isetf clojure
line 500: 
line 501: " Cmake
line 502: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 503: 
line 504: " Cmusrc
line 505: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 506: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 507: 
line 508: " Cobol
line 509: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
line 510: "   cobol or zope form controller python script? (heuristic)
line 516: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 517: 
line 518: " Coco/R
line 519: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 520: 
line 521: " Cold Fusion
line 522: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 523: 
line 524: " Configure scripts
line 525: au BufNewFile,BufRead configure.in,configure.ac setf config
line 526: 
line 527: " CUDA  Cumpute Unified Device Architecture
line 528: au BufNewFile,BufRead *.cu^I^I^Isetf cuda
line 529: 
line 530: " WildPackets EtherPeek Decoder
line 531: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 532: 
line 533: " Enlightenment configuration files
line 534: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 535: 
line 536: " Eterm
line 537: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 538: 
line 539: " Lynx config files
line 540: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 541: 
line 542: " Quake
line 543: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 544: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 545: 
line 546: " Quake C
line 547: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 548: 
line 549: " Configure files
line 550: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg
line 551: 
line 552: " Cucumber
line 553: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 554: 
line 555: " Communicating Sequential Processes
line 556: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 557: 
line 558: " CUPL logic description and simulation
line 559: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 560: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 561: 
line 562: " Debian Control
line 563: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
line 567: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
line 568: 
line 569: " Debian Sources.list
line 570: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 571: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 572: 
line 573: " Deny hosts
line 574: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 575: 
line 576: " dnsmasq(8) configuration files
line 577: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 578: 
line 579: " ROCKLinux package description
line 580: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 581: 
line 582: " the D language or dtrace
line 583: au BufNewFile,BufRead *.d^I^I^Icall s:DtraceCheck()
line 584: 
line 585: func! s:DtraceCheck()
line 596: 
line 597: " Desktop files
line 598: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop
line 599: 
line 600: " Dict config
line 601: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 602: 
line 603: " Dictd config
line 604: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf
line 605: 
line 606: " Diff files
line 607: au BufNewFile,BufRead *.diff,*.rej,*.patch^Isetf diff
line 608: 
line 609: " Dircolors
line 610: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 611: 
line 612: " Diva (with Skill) or InstallShield
line 618: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 619: 
line 620: " DCL (Digital Command Language - vms) or DNS zone file
line 621: au BufNewFile,BufRead *.com^I^I^Icall s:BindzoneCheck('dcl')
line 622: 
line 623: " DOT
line 624: au BufNewFile,BufRead *.dot^I^I^Isetf dot
line 625: 
line 626: " Dylan - lid files
line 627: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 628: 
line 629: " Dylan - intr files (melange)
line 630: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 631: 
line 632: " Dylan
line 633: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 634: 
line 635: " Microsoft Module Definition
line 636: au BufNewFile,BufRead *.def^I^I^Isetf def
line 637: 
line 638: " Dracula
line 639: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
line 640: 
line 641: " Datascript
line 642: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 643: 
line 644: " dsl
line 645: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl
line 646: 
line 647: " DTD (Document Type Definition for XML)
line 648: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 649: 
line 650: " DTS/DSTI (device tree files)
line 651: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
line 652: 
line 653: " EDIF (*.edf,*.edif,*.edn,*.edo)
line 654: au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)^Isetf edif
line 655: 
line 656: " Embedix Component Description
line 657: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 658: 
line 659: " Eiffel or Specman
line 660: au BufNewFile,BufRead *.e,*.E^I^I^Icall s:FTe()
line 661: 
line 662: " Elinks configuration
line 663: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks
line 664: 
line 665: func! s:FTe()
line 676: 
line 677: " ERicsson LANGuage; Yaws is erlang too
line 678: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 679: 
line 680: " Elm Filter Rules file
line 681: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 682: 
line 683: " ESMTP rc file
line 684: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 685: 
line 686: " ESQL-C
line 687: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 688: 
line 689: " Esterel
line 690: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 691: 
line 692: " Essbase script
line 693: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 694: 
line 695: " Exim
line 696: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 697: 
line 698: " Expect
line 699: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 700: 
line 701: " Exports
line 702: au BufNewFile,BufRead exports^I^I^Isetf exports
line 703: 
line 704: " Falcon
line 705: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 706: 
line 707: " Fantom
line 708: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 709: 
line 710: " Factor
line 711: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 712: 
line 713: " Fetchmail RC file
line 714: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 715: 
line 716: " FlexWiki - disabled, because it has side effects when a .wiki file
line 717: " is not actually FlexWiki
line 718: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
line 719: 
line 720: " Focus Executable
line 721: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 722: 
line 723: " Focus Master file (but not for auto.master)
line 724: au BufNewFile,BufRead auto.master^I^Isetf conf
line 725: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 726: 
line 727: " Forth
line 728: au BufNewFile,BufRead *.fs,*.ft^I^I^Isetf forth
line 729: 
line 730: " Reva Forth
line 731: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 732: 
line 733: " Fortran
line 734: if has("fname_case")
line 735:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran
line 736: endif
line 737: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
line 738: 
line 739: " Framescript
line 740: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 741: 
line 742: " FStab
line 743: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 744: 
line 745: " GDB command files
line 746: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb
line 747: 
line 748: " GDMO
line 749: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 750: 
line 751: " Gedcom
line 752: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 753: 
line 754: " Git
line 755: au BufNewFile,BufRead *.git/COMMIT_EDITMSG^Isetf gitcommit
line 756: au BufNewFile,BufRead *.git/MERGE_MSG^I^Isetf gitcommit
line 757: au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
line 758: au BufNewFile,BufRead *.git/modules/*/COMMIT_EDITMSG setf gitcommit
line 759: au BufNewFile,BufRead *.git/modules/*/config^Isetf gitconfig
line 760: au BufNewFile,BufRead */.config/git/config^Isetf gitconfig
line 761: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase
line 765: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif
line 769: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif
line 770: 
line 771: " Gkrellmrc
line 772: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 773: 
line 774: " GP scripts (2.0 and onward)
line 775: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 776: 
line 777: " GPG
line 778: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 779: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 780: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 781: 
line 782: " gnash(1) configuration files
line 783: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 784: 
line 785: " Gitolite
line 786: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 787: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 788: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 789: 
line 790: " Gnuplot scripts
line 791: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot
line 792: 
line 793: " GrADS scripts
line 794: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 795: 
line 796: " Gretl
line 797: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 798: 
line 799: " Groovy
line 800: au BufNewFile,BufRead *.groovy^I^I^Isetf groovy
line 801: 
line 802: " GNU Server Pages
line 803: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 804: 
line 805: " Group file
line 806: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 807: 
line 808: " GTK RC
line 809: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 810: 
line 811: " Haml
line 812: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 813: 
line 814: " Hamster Classic | Playground files
line 815: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster
line 816: 
line 817: " Haskell
line 818: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell
line 819: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 820: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 821: 
line 822: " Haste
line 823: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 824: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 825: 
line 826: " Hercules
line 827: au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum^Isetf hercules
line 828: 
line 829: " HEX (Intel)
line 830: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
line 831: 
line 832: " Tilde (must be before HTML)
line 833: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 834: 
line 835: " HTML (.shtml and .stm for server side)
line 836: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
line 837: 
line 838: " Distinguish between HTML, XHTML and Django
line 839: func! s:FThtml()
line 854: 
line 855: " HTML with Ruby - eRuby
line 856: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 857: 
line 858: " HTML with M4
line 859: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 860: 
line 861: " HTML Cheetah template
line 862: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah
line 863: 
line 864: " Host config
line 865: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 866: 
line 867: " Hosts access
line 868: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 869: 
line 870: " Hyper Builder
line 871: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 872: 
line 873: " Httest
line 874: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 875: 
line 876: " Icon
line 877: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 878: 
line 879: " IDL (Interface Description Language)
line 880: au BufNewFile,BufRead *.idl^I^I^Icall s:FTidl()
line 881: 
line 882: " Distinguish between standard IDL and MS-IDL
line 883: func! s:FTidl()
line 894: 
line 895: " Microsoft IDL (Interface Description Language)  Also *.idl
line 896: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 897: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 898: 
line 899: " Icewm menu
line 900: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 901: 
line 902: " Indent profile (must come before IDL *.pro!)
line 903: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 904: au BufNewFile,BufRead indent.pro^I^Icall s:ProtoCheck('indent')
line 905: 
line 906: " IDL (Interactive Data Language)
line 907: au BufNewFile,BufRead *.pro^I^I^Icall s:ProtoCheck('idlang')
line 908: 
line 909: " Distinguish between "default" and Cproto prototype file. */
line 910: func! s:ProtoCheck(default)
line 922: 
line 923: 
line 924: " Indent RC
line 925: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 926: 
line 927: " Inform
line 928: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 929: 
line 930: " Initng
line 931: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 932: 
line 933: " Innovation Data Processing
line 934: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat
line 935: au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c ^Isetf upstreamlog
line 936: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 937: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog
line 938: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog
line 939: 
line 940: " Ipfilter
line 941: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 942: 
line 943: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 944: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 945: 
line 946: " .INI file for MSDOS
line 947: au BufNewFile,BufRead *.ini^I^I^Isetf dosini
line 948: 
line 949: " SysV Inittab
line 950: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 951: 
line 952: " Inno Setup
line 953: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 954: 
line 955: " J
line 956: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 957: 
line 958: " JAL
line 959: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 960: 
line 961: " Jam
line 962: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 963: 
line 964: " Java
line 965: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
line 966: 
line 967: " JavaCC
line 968: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 969: 
line 970: " JavaScript, ECMAScript
line 971: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.json   setf javascript
line 972: 
line 973: " Java Server Pages
line 974: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 975: 
line 976: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 977: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 978: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 979: 
line 980: " Jess
line 981: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 982: 
line 983: " Jgraph
line 984: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 985: 
line 986: " Jovial
line 987: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 988: 
line 989: " Kixtart
line 990: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 991: 
line 992: " Kimwitu[++]
line 993: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 994: 
line 995: " KDE script
line 996: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 997: 
line 998: " Kconfig
line 999: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
line 1000: 
line 1001: " Lace (ISE)
line 1002: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 1003: 
line 1004: " Latte
line 1005: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 1006: 
line 1007: " Limits
line 1008: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 1009: 
line 1010: " LambdaProlog (*.mod too, see Modsim)
line 1011: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog
line 1012: 
line 1013: " LDAP LDIF
line 1014: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 1015: 
line 1016: " Ld loader
line 1017: au BufNewFile,BufRead *.ld^I^I^Isetf ld
line 1018: 
line 1019: " Lex
line 1020: au BufNewFile,BufRead *.lex,*.l^I^I^Isetf lex
line 1021: 
line 1022: " Libao
line 1023: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 1024: 
line 1025: " Libsensors
line 1026: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 1027: 
line 1028: " LFTP
line 1029: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 1030: 
line 1031: " Lifelines (or Lex for C++!)
line 1032: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
line 1033: 
line 1034: " Lilo: Linux loader
line 1035: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 1036: 
line 1037: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
line 1038: if has("fname_case")
line 1039:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
line 1040: else
line 1041:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
line 1042: endif
line 1043: 
line 1044: " SBCL implementation of Common Lisp
line 1045: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 1046: 
line 1047: " Liquid
line 1048: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 1049: 
line 1050: " Lite
line 1051: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 1052: 
line 1053: " LiteStep RC files
line 1054: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 1055: 
line 1056: " Login access
line 1057: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 1058: 
line 1059: " Login defs
line 1060: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 1061: 
line 1062: " Logtalk
line 1063: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 1064: 
line 1065: " LOTOS
line 1066: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
line 1067: 
line 1068: " Lout (also: *.lt)
line 1069: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 1070: 
line 1071: " Lua
line 1072: au BufNewFile,BufRead *.lua^I^I^Isetf lua
line 1073: 
line 1074: " Linden Scripting Language (Second Life)
line 1075: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl
line 1076: 
line 1077: " Lynx style file (or LotusScript!)
line 1078: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 1079: 
line 1080: " M4
line 1082: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 1083: 
line 1084: " MaGic Point
line 1085: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 1086: 
line 1087: " Mail (for Elm, trn, mutt, muttng, rn, slrn)
line 1088: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 1089: 
line 1090: " Mail aliases
line 1091: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 1092: 
line 1093: " Mailcap configuration file
line 1094: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 1095: 
line 1096: " Makefile
line 1097: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
line 1098: 
line 1099: " MakeIndex
line 1100: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 1101: 
line 1102: " Mallard
line 1103: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 1104: 
line 1105: " Manpage
line 1106: au BufNewFile,BufRead *.man^I^I^Isetf man
line 1107: 
line 1108: " Man config
line 1109: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 1110: 
line 1111: " Maple V
line 1112: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 1113: 
line 1114: " Map (UMN mapserver config file)
line 1115: au BufNewFile,BufRead *.map^I^I^Isetf map
line 1116: 
line 1117: " Markdown
line 1118: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,README.md  setf markdown
line 1119: 
line 1120: " Mason
line 1121: au BufNewFile,BufRead *.mason,*.mhtml^I^Isetf mason
line 1122: 
line 1123: " Matlab or Objective C
line 1124: au BufNewFile,BufRead *.m^I^I^Icall s:FTm()
line 1125: 
line 1126: func! s:FTm()
line 1150: 
line 1151: " Mathematica notebook
line 1152: au BufNewFile,BufRead *.nb^I^I^Isetf mma
line 1153: 
line 1154: " Maya Extension Language
line 1155: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 1156: 
line 1157: " Mercurial (hg) commit file
line 1158: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 1159: 
line 1160: " Mercurial config (looks like generic config file)
line 1161: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 1162: 
line 1163: " Messages (logs mostly)
line 1164: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 1165: 
line 1166: " Metafont
line 1167: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 1168: 
line 1169: " MetaPost
line 1170: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 1171: 
line 1172: " MGL
line 1173: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 1174: 
line 1175: " MMIX or VMS makefile
line 1176: au BufNewFile,BufRead *.mms^I^I^Icall s:FTmms()
line 1177: 
line 1178: " Symbian meta-makefile definition (MMP)
line 1179: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 1180: 
line 1181: func! s:FTmms()
line 1197: 
line 1198: 
line 1199: " Modsim III (or LambdaProlog)
line 1205: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif
line 1206: 
line 1207: " Modula 2
line 1208: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.md,*.mi setf modula2
line 1209: 
line 1210: " Modula 3 (.m3, .i3, .mg, .ig)
line 1211: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1212: 
line 1213: " Monk
line 1214: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1215: 
line 1216: " MOO
line 1217: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1218: 
line 1219: " Modconf
line 1220: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1221: 
line 1222: " Mplayer config
line 1223: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1224: 
line 1225: " Moterola S record
line 1226: au BufNewFile,BufRead *.s19,*.s28,*.s37^I^Isetf srec
line 1227: 
line 1228: " Mrxvtrc
line 1229: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1230: 
line 1231: " Msql
line 1232: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1233: 
line 1234: " Mysql
line 1235: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
line 1236: 
line 1237: " Mutt setup files (must be before catch *.rc)
line 1238: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 1239: 
line 1240: " M$ Resource files
line 1241: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc
line 1242: 
line 1243: " MuPAD source
line 1244: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1245: 
line 1246: " Mush
line 1247: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1248: 
line 1249: " Mutt setup file (also for Muttng)
line 1250: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1251: 
line 1252: " Nano
line 1253: au BufNewFile,BufRead */etc/nanorc,.nanorc^Isetf nanorc
line 1254: 
line 1255: " Nastran input/DMAP
line 1256: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1257: 
line 1258: " Natural
line 1259: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1260: 
line 1261: " Netrc
line 1262: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1263: 
line 1264: " Ninja file
line 1265: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1266: 
line 1267: " Novell netware batch files
line 1268: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1269: 
line 1270: " Nroff/Troff (*.ms and *.t are checked below)
line 1274: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1275: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1276: au BufNewFile,BufRead *.[1-9]^I^I^Icall s:FTnroff()
line 1277: 
line 1278: " This function checks if one of the first five lines start with a dot.  In
line 1279: " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
line 1280: func! s:FTnroff()
line 1287: 
line 1288: " Nroff or Objective C++
line 1289: au BufNewFile,BufRead *.mm^I^I^Icall s:FTmm()
line 1290: 
line 1291: func! s:FTmm()
line 1303: 
line 1304: " Not Quite C
line 1305: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1306: 
line 1307: " NSIS
line 1308: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1309: 
line 1310: " OCAML
line 1311: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml
line 1312: 
line 1313: " Occam
line 1314: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1315: 
line 1316: " Omnimark
line 1317: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1318: 
line 1319: " OpenROAD
line 1320: au BufNewFile,BufRead *.or^I^I^Isetf openroad
line 1321: 
line 1322: " OPL
line 1323: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl
line 1324: 
line 1325: " Oracle config file
line 1326: au BufNewFile,BufRead *.ora^I^I^Isetf ora
line 1327: 
line 1328: " Packet filter conf
line 1329: au BufNewFile,BufRead pf.conf^I^I^Isetf pf
line 1330: 
line 1331: " Pam conf
line 1332: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf
line 1333: 
line 1334: " PApp
line 1335: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp
line 1336: 
line 1337: " Password file
line 1338: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1339: 
line 1340: " Pascal (also *.p)
line 1341: au BufNewFile,BufRead *.pas^I^I^Isetf pascal
line 1342: 
line 1343: " Delphi project file
line 1344: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal
line 1345: 
line 1346: " PDF
line 1347: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf
line 1348: 
line 1349: " Perl
line 1350: if has("fname_case")
line 1351:   au BufNewFile,BufRead *.pl,*.PL^I^Icall s:FTpl()
line 1352: else
line 1353:   au BufNewFile,BufRead *.pl^I^I^Icall s:FTpl()
line 1354: endif
line 1355: au BufNewFile,BufRead *.plx,*.al^I^Isetf perl
line 1356: au BufNewFile,BufRead *.p6,*.pm6^I^Isetf perl6
line 1357: 
line 1358: func! s:FTpl()
line 1372: 
line 1373: " Perl, XPM or XPM2
line 1381: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1382: 
line 1383: " Perl POD
line 1384: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1385: 
line 1386: " Php, php3, php4, etc.
line 1387: " Also Phtml (was used for PHP 2 in the past)
line 1388: " Also .ctp for Cake template file
line 1389: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php
line 1390: 
line 1391: " Pike
line 1392: au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
line 1393: 
line 1394: " Pinfo config
line 1395: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1396: 
line 1397: " Palm Resource compiler
line 1398: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1399: 
line 1400: " Pine config
line 1401: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1402: 
line 1403: " PL/1, PL/I
line 1404: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1405: 
line 1406: " PL/M (also: *.inp)
line 1407: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1408: 
line 1409: " PL/SQL
line 1410: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1411: 
line 1412: " PLP
line 1413: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1414: 
line 1415: " PO and PO template (GNU gettext)
line 1416: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1417: 
line 1418: " Postfix main config
line 1419: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain
line 1420: 
line 1421: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1422: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1423: 
line 1424: " PostScript Printer Description
line 1425: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1426: 
line 1427: " Povray
line 1428: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1429: 
line 1430: " Povray configuration
line 1431: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1432: 
line 1433: " Povray, PHP or assembly
line 1434: au BufNewFile,BufRead *.inc^I^I^Icall s:FTinc()
line 1435: 
line 1436: func! s:FTinc()
line 1457: 
line 1458: " Printcap and Termcap
line 1460: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1462: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1463: 
line 1464: " PCCTS / ANTRL
line 1465: "au BufNewFile,BufRead *.g^I^I^Isetf antrl
line 1466: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 1467: 
line 1468: " PPWizard
line 1469: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1470: 
line 1471: " Obj 3D file format
line 1472: " TODO: is there a way to avoid MS-Windows Object files?
line 1473: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1474: 
line 1475: " Oracle Pro*C/C++
line 1476: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1477: 
line 1478: " Privoxy actions file
line 1479: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1480: 
line 1481: " Procmail
line 1482: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1483: 
line 1484: " Progress or CWEB
line 1485: au BufNewFile,BufRead *.w^I^I^Icall s:FTprogress_cweb()
line 1486: 
line 1487: func! s:FTprogress_cweb()
line 1498: 
line 1499: " Progress or assembly
line 1500: au BufNewFile,BufRead *.i^I^I^Icall s:FTprogress_asm()
line 1501: 
line 1502: func! s:FTprogress_asm()
line 1524: 
line 1525: " Progress or Pascal
line 1526: au BufNewFile,BufRead *.p^I^I^Icall s:FTprogress_pascal()
line 1527: 
line 1528: func! s:FTprogress_pascal()
line 1552: 
line 1553: 
line 1554: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1555: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1559: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1560: 
line 1561: " Prolog
line 1562: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1563: 
line 1564: " Promela
line 1565: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 1566: 
line 1567: " Google protocol buffers
line 1568: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 1569: 
line 1570: " Protocols
line 1571: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 1572: 
line 1573: " Pyrex
line 1574: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
line 1575: 
line 1576: " Python
line 1577: au BufNewFile,BufRead *.py,*.pyw^I^Isetf python
line 1578: 
line 1579: " Quixote (Python-based web framework)
line 1580: au BufNewFile,BufRead *.ptl^I^I^Isetf python
line 1581: 
line 1582: " Radiance
line 1583: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 1584: 
line 1585: " Ratpoison config/command files
line 1586: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 1587: 
line 1588: " RCS file
line 1589: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 1590: 
line 1591: " Readline
line 1592: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 1593: 
line 1594: " Registry for MS-Windows
line 1596: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 1597: 
line 1598: " Renderman Interface Bytestream
line 1599: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 1600: 
line 1601: " Rexx
line 1602: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 1603: 
line 1604: " R (Splus)
line 1605: if has("fname_case")
line 1606:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r
line 1607: else
line 1608:   au BufNewFile,BufRead *.s^I^I^Isetf r
line 1609: endif
line 1610: 
line 1611: " R Help file
line 1612: if has("fname_case")
line 1613:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 1614: else
line 1615:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 1616: endif
line 1617: 
line 1618: " R noweb file
line 1619: if has("fname_case")
line 1620:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 1621: else
line 1622:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 1623: endif
line 1624: 
line 1625: " Rexx, Rebol or R
line 1626: au BufNewFile,BufRead *.r,*.R^I^I^Icall s:FTr()
line 1627: 
line 1628: func! s:FTr()
line 1660: 
line 1661: " Remind
line 1662: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 1663: 
line 1664: " Resolv.conf
line 1665: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 1666: 
line 1667: " Relax NG Compact
line 1668: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 1669: 
line 1670: " Relax NG XML
line 1671: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 1672: 
line 1673: " RPL/2
line 1674: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 1675: 
line 1676: " Robots.txt
line 1677: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 1678: 
line 1679: " Rpcgen
line 1680: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 1681: 
line 1682: " reStructuredText Documentation Format
line 1683: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 1684: 
line 1685: " RTF
line 1686: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 1687: 
line 1688: " Interactive Ruby shell
line 1689: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
line 1690: 
line 1691: " Ruby
line 1692: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 1693: 
line 1694: " RubyGems
line 1695: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 1696: 
line 1697: " Rackup
line 1698: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 1699: 
line 1700: " Bundler
line 1701: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 1702: 
line 1703: " Ruby on Rails
line 1704: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 1705: 
line 1706: " Rantfile and Rakefile is like Ruby
line 1707: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 1708: 
line 1709: " S-lang (or shader language, or SmallLisp)
line 1710: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 1711: 
line 1712: " Samba config
line 1713: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 1714: 
line 1715: " SAS script
line 1716: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 1717: 
line 1718: " Sass
line 1719: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 1720: 
line 1721: " Sather
line 1722: au BufNewFile,BufRead *.sa^I^I^Isetf sather
line 1723: 
line 1724: " Scilab
line 1725: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 1726: 
line 1727: " SCSS
line 1728: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 1729: 
line 1730: " SD: Streaming Descriptors
line 1731: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 1732: 
line 1733: " SDL
line 1734: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 1735: 
line 1736: " sed
line 1737: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 1738: 
line 1739: " Sieve (RFC 3028)
line 1740: au BufNewFile,BufRead *.siv^I^I^Isetf sieve
line 1741: 
line 1742: " Sendmail
line 1743: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 1744: 
line 1745: " Sendmail .mc files are actually m4.  Could also be MS Message text file.
line 1746: au BufNewFile,BufRead *.mc^I^I^Icall s:McSetf()
line 1747: 
line 1748: func! s:McSetf()
line 1763: 
line 1764: " Services
line 1765: au BufNewFile,BufRead */etc/services^I^Isetf services
line 1766: 
line 1767: " Service Location config
line 1768: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 1769: 
line 1770: " Service Location registration
line 1771: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 1772: 
line 1773: " Service Location SPI
line 1774: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 1775: 
line 1776: " Setserial config
line 1777: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 1778: 
line 1779: " SGML
line 1789: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 1790: 
line 1791: " SGMLDECL
line 1795: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 1796: 
line 1797: " SGML catalog file
line 1798: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 1799: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 1800: 
line 1801: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 1802: " Gentoo ebuilds are actually bash scripts
line 1803: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash_profile*,.bash_logout*,*.bash,*.ebuild call SetFileTypeSH("bash")
line 1804: au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
line 1805: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
line 1806: 
line 1807: " Also called from scripts.vim.
line 1808: func! SetFileTypeSH(name)
line 1851: 
line 1852: " For shell-like file types, check for an "exec" command hidden in a comment,
line 1853: " as used for Tcl.
line 1854: " Also called from scripts.vim, thus can't be local to this script.
line 1855: func! SetFileTypeShell(name)
line 1874: 
line 1875: " tcsh scripts
line 1876: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall SetFileTypeShell("tcsh")
line 1877: 
line 1878: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 1879: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
line 1880: 
line 1881: func! s:CSH()
line 1890: 
line 1891: " Z-Shell script
line 1892: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 1893: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 1894: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
line 1895: 
line 1896: " Scheme
line 1897: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme
line 1898: 
line 1899: " Screen RC
line 1900: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 1901: 
line 1902: " Simula
line 1903: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 1904: 
line 1905: " SINDA
line 1906: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 1907: 
line 1908: " SiSU
line 1909: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 1910: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 1911: 
line 1912: " SKILL
line 1913: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 1914: 
line 1915: " SLRN
line 1916: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 1917: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 1918: 
line 1919: " Smalltalk (and TeX)
line 1920: au BufNewFile,BufRead *.st^I^I^Isetf st
line 1928: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif
line 1929: 
line 1930: " Smarty templates
line 1931: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 1932: 
line 1933: " SMIL or XML
line 1939: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 1940: 
line 1941: " SMIL or SNMP MIB file
line 1947: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 1948: 
line 1949: " SMITH
line 1950: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 1951: 
line 1952: " Snobol4 and spitbol
line 1953: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 1954: 
line 1955: " SNMP MIB files
line 1956: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 1957: 
line 1958: " Snort Configuration
line 1959: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 1960: au BufNewFile,BufRead *.rules^I^I^Icall s:FTRules()
line 1961: 
line 1962: let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
line 1963: func! s:FTRules()
line 1991: 
line 1992: 
line 1993: " Spec (Linux RPM)
line 1994: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 1995: 
line 1996: " Speedup (AspenTech plant simulator)
line 1997: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 1998: 
line 1999: " Slice
line 2000: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 2001: 
line 2002: " Spice
line 2003: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 2004: 
line 2005: " Spyce
line 2006: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 2007: 
line 2008: " Squid
line 2009: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 2010: 
line 2011: " SQL for Oracle Designer
line 2012: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql
line 2013: 
line 2014: " SQL
line 2015: au BufNewFile,BufRead *.sql^I^I^Icall s:SQL()
line 2016: 
line 2017: func! s:SQL()
line 2024: 
line 2025: " SQLJ
line 2026: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 2027: 
line 2028: " SQR
line 2029: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 2030: 
line 2031: " OpenSSH configuration
line 2032: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig
line 2033: 
line 2034: " OpenSSH server configuration
line 2035: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig
line 2036: 
line 2037: " Stata
line 2038: au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata
line 2039: 
line 2040: " SMCL
line 2041: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 2042: 
line 2043: " Stored Procedures
line 2044: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 2045: 
line 2046: " Standard ML
line 2047: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 2048: 
line 2049: " Sratus VOS command macro
line 2050: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 2051: 
line 2052: " Sysctl
line 2053: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 2054: 
line 2055: " Synopsys Design Constraints
line 2056: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 2057: 
line 2058: " Sudoers
line 2059: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 2060: 
line 2061: " SVG (Scalable Vector Graphics)
line 2062: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 2063: 
line 2064: " If the file has an extension of 't' and is in a directory 't' then it is
line 2065: " almost certainly a Perl test file.
line 2066: " If the first line starts with '#' and contains 'perl' it's probably a Perl
line 2067: " file.
line 2068: " (Slow test) If a file contains a 'use' statement then it is almost certainly
line 2069: " a Perl file.
line 2070: func! s:FTperl()
line 2085: 
line 2086: " Tads (or Nroff or Perl test file)
line 2088: au BufNewFile,BufRead *.t if !s:FTnroff() && !s:FTperl() | setf tads | endif
line 2089: 
line 2090: " Tags
line 2091: au BufNewFile,BufRead tags^I^I^Isetf tags
line 2092: 
line 2093: " TAK
line 2094: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 2095: 
line 2096: " Task
line 2097: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 2098: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 2099: 
line 2100: " Tcl (JACL too)
line 2101: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl
line 2102: 
line 2103: " TealInfo
line 2104: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 2105: 
line 2106: " Telix Salt
line 2107: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 2108: 
line 2109: " Terminfo
line 2110: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 2111: 
line 2112: " TeX
line 2113: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 2114: au BufNewFile,BufRead *.tex^I^I^Icall s:FTtex()
line 2115: 
line 2116: " Choose context, plaintex, or tex (LaTeX) based on these rules:
line 2117: " 1. Check the first line of the file for "%&<format>".
line 2118: " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
line 2119: " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
line 2120: func! s:FTtex()
line 2167: 
line 2168: " ConTeXt
line 2169: au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context
line 2170: 
line 2171: " Texinfo
line 2172: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 2173: 
line 2174: " TeX configuration
line 2175: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 2176: 
line 2177: " Tidy config
line 2178: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy
line 2179: 
line 2180: " TF mud client
line 2181: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf
line 2182: 
line 2183: " TPP - Text Presentation Program
line 2184: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp
line 2185: 
line 2186: " Treetop
line 2187: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 2188: 
line 2189: " Trustees
line 2190: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 2191: 
line 2192: " TSS - Geometry
line 2193: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 2194: 
line 2195: " TSS - Optics
line 2196: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 2197: 
line 2198: " TSS - Command Line (temporary)
line 2199: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 2200: 
line 2201: " TWIG files
line 2202: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 2203: 
line 2204: " Motif UIT/UIL files
line 2205: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 2206: 
line 2207: " Udev conf
line 2208: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 2209: 
line 2210: " Udev permissions
line 2211: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 2212: "
line 2213: " Udev symlinks config
line 2214: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 2215: 
line 2216: " UnrealScript
line 2217: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 2218: 
line 2219: " Updatedb
line 2220: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 2221: 
line 2222: " Upstart (init(8)) config files
line 2223: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 2224: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 2225: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 2226: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart
line 2227: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 2228: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 2229: 
line 2230: " Vera
line 2231: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 2232: 
line 2233: " Verilog HDL
line 2234: au BufNewFile,BufRead *.v^I^I^Isetf verilog
line 2235: 
line 2236: " Verilog-AMS HDL
line 2237: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 2238: 
line 2239: " VHDL
line 2240: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
line 2241: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 2242: 
line 2243: " Vim script
line 2244: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim
line 2245: 
line 2246: " Viminfo file
line 2247: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 2248: 
line 2249: " Virata Config Script File or Drupal module
line 2255: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 2256: 
line 2257: " Visual Basic (also uses *.bas) or FORM
line 2258: au BufNewFile,BufRead *.frm^I^I^Icall s:FTVB("form")
line 2259: 
line 2260: " SaxBasic is close to Visual Basic
line 2261: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 2262: 
line 2263: " Vgrindefs file
line 2264: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 2265: 
line 2266: " VRML V1.0c
line 2267: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 2268: 
line 2269: " Webmacro
line 2270: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 2271: 
line 2272: " Wget config
line 2273: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 2274: 
line 2275: " Website MetaLanguage
line 2276: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 2277: 
line 2278: " Winbatch
line 2279: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 2280: 
line 2281: " WSML
line 2282: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 2283: 
line 2284: " WvDial
line 2285: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 2286: 
line 2287: " CVS RC file
line 2288: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 2289: 
line 2290: " CVS commit file
line 2291: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 2292: 
line 2293: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 2294: " lines in a WEB file).
line 2300: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 2301: 
line 2302: " Windows Scripting Host and Windows Script Component
line 2303: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 2304: 
line 2305: " XHTML
line 2306: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 2307: 
line 2308: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
line 2314: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 2315: au BufEnter *.xpm2^I^I^I^Isetf xpm2
line 2316: 
line 2317: " XFree86 config
line 2322: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 2325: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2326: 
line 2327: " Xorg config
line 2328: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2329: 
line 2330: " Xinetd conf
line 2331: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 2332: 
line 2333: " XS Perl extension interface language
line 2334: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 2335: 
line 2336: " X resources file
line 2337: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 2338: 
line 2339: " Xmath
line 2340: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 2342: au BufNewFile,BufRead *.ms if !s:FTnroff() | setf xmath | endif
line 2343: 
line 2344: " XML  specific variants: docbk and xbl
line 2345: au BufNewFile,BufRead *.xml^I^I^Icall s:FTxml()
line 2346: 
line 2347: func! s:FTxml()
line 2372: 
line 2373: " XMI (holding UML models) is also XML
line 2374: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 2375: 
line 2376: " CSPROJ files are Visual Studio.NET's XML-based project config files
line 2377: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 2378: 
line 2379: " Qt Linguist translation source and Qt User Interface Files are XML
line 2380: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml
line 2381: 
line 2382: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 2383: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 2384: 
line 2385: " Xdg menus
line 2386: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 2387: 
line 2388: " ATI graphics driver configuration
line 2389: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 2390: 
line 2391: " XLIFF (XML Localisation Interchange File Format) is also XML
line 2392: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 2393: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 2394: 
line 2395: " XML User Interface Language
line 2396: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 2397: 
line 2398: " X11 xmodmap (also see below)
line 2399: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 2400: 
line 2401: " Xquery
line 2402: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 2403: 
line 2404: " XSD
line 2405: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 2406: 
line 2407: " Xslt
line 2408: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 2409: 
line 2410: " Yacc
line 2411: au BufNewFile,BufRead *.yy^I^I^Isetf yacc
line 2412: 
line 2413: " Yacc or racc
line 2414: au BufNewFile,BufRead *.y^I^I^Icall s:FTy()
line 2415: 
line 2416: func! s:FTy()
line 2432: 
line 2433: 
line 2434: " Yaml
line 2435: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml
line 2436: 
line 2437: " yum conf (close enough to dosini)
line 2438: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 2439: 
line 2440: " Zimbu
line 2441: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 2442: 
line 2443: " Zope
line 2444: "   dtml (zope dynamic template markup language), pt (zope page template),
line 2445: "   cpt (zope form controller page template)
line 2446: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall s:FThtml()
line 2447: "   zsql (zope sql method)
line 2448: au BufNewFile,BufRead *.zsql^I^I^Icall s:SQL()
line 2449: 
line 2450: " Z80 assembler asz80
line 2451: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 2452: 
line 2453: augroup END
line 2454: 
line 2455: 
line 2456: " Source the user-specified filetype file, for backwards compatibility with
line 2457: " Vim 5.x.
line 2458: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 2459:   execute "source " . myfiletypefile
line 2460: endif
line 2461: 
line 2462: 
line 2463: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 2464: " when there are no matching file name extensions.
line 2465: " Don't do this for compressed files.
line 2466: augroup filetypedetect
line 2469: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 2470: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 2471: 
line 2472: 
line 2473: " Extra checks for when no filetype has been detected now.  Mostly used for
line 2474: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 2475: " script file.
line 2476: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 2477: " like are used.
line 2478: 
line 2479: " More Apache config files
line 2480: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
line 2481: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
line 2482: 
line 2483: " Asterisk config file
line 2484: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 2485: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 2486: 
line 2487: " Bazaar version control
line 2488: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 2489: 
line 2490: " BIND zone
line 2491: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 2492: 
line 2493: " Calendar
line 2496: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 2497: 
line 2498: " Changelog
line 2504: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 2505: 
line 2506: " Crontab
line 2507: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 2508: 
line 2509: " dnsmasq(8) configuration
line 2510: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 2511: 
line 2512: " Dracula
line 2513: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 2514: 
line 2515: " Fvwm
line 2516: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 2518: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 2524: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 2525: 
line 2526: " Gedcom
line 2527: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 2528: 
line 2529: " GTK RC
line 2530: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 2531: 
line 2532: " Jam
line 2533: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 2534: 
line 2535: " Jargon
line 2539: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 2540: 
line 2541: " Kconfig
line 2542: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
line 2543: 
line 2544: " Lilo: Linux loader
line 2545: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 2546: 
line 2547: " Logcheck
line 2548: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 2549: 
line 2550: " Makefile
line 2551: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 2552: 
line 2553: " Ruby Makefile
line 2554: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 2555: 
line 2556: " Mail (also matches muttrc.vim, so this is below the other checks)
line 2557: au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 2558: 
line 2559: " Modconf
line 2563: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 2564: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 2565: 
line 2566: " Mutt setup file
line 2567: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 2568: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 2569: 
line 2570: " Nroff macros
line 2571: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 2572: 
line 2573: " Pam conf
line 2574: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 2575: 
line 2576: " Printcap and Termcap
line 2580: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 2584: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 2585: 
line 2586: " ReDIF
line 2587: " Only used when the .rdf file was not detected to be XML.
line 2588: au BufRead,BufNewFile *.rdf^I^I^Icall s:Redif()
line 2589: func! s:Redif()
line 2599: 
line 2600: " Remind
line 2601: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 2602: 
line 2603: " Vim script
line 2604: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 2605: 
line 2606: " Subversion commit file
line 2607: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 2608: 
line 2609: " X resources file
line 2610: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 2611: 
line 2612: " XFree86 config
line 2614: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 2619: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 2620: 
line 2621: " X11 xmodmap
line 2622: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 2623: 
line 2624: " Xinetd conf
line 2625: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 2626: 
line 2627: " yum conf (close enough to dosini)
line 2628: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 2629: 
line 2630: " Z-Shell script
line 2631: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 2632: 
line 2633: 
line 2634: " Plain text files, needs to be far down to not override others.  This avoids
line 2635: " the "conf" type being used if there is a line starting with '#'.
line 2636: au BufNewFile,BufRead *.txt,*.text^I^Isetf text
line 2637: 
line 2638: 
line 2639: " Use the filetype detect plugins.  They may overrule any of the previously
line 2640: " detected filetypes.
line 2641: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/ftdetect/*.vim"
chdir(/home/max/.vim/ftdetect)
fchdir() to previous dir
line 2641: sourcing "/home/max/.vim/ftdetect/gofiletype.vim"
line 1: " We take care to preserve the user's fileencodings and fileformats,
line 2: " because those settings are global (not buffer local), yet we want
line 3: " to override them for loading Go files, which are defined to be UTF-8.
line 4: let s:current_fileformats = ''
line 5: let s:current_fileencodings = ''
line 6: 
line 7: " define fileencodings to open as utf-8 encoding even if it's ascii.
line 8: function! s:gofiletype_pre()
line 14: 
line 15: " restore fileencodings as others
line 16: function! s:gofiletype_post()
line 20: 
line 21: au BufNewFile *.go setlocal filetype=go fileencoding=utf-8 fileformat=unix
line 22: au BufRead *.go call s:gofiletype_pre()
line 23: au BufReadPost *.go call s:gofiletype_post()
finished sourcing /home/max/.vim/ftdetect/gofiletype.vim
continuing in /usr/share/vim/vim74/filetype.vim
Searching for "/var/lib/vim/addons/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"
Searching for "/usr/share/vim/vim74/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"
Searching for "/var/lib/vim/addons/after/ftdetect/*.vim"
Searching for "/home/max/.vim/after/ftdetect/*.vim"
line 2642: 
line 2643: " NOTE: The above command could have ended the filetypedetect autocmd group
line 2644: " and started another one. Let's make sure it has ended to get to a consistent
line 2645: " state.
line 2646: augroup END
line 2647: 
line 2648: " Generic configuration file (check this last, it's just guessing!)
line 2654: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf conf | endif
line 2655: 
line 2656: 
line 2657: " If the GUI is already running, may still need to install the Syntax menu.
line 2658: " Don't do it when the 'M' flag is included in 'guioptions'.
line 2660: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 2661:   source <sfile>:p:h/menu.vim
line 2662: endif
line 2663: 
line 2664: " Function called for testing all functions defined here.  These are
line 2665: " script-local, thus need to be executed here.
line 2666: " Returns a string with error messages (hopefully empty).
line 2667: func! TestFiletypeFuncs(testlist)
line 2678: 
line 2679: " Restore 'cpoptions'
line 2680: let &cpo = s:cpo_save
line 2681: unlet s:cpo_save
finished sourcing /usr/share/vim/vim74/filetype.vim
continuing in /usr/share/vim/vim74/syntax/syntax.vim
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/var/lib/vim/addons/after/filetype.vim"
Searching for "/home/max/.vim/after/filetype.vim"
line 26:   let s:did_ft = 0
line 27: endif
line 28: 
line 29: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected.
line 31: augroup syntaxset
line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
line 33: augroup END
line 34: 
line 35: 
line 36: " Execute the syntax autocommands for the each buffer.
line 37: " If the filetype wasn't detected yet, do that now.
line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 39: " already was set manually (e.g., help buffers).
line 40: doautoall syntaxset FileType
line 41: if !s:did_ft
line 42:   doautoall filetypedetect BufRead
line 43: endif
finished sourcing /usr/share/vim/vim74/syntax/syntax.vim
continuing in /usr/share/vim/vimrc
line 21: endif
line 22: 
line 23: " If using a dark background within the editing area and syntax highlighting
line 24: " turn on this option as well
line 25: "set background=dark
line 26: 
line 27: " Uncomment the following to have Vim jump to the last position when
line 28: " reopening a file
line 29: "if has("autocmd")
line 30: "  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
line 31: "endif
line 32: 
line 33: " Uncomment the following to have Vim load indentation rules and plugins
line 34: " according to the detected filetype.
line 35: "if has("autocmd")
line 36: "  filetype plugin indent on
line 37: "endif
line 38: 
line 39: " The following are commented out as they cause vim to behave a lot
line 40: " differently from regular Vi. They are highly recommended though.
line 41: "set showcmd^I^I" Show (partial) command in status line.
line 42: "set showmatch^I^I" Show matching brackets.
line 43: "set ignorecase^I^I" Do case insensitive matching
line 44: "set smartcase^I^I" Do smart case matching
line 45: "set incsearch^I^I" Incremental search
line 46: "set autowrite^I^I" Automatically save before commands like :next and :make
line 47: "set hidden^I^I" Hide buffers when they are abandoned
line 48: "set mouse=a^I^I" Enable mouse usage (all modes)
line 49: 
line 50: " Source a global configuration file if available
line 51: if filereadable("/etc/vim/vimrc.local")
line 52:   source /etc/vim/vimrc.local
line 53: endif
line 54: 
finished sourcing $VIM/vimrc
chdir(/home/max)
fchdir() to previous dir
sourcing "$HOME/.vimrc"
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/autocomplete.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/autocomplete.vim"
line 1: " autocomplete.vim
line 2: " ~/.vimrc/plugin/settings/autocomplete.vm
line 3: " use this to map the autocomplete key to tab and also other settings
line 4: 
line 5: " map tab to ctrl p
line 6: imap <Tab> <C-P>
finished sourcing /home/max/.vim/plugin/settings/autocomplete.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/base.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/base.vim"
line 1: " When started as "evim", evim.vim will already have done these settings.
line 2: if v:progname =~? "evim"
line 3:   finish
line 4: endif
line 5: 
line 6: " Use Vim settings, rather than Vi settings (much better!).
line 7: " This must be first, because it changes other options as a side effect.
line 8: set nocompatible
line 9: 
line 10: " allow backspacing over everything in insert mode
line 11: set backspace=indent,eol,start
line 12: 
line 13: if has("vms")
line 14:   set nobackup^I^I" do not keep a backup file, use versions instead
line 15: else
line 16:   set backup^I^I" keep a backup file
line 17: endif
line 18: set history=50^I^I" keep 50 lines of command line history
line 19: set ruler^I^I" show the cursor position all the time
line 20: set showcmd^I^I" display incomplete commands
line 21: set incsearch^I^I" do incremental searching
line 22: 
line 23: " For Win32 GUI: remove 't' flag from 'guioptions': no tearoff menu entries
line 24: " let &guioptions = substitute(&guioptions, "t", "", "g")
line 25: 
line 26: " Don't use Ex mode, use Q for formatting
line 27: map Q gq
line 28: 
line 29: " CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
line 30: " so that you can undo CTRL-U after inserting a line break.
line 31: inoremap <C-U> <C-G>u<C-U>
line 32: 
line 33: " In many terminal emulators the mouse works just fine, thus enable it.
line 34: if has('mouse')
line 35:   set mouse=a
line 36: endif
line 37: 
line 38: " Switch syntax highlighting on, when the terminal has colors
line 39: " Also switch on highlighting the last used search pattern.
line 40: if &t_Co > 2 || has("gui_running")
line 41:   syntax on
line 41: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 41: sourcing "/usr/share/vim/vim74/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 04
line 4: 
line 5: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 15: sourcing "/usr/share/vim/vim74/syntax/nosyntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2006 Apr 16
line 4: 
line 5: " This file is used for ":syntax off".
line 6: " It removes the autocommands and stops highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " Remove all autocommands for the Syntax event.  This also avoids that
line 13: " "syntax=foo" in a modeline triggers the SynSet() function of synload.vim.
line 14: au! Syntax
line 15: 
line 16: " remove all syntax autocommands and remove the syntax for each buffer
line 17: augroup syntaxset
line 18:   au!
line 19:   au BufEnter * syn clear
line 20:   au BufEnter * if exists("b:current_syntax") | unlet b:current_syntax | endif
line 21:   doautoall syntaxset BufEnter *
line 22:   au!
line 23: augroup END
line 24: 
line 25: if exists("syntax_on")
line 26:   unlet syntax_on
line 27: endif
line 28: if exists("syntax_manual")
line 29:   unlet syntax_manual
line 30: endif
finished sourcing /usr/share/vim/vim74/syntax/nosyntax.vim
continuing in /usr/share/vim/vim74/syntax/syntax.vim
line 16: endif
line 17: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/syntax/synload.vim"
Searching for "/var/lib/vim/addons/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim74/syntax/synload.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 19: sourcing "/usr/share/vim/vim74/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2012 Sep 25
line 4: 
line 5: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
line 10: if !has("syntax")
line 11:   finish
line 12: endif
line 13: 
line 14: " let others know that syntax has been switched on
line 15: let syntax_on = 1
line 16: 
line 17: " Set the default highlighting colors.  Use a color scheme if specified.
line 18: if exists("colors_name")
line 19:   exe "colors " . colors_name
line 20: else
line 21:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 21: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim
continuing in /usr/share/vim/vim74/syntax/synload.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/after/syntax/syncolor.vim"
line 22: endif
line 23: 
line 24: " Line continuation is used here, remove 'C' from 'cpoptions'
line 25: let s:cpo_save = &cpo
line 26: set cpo&vim
line 27: 
line 28: " First remove all old syntax autocommands.
line 29: au! Syntax
line 30: 
line 31: au Syntax *^I^Icall s:SynSet()
line 32: 
line 33: fun! s:SynSet()
line 61: 
line 62: 
line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL)
line 68: au Syntax c,cpp,cs,idl,php if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 69: 
line 70: 
line 71: " Source the user-specified syntax highlighting file
line 72: if exists("mysyntaxfile") && filereadable(expand(mysyntaxfile))
line 73:   execute "source " . mysyntaxfile
line 74: endif
line 75: 
line 76: " Restore 'cpoptions'
line 77: let &cpo = s:cpo_save
line 78: unlet s:cpo_save
finished sourcing /usr/share/vim/vim74/syntax/synload.vim
continuing in /usr/share/vim/vim74/syntax/syntax.vim
line 20: 
line 21: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
line 24: else
line 25:   filetype on
line 26:   let s:did_ft = 0
line 27: endif
line 28: 
line 29: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected.
line 31: augroup syntaxset
line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
line 33: augroup END
line 34: 
line 35: 
line 36: " Execute the syntax autocommands for the each buffer.
line 37: " If the filetype wasn't detected yet, do that now.
line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 39: " already was set manually (e.g., help buffers).
line 40: doautoall syntaxset FileType
line 41: if !s:did_ft
line 42:   doautoall filetypedetect BufRead
line 43: endif
finished sourcing /usr/share/vim/vim74/syntax/syntax.vim
continuing in /home/max/.vim/plugin/settings/base.vim
line 42:   set hlsearch
line 43: endif
line 44: 
line 45: " Only do this part when compiled with support for autocommands.
line 46: if has("autocmd")
line 47: 
line 48:   " Enable file type detection.
line 49:   " Use the default filetype settings, so that mail gets 'tw' set to 72,
line 50:   " 'cindent' is on in C files, etc.
line 51:   " Also load indent files, to automatically do language-dependent indenting.
line 52:   filetype plugin indent on
Searching for "filetype.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/filetype.vim"
Searching for "/var/lib/vim/addons/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim74/filetype.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 52: sourcing "/usr/share/vim/vim74/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2013 Sep 22
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
finished sourcing /usr/share/vim/vim74/filetype.vim
continuing in /home/max/.vim/plugin/settings/base.vim
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/var/lib/vim/addons/after/filetype.vim"
Searching for "/home/max/.vim/after/filetype.vim"
Searching for "ftplugin.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/ftplugin.vim"
Searching for "/var/lib/vim/addons/ftplugin.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"
Searching for "/usr/share/vim/vim74/ftplugin.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 52: sourcing "/usr/share/vim/vim74/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
line 8: endif
line 9: let did_load_ftplugin = 1
line 10: 
line 11: augroup filetypeplugin
line 12:   au FileType * call s:LoadFTPlugin()
line 13: 
line 14:   func! s:LoadFTPlugin()
line 35: augroup END
finished sourcing /usr/share/vim/vim74/ftplugin.vim
continuing in /home/max/.vim/plugin/settings/base.vim
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"
Searching for "/var/lib/vim/addons/after/ftplugin.vim"
Searching for "/home/max/.vim/after/ftplugin.vim"
Searching for "indent.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/indent.vim"
Searching for "/var/lib/vim/addons/indent.vim"
Searching for "/usr/share/vim/vimfiles/indent.vim"
Searching for "/usr/share/vim/vim74/indent.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 52: sourcing "/usr/share/vim/vim74/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
line 5: 
line 6: if exists("did_indent_on")
line 7:   finish
line 8: endif
line 9: let did_indent_on = 1
line 10: 
line 11: augroup filetypeindent
line 12:   au FileType * call s:LoadIndent()
line 13:   func! s:LoadIndent()
line 31: augroup END
finished sourcing /usr/share/vim/vim74/indent.vim
continuing in /home/max/.vim/plugin/settings/base.vim
Searching for "/usr/share/vim/vimfiles/after/indent.vim"
Searching for "/var/lib/vim/addons/after/indent.vim"
Searching for "/home/max/.vim/after/indent.vim"
line 53: 
line 54:   " Put these in an autocmd group, so that we can delete them easily.
line 55:   augroup vimrcEx
line 56:   au!
line 57: 
line 58:   " For all text files set 'textwidth' to 78 characters.
line 59:   autocmd FileType text setlocal textwidth=78
line 60: 
line 61:   " When editing a file, always jump to the last known cursor position.
line 62:   " Don't do it when the position is invalid or when inside an event handler
line 63:   " (happens when dropping a file on gvim).
line 64:   " Also don't do it when the mark is in the first line, that is the default
line 65:   " position when opening a file.
line 69:   autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") |   exe "normal! g`\"" | endif
line 70: 
line 71:   augroup END
line 72: 
line 73: else
line 74: 
line 75:   set autoindent^I^I" always set autoindenting on
line 76: 
line 77: endif " has("autocmd")
line 78: 
line 79: " Convenient command to see the difference between the current buffer and the
line 80: " file it was loaded from, thus the changes you made.
line 81: " Only define it when not defined already.
line 82: if !exists(":DiffOrig")
line 84:   command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis | wincmd p | diffthis
line 85: endif
finished sourcing /home/max/.vim/plugin/settings/base.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/c++.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/c++.vim"
line 1: " c++.vim
line 2: " ~/.vimrc/plugin/settings/c++.vim
line 3: " Sets the c++ file extension for the different filetypes
line 4: 
line 5: au BufRead,BufNewFile *.h setfiletype cpp
line 6: au BufRead,BufNewFile *.cc setfiletype cpp
finished sourcing /home/max/.vim/plugin/settings/c++.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/colors.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/colors.vim"
line 1: " colors.vim
line 2: " ~/.vim/plugin/settings/colors.vim
line 3: " use this to set default (non file specific) colors
line 4: set t_Co=256
Searching for "syntax/syncolor.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 4: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim
continuing in /home/max/.vim/plugin/settings/colors.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/after/syntax/syncolor.vim"
line 5: colorscheme monokai
Searching for "colors/monokai.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/colors/monokai.vim"
chdir(/home/max/.vim/colors)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/colors/monokai.vim"
line 1: " Vim color file
line 2: " Converted from Textmate theme Monokai using Coloration v0.3.2 (http://github.com/sickill/coloration)
line 3: 
line 4: set background=dark
Searching for "syntax/syncolor.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 4: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim
continuing in /home/max/.vim/colors/monokai.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/after/syntax/syncolor.vim"
line 5: highlight clear
Searching for "syntax/syncolor.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 5: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim
continuing in /home/max/.vim/colors/monokai.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/after/syntax/syncolor.vim"
line 6: 
line 7: if exists("syntax_on")
line 8:   syntax reset
line 8: runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 8: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi! link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi! link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi! link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi! link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi! link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi! link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi! link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi! link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi! link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi! link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi! link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi! link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi! link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi! link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi! link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi! link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi! link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi! link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi! link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi! link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi! link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi! link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi! link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi! link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim
continuing in /home/max/.vim/colors/monokai.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/after/syntax/syncolor.vim"
line 9: endif
line 10: 
line 11: let g:colors_name = "monokai"
line 12: 
line 13: hi Cursor ctermfg=235 ctermbg=231 cterm=NONE guifg=#272822 guibg=#f8f8f0 gui=NONE
line 14: hi Visual ctermfg=NONE ctermbg=59 cterm=NONE guifg=NONE guibg=#49483e gui=NONE
line 15: hi CursorLine ctermfg=NONE ctermbg=237 cterm=NONE guifg=NONE guibg=#3c3d37 gui=NONE
line 16: hi CursorColumn ctermfg=NONE ctermbg=237 cterm=NONE guifg=NONE guibg=#3c3d37 gui=NONE
line 17: hi ColorColumn ctermfg=NONE ctermbg=237 cterm=NONE guifg=NONE guibg=#3c3d37 gui=NONE
line 18: hi LineNr ctermfg=102 ctermbg=237 cterm=NONE guifg=#90908a guibg=#3c3d37 gui=NONE
line 19: hi VertSplit ctermfg=241 ctermbg=241 cterm=NONE guifg=#64645e guibg=#64645e gui=NONE
line 20: hi MatchParen ctermfg=197 ctermbg=NONE cterm=underline guifg=#f92672 guibg=NONE gui=underline
line 21: hi StatusLine ctermfg=231 ctermbg=241 cterm=bold guifg=#f8f8f2 guibg=#64645e gui=bold
line 22: hi StatusLineNC ctermfg=231 ctermbg=241 cterm=NONE guifg=#f8f8f2 guibg=#64645e gui=NONE
line 23: hi Pmenu ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 24: hi PmenuSel ctermfg=NONE ctermbg=59 cterm=NONE guifg=NONE guibg=#49483e gui=NONE
line 25: hi IncSearch ctermfg=235 ctermbg=186 cterm=NONE guifg=#272822 guibg=#e6db74 gui=NONE
line 26: hi Search ctermfg=NONE ctermbg=NONE cterm=underline guifg=NONE guibg=NONE gui=underline
line 27: hi Directory ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 28: hi Folded ctermfg=242 ctermbg=235 cterm=NONE guifg=#75715e guibg=#272822 gui=NONE
line 29: 
line 30: hi Normal ctermfg=231 ctermbg=235 cterm=NONE guifg=#f8f8f2 guibg=#272822 gui=NONE
line 31: hi Boolean ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 32: hi Character ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 33: hi Comment ctermfg=242 ctermbg=NONE cterm=NONE guifg=#75715e guibg=NONE gui=NONE
line 34: hi Conditional ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 35: hi Constant ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 36: hi Define ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 37: hi DiffAdd ctermfg=231 ctermbg=64 cterm=bold guifg=#f8f8f2 guibg=#46830c gui=bold
line 38: hi DiffDelete ctermfg=88 ctermbg=NONE cterm=NONE guifg=#8b0807 guibg=NONE gui=NONE
line 39: hi DiffChange ctermfg=231 ctermbg=23 cterm=NONE guifg=#f8f8f2 guibg=#243955 gui=NONE
line 40: hi DiffText ctermfg=231 ctermbg=24 cterm=bold guifg=#f8f8f2 guibg=#204a87 gui=bold
line 41: hi ErrorMsg ctermfg=231 ctermbg=197 cterm=NONE guifg=#f8f8f0 guibg=#f92672 gui=NONE
line 42: hi WarningMsg ctermfg=231 ctermbg=197 cterm=NONE guifg=#f8f8f0 guibg=#f92672 gui=NONE
line 43: hi Float ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 44: hi Function ctermfg=148 ctermbg=NONE cterm=NONE guifg=#a6e22e guibg=NONE gui=NONE
line 45: hi Identifier ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 46: hi Keyword ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 47: hi Label ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 48: hi NonText ctermfg=59 ctermbg=236 cterm=NONE guifg=#49483e guibg=#31322c gui=NONE
line 49: hi Number ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 50: hi Operator ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 51: hi PreProc ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 52: hi Special ctermfg=231 ctermbg=NONE cterm=NONE guifg=#f8f8f2 guibg=NONE gui=NONE
line 53: hi SpecialKey ctermfg=59 ctermbg=237 cterm=NONE guifg=#49483e guibg=#3c3d37 gui=NONE
line 54: hi Statement ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 55: hi StorageClass ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 56: hi String ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 57: hi Tag ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 58: hi Title ctermfg=231 ctermbg=NONE cterm=bold guifg=#f8f8f2 guibg=NONE gui=bold
line 59: hi Todo ctermfg=95 ctermbg=NONE cterm=inverse,bold guifg=#75715e guibg=NONE gui=inverse,bold
line 60: hi Type ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 61: hi Underlined ctermfg=NONE ctermbg=NONE cterm=underline guifg=NONE guibg=NONE gui=underline
line 62: hi rubyClass ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 63: hi rubyFunction ctermfg=148 ctermbg=NONE cterm=NONE guifg=#a6e22e guibg=NONE gui=NONE
line 64: hi rubyInterpolationDelimiter ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 65: hi rubySymbol ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 66: hi rubyConstant ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 67: hi rubyStringDelimiter ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 68: hi rubyBlockParameter ctermfg=208 ctermbg=NONE cterm=NONE guifg=#fd971f guibg=NONE gui=italic
line 69: hi rubyInstanceVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 70: hi rubyInclude ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 71: hi rubyGlobalVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 72: hi rubyRegexp ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 73: hi rubyRegexpDelimiter ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 74: hi rubyEscape ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 75: hi rubyControl ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 76: hi rubyClassVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 77: hi rubyOperator ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 78: hi rubyException ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 79: hi rubyPseudoVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 80: hi rubyRailsUserClass ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 81: hi rubyRailsARAssociationMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 82: hi rubyRailsARMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 83: hi rubyRailsRenderMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 84: hi rubyRailsMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 85: hi erubyDelimiter ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 86: hi erubyComment ctermfg=95 ctermbg=NONE cterm=NONE guifg=#75715e guibg=NONE gui=NONE
line 87: hi erubyRailsMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 88: hi htmlTag ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 89: hi htmlEndTag ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 90: hi htmlTagName ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 91: hi htmlArg ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 92: hi htmlSpecialChar ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 93: hi javaScriptFunction ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 94: hi javaScriptRailsFunction ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 95: hi javaScriptBraces ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 96: hi yamlKey ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 97: hi yamlAnchor ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 98: hi yamlAlias ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 99: hi yamlDocumentHeader ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 100: hi cssURL ctermfg=208 ctermbg=NONE cterm=NONE guifg=#fd971f guibg=NONE gui=italic
line 101: hi cssFunctionName ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 102: hi cssColor ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 103: hi cssPseudoClassId ctermfg=148 ctermbg=NONE cterm=NONE guifg=#a6e22e guibg=NONE gui=NONE
line 104: hi cssClassName ctermfg=148 ctermbg=NONE cterm=NONE guifg=#a6e22e guibg=NONE gui=NONE
line 105: hi cssValueLength ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 106: hi cssCommonAttr ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 107: hi cssBraces ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
finished sourcing /home/max/.vim/colors/monokai.vim
continuing in /home/max/.vim/plugin/settings/colors.vim
finished sourcing /home/max/.vim/plugin/settings/colors.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/easymotion.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/easymotion.vim"
line 1: " easymotion.vim
line 2: " ~/.vim/plugin/settings/easymotion.vim
line 3: " https://github.com/Lokaltog/vim-easymotion
line 4: " use this file to set easymotion settings
line 5: 
line 6: " set leader key
line 7: map <Space> <Plug>(easymotion-prefix)
line 8: let g:EasyMotion_do_mapping = 0 " Disable default mappings
line 9: 
line 10: " Bi-directional find motion
line 11: " Jump to anywhere you want with minimal keystrokes, with just one key
line 12: " binding.
line 13: " s{char}{label}
line 14: " nmap s <Plug>(easymotion-s)
line 15: " nmap t <Plug>(easymotion-t2)
line 16: " s{char}{char}{label}
line 17: " need one more keystroke but on average it may be more comfortable
line 18: " nmap s <Plug>(easymotion-s2)
line 19: 
line 20: " Turn on case sensitive feature
line 21: let g:EasyMotion_smartcase = 1
line 22: 
line 23: " JK motions: line motions
line 24: map <Leader>j <Plug>(easymotion-j)
line 25: map <Leader>k <Plug>(easymotion-k)
finished sourcing /home/max/.vim/plugin/settings/easymotion.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/numbering.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/numbering.vim"
line 1: " numbering.vim
line 2: " ~/.vim/plugin/settings/numbering.vim
line 3: " use this to turn on number and maybe settings later
line 4: set nu
finished sourcing /home/max/.vim/plugin/settings/numbering.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/python.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/python.vim"
finished sourcing /home/max/.vim/plugin/settings/python.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/pythondebug.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/pythondebug.vim"
line 1: map <Leader>d oimport ipdb;ipdb.set_trace()<CR><ESC>
finished sourcing /home/max/.vim/plugin/settings/pythondebug.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/spacing.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/spacing.vim"
line 1: " spacing.vim
line 2: " ~/.vim/plugin/settings/spacing.vim
line 3: " use this to set default non file specific spacing
line 4: " set the tab width
line 5: set ts=2 sts=2 sw=2
line 6: 
line 7: "allow for inserting line break without entering insert
line 8: nmap <S-Enter> O<Esc>
line 9: nmap <CR> o<Esc>
finished sourcing /home/max/.vim/plugin/settings/spacing.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/splits.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/splits.vim"
line 1: " splits.vim
line 2: " ~/.vim/plugin/settings/splits.vim
line 3: " http://robots.thoughtbot.com/vim-splits-move-faster-and-more-naturally
line 4: " use this to set split settings
line 5: 
line 6: " set natural splitting
line 7: " i.e. split below and split right by default
line 8: set splitbelow
line 9: set splitright
line 10: 
line 11: " set easy split switching
line 12: nnoremap <C-J> <C-W><C-J>
line 13: nnoremap <C-K> <C-W><C-K>
line 14: nnoremap <C-L> <C-W><C-L>
line 15: nnoremap <C-H> <C-W><C-H>
finished sourcing /home/max/.vim/plugin/settings/splits.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/syntastic.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/syntastic.vim"
line 1: " syntastic.vim
line 2: " ~/.vim/plugin/settings/syntastic.vim
line 3: " used to set settings for syntastic
line 4: " https://github.com/scrooloose/syntastic
line 5: let g:syntastic_cpp_checkers=['cpplint']
line 6: let g:syntastic_cpp_check_headers=1
line 7: 
line 8: " custom pylintrc file
line 9: let g:syntastic_python_checkers=['pylint']
line 10: let g:syntastic_python_pylint_args='--rcfile=/home/max/.pylintrc'
line 11: let g:syntastic_python_pylint_post_args = '--rcfile=/home/max/.pylintrc'
line 12: " hopefully setting the bottom list thing
line 13: let g:syntastic_always_populate_loc_list = 1
line 14: " this is probably going to do the bottom thing
line 15: let g:syntastic_aggregate_errors = 1
line 16: 
line 17: let g:syntastic_check_on_open=1
line 18: let g:syntastic_enable_signs=1
line 19: 
line 20: " this really give me the thing on the bottom
line 21: let g:syntastic_auto_loc_list=0
line 22: 
line 23: " c++ 11 support
line 24: let g:syntastic_cpp_compiler_options = ' -std=c++11'
line 25: 
finished sourcing /home/max/.vim/plugin/settings/syntastic.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/vimtemp.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/vimtemp.vim"
line 1: " vimtemp.vim
line 2: " /home/max/plugin/settings/vimtemp.vim
line 3: "
line 4: " Changes the vim temp directory
line 5: 
line 6: set backupdir=//home//max//.vim//vimtemp//
line 7: 
finished sourcing /home/max/.vim/plugin/settings/vimtemp.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/vimundo.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/vimundo.vim"
line 1: " vimundo.vim
line 2: " /home/max/.vim/plugin/settings/vimundo.vim
line 3: " turns on persistant undoing
line 4: set undofile " save undo's after closing file
line 5: set undodir=/home/max/.vim/vimundo " where to save to
finished sourcing /home/max/.vim/plugin/settings/vimundo.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/vundle.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/vundle.vim"
line 1: " vundle.vim
line 2: " ~/.vim/plugin/settings/*.vim
line 3: " https://github.com/gmarik/Vundle.vim
line 4: " use this to set settings for Vundle
line 5: " vundle is a plugin manager used to install and update plugins cleanly
line 6: " ignore all settings up to the Plugin point
line 7: set nocompatible              " be iMproved, required
line 8: filetype off                  " required
Searching for "ftoff.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after"
Searching for "/home/max/.vim/ftoff.vim"
Searching for "/var/lib/vim/addons/ftoff.vim"
Searching for "/usr/share/vim/vimfiles/ftoff.vim"
Searching for "/usr/share/vim/vim74/ftoff.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 8: sourcing "/usr/share/vim/vim74/ftoff.vim"
line 1: " Vim support file to switch off detection of file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2001 Jun 11
line 5: 
line 6: if exists("did_load_filetypes")
line 7:   unlet did_load_filetypes
line 8: endif
line 9: 
line 10: " Remove all autocommands in the filetypedetect group
line 11: silent! au! filetypedetect *
finished sourcing /usr/share/vim/vim74/ftoff.vim
continuing in /home/max/.vim/plugin/settings/vundle.vim
Searching for "/usr/share/vim/vimfiles/after/ftoff.vim"
Searching for "/var/lib/vim/addons/after/ftoff.vim"
Searching for "/home/max/.vim/after/ftoff.vim"
line 9: 
line 10: " set the runtime path to include Vundle and initialize
line 11: set rtp+=/home/max/.vim/bundle/Vundle.vim
line 12: call vundle#begin()
Searching for "autoload/vundle.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim"
Searching for "/home/max/.vim/autoload/vundle.vim"
Searching for "/var/lib/vim/addons/autoload/vundle.vim"
Searching for "/usr/share/vim/vimfiles/autoload/vundle.vim"
Searching for "/usr/share/vim/vim74/autoload/vundle.vim"
Searching for "/usr/share/vim/vimfiles/after/autoload/vundle.vim"
Searching for "/var/lib/vim/addons/after/autoload/vundle.vim"
Searching for "/home/max/.vim/after/autoload/vundle.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/autoload/vundle.vim"
chdir(/home/max/.vim/bundle/Vundle.vim/autoload)
fchdir() to previous dir
line 12: sourcing "/home/max/.vim/bundle/Vundle.vim/autoload/vundle.vim"
line 1: " Vundle        is a shortcut for Vim Bundle and Is a simple plugin manager for Vim
line 2: " Author:       gmarik
line 3: " HomePage:     http://github.com/gmarik/Vundle.vim
line 4: " Readme:       http://github.com/gmarik/Vundle.vim/blob/master/README.md
line 5: " Version:      0.10.2
line 6: 
line 7: " Plugin Commands
line 9: com! -nargs=+  -bar   Plugin call vundle#config#bundle(<args>)
line 10: 
line 12: com! -nargs=? -bang -complete=custom,vundle#scripts#complete PluginInstall call vundle#installer#new('!' == '<bang>', <q-args>)
line 13: 
line 15: com! -nargs=? -bang -complete=custom,vundle#scripts#complete PluginSearch call vundle#scripts#all('!' == '<bang>', <q-args>)
line 16: 
line 18: com! -nargs=0 -bang PluginList call vundle#installer#list('!' == '<bang>')
line 19: 
line 21: com! -nargs=? -bang   PluginClean call vundle#installer#clean('!' == '<bang>')
line 22: 
line 24: com! -nargs=0         PluginDocs call vundle#installer#helptags(g:bundles)
line 25: 
line 26: " Aliases
line 27: com! PluginUpdate PluginInstall!
line 28: 
line 29: " Vundle Aliases
line 30: com! -nargs=? -bang -complete=custom,vundle#scripts#complete VundleInstall PluginInstall<bang> <args>
line 31: com! -nargs=? -bang -complete=custom,vundle#scripts#complete VundleSearch  PluginSearch<bang> <args>
line 32: com! -nargs=? -bang                                          VundleClean   PluginClean<bang>
line 33: com! -nargs=0                                                VundleDocs    PluginDocs
line 34: com!                                                         VundleUpdate  PluginInstall!
line 35: 
line 36: " Deprecated Commands
line 37: com! -nargs=+                                                Bundle        call vundle#config#bundle(<args>)
line 38: com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleInstall PluginInstall<bang> <args>
line 39: com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleSearch  PluginSearch<bang> <args>
line 40: com! -nargs=0 -bang                                          BundleList    PluginList<bang>
line 41: com! -nargs=? -bang                                          BundleClean   PluginClean<bang>
line 42: com! -nargs=0                                                BundleDocs    PluginDocs
line 43: com!                                                         BundleUpdate  PluginInstall!
line 44: 
line 45: " Set up the signs used in the installer window. (See :help signs)
line 46: if (has('signs'))
line 47:   sign define Vu_error    text=!  texthl=Error
line 48:   sign define Vu_active   text=>  texthl=Comment
line 49:   sign define Vu_todate   text=.  texthl=Comment
line 50:   sign define Vu_new      text=+  texthl=Comment
line 51:   sign define Vu_updated  text=*  texthl=Comment
line 52:   sign define Vu_deleted  text=-  texthl=Comment
line 53:   sign define Vu_helptags text=*  texthl=Comment
line 54:   sign define Vu_pinned   text==  texthl=Comment
line 55: endif
line 56: 
line 57: " Set up Vundle.  This function has to be called from the users vimrc file.
line 58: " This will force Vim to source this file as a side effect which wil define
line 59: " the :Plugin command.  After calling this function the user can use the
line 60: " :Plugin command in the vimrc.  It is not possible to do this automatically
line 61: " because when loading the vimrc file no plugins where loaded yet.
line 62: func! vundle#rc(...) abort
line 69: 
line 70: " Alternative to vundle#rc, offers speed up by modifying rtp only when end()
line 71: " called later.
line 72: func! vundle#begin(...) abort
line 76: 
line 77: " Finishes putting plugins on the rtp.
line 78: func! vundle#end(...) abort
line 82: 
line 83: " vim: set expandtab sts=2 ts=2 sw=2 tw=78 norl:
finished sourcing /home/max/.vim/bundle/Vundle.vim/autoload/vundle.vim
continuing in /home/max/.vim/plugin/settings/vundle.vim
calling function vundle#begin()

line 1:   let g:vundle_lazy_load = 1
line 2:   call call('vundle#rc', a:000)
calling function vundle#begin..vundle#rc()

line 1:   let g:bundle_dir = len(a:000) > 0 ? expand(a:1, 1) : expand('$HOME/.vim/bundle', 1)
line 2:   let g:updated_bundles = []
line 3:   let g:vundle_log = []
line 4:   let g:vundle_changelog = ['Updated Plugins:']
line 5:   call vundle#config#init()
Searching for "autoload/vundle/config.vim" in "/home/max/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim"
Searching for "/home/max/.vim/autoload/vundle/config.vim"
Searching for "/var/lib/vim/addons/autoload/vundle/config.vim"
Searching for "/usr/share/vim/vimfiles/autoload/vundle/config.vim"
Searching for "/usr/share/vim/vim74/autoload/vundle/config.vim"
Searching for "/usr/share/vim/vimfiles/after/autoload/vundle/config.vim"
Searching for "/var/lib/vim/addons/after/autoload/vundle/config.vim"
Searching for "/home/max/.vim/after/autoload/vundle/config.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/autoload/vundle/config.vim"
chdir(/home/max/.vim/bundle/Vundle.vim/autoload/vundle)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/Vundle.vim/autoload/vundle/config.vim"
line 1: " ---------------------------------------------------------------------------
line 2: " Add a plugin to the runtimepath.
line 3: "
line 4: " arg    -- a string specifying the plugin
line 5: " ...    -- a dictionary of options for the plugin
line 6: " return -- the return value from vundle#config#init_bundle()
line 7: " ---------------------------------------------------------------------------
line 8: func! vundle#config#bundle(arg, ...)
line 23: 
line 24: 
line 25: " ---------------------------------------------------------------------------
line 26: "  When lazy bundle load is used (begin/end functions), add all configured
line 27: "  bundles to runtimepath and reorder appropriately.
line 28: " ---------------------------------------------------------------------------
line 29: func! vundle#config#activate_bundles()
line 33: 
line 34: 
line 35: " ---------------------------------------------------------------------------
line 36: " Initialize Vundle.
line 37: "
line 38: " Start a new bundles list and make sure the runtimepath does not contain
line 39: " directories from a previous call. In theory, this should only be called
line 40: " once.
line 41: " ---------------------------------------------------------------------------
line 42: func! vundle#config#init()
line 48: 
line 49: 
line 50: " ---------------------------------------------------------------------------
line 51: " Add a list of bundles to the runtimepath and source them.
line 52: "
line 53: " bundles -- a list of bundle objects
line 54: " ---------------------------------------------------------------------------
line 55: func! vundle#config#require(bundles) abort
line 66: 
line 67: 
line 68: " ---------------------------------------------------------------------------
line 69: " Create a bundle object from a bundle specification.
line 70: "
line 71: " name   -- the bundle specification as a string
line 72: " opts   -- the options dictionary from then bundle definition
line 73: " return -- an initialized bundle object
line 74: " ---------------------------------------------------------------------------
line 75: func! vundle#config#init_bundle(name, opts)
line 84: 
line 85: 
line 86: " ---------------------------------------------------------------------------
line 87: " Check if the current bundle name has already been used in this running
line 88: " instance and show an error to that effect.
line 89: "
line 90: " bundle -- a bundle object whose name is to be checked
line 91: " return -- 0 if the bundle's name has been seen before, 1 otherwise
line 92: " ---------------------------------------------------------------------------
line 93: funct! s:check_bundle_name(bundle)
line 104: 
line 105: 
line 106: " ---------------------------------------------------------------------------
line 107: " Parse the options which can be supplied with the bundle specification.
line 108: " Corresponding documentation: vundle-plugins-configure
line 109: "
line 110: " opts   -- a dictionary with the user supplied options for the bundle
line 111: " return -- a dictionary with the user supplied options for the bundle, this
line 112: "           will be merged with a s:bundle object into one dictionary.
line 113: " ---------------------------------------------------------------------------
line 114: func! s:parse_options(opts)
line 124: 
line 125: 
line 126: " ---------------------------------------------------------------------------
line 127: " Parse the plugin specification.  Corresponding documentation:
line 128: " vundle-plugins-uris
line 129: "
line 130: " arg    -- the string supplied to identify the plugin
line 131: " return -- a dictionary with the folder name (key 'name') and the uri (key
line 132: "           'uri') for cloning the plugin  and the original argument (key
line 133: "           'name_spec')
line 134: " ---------------------------------------------------------------------------
line 135: func! s:parse_name(arg)
line 157: 
line 158: 
line 159: " ---------------------------------------------------------------------------
line 160: "  Modify the runtimepath, after all bundles have been added, so that the
line 161: "  directories that were in the default runtimepath appear first in the list
line 162: "  (with their 'after' directories last).
line 163: " ---------------------------------------------------------------------------
line 164: func! s:rtp_add_defaults()
line 176: 
line 177: 
line 178: " ---------------------------------------------------------------------------
line 179: " Remove all paths for the plugins which are managed by Vundle from the
line 180: " runtimepath.
line 181: " ---------------------------------------------------------------------------
line 182: func! s:rtp_rm_a()
line 189: 
line 190: 
line 191: " ---------------------------------------------------------------------------
line 192: " Add all paths for the plugins which are managed by Vundle to the
line 193: " runtimepath.
line 194: " ---------------------------------------------------------------------------
line 195: func! s:rtp_add_a()
line 202: 
line 203: 
line 204: " ---------------------------------------------------------------------------
line 205: " Remove a directory and the corresponding 'after' directory from runtimepath.
line 206: "
line 207: " dir    -- the directory name to be removed as a string.  The corresponding
line 208: "           'after' directory will also be removed.
line 209: " ---------------------------------------------------------------------------
line 210: func! s:rtp_rm(dir) abort
line 214: 
line 215: 
line 216: " ---------------------------------------------------------------------------
line 217: " Add a directory and the corresponding 'after' directory to runtimepath.
line 218: "
line 219: " dir    -- the directory name to be added as a string.  The corresponding
line 220: "           'after' directory will also be added.
line 221: " ---------------------------------------------------------------------------
line 222: func! s:rtp_add(dir) abort
line 226: 
line 227: 
line 228: " ---------------------------------------------------------------------------
line 229: " Expand and simplify a path.
line 230: "
line 231: " path   -- the path to expand as a string
line 232: " return -- the expanded and simplified path
line 233: " ---------------------------------------------------------------------------
line 234: func! s:expand_path(path) abort
line 237: 
line 238: 
line 239: " ---------------------------------------------------------------------------
line 240: " Find the actual path inside a bundle directory to be added to the
line 241: " runtimepath.  It might be provided by the user with the 'rtp' option.
line 242: " Corresponding documentation: vundle-plugins-configure
line 243: "
line 244: " opts   -- a bundle dict
line 245: " return -- expanded path to the corresponding plugin directory
line 246: " ---------------------------------------------------------------------------
line 247: func! s:rtpath(opts)
line 250: 
line 251: 
line 252: " ---------------------------------------------------------------------------
line 253: " a bundle 'object'
line 254: " ---------------------------------------------------------------------------
line 255: let s:bundle = {}
line 256: 
line 257: 
line 258: " ---------------------------------------------------------------------------
line 259: " Return the absolute path to the directory inside the bundle directory
line 260: " (prefix) where thr bundle will be cloned.
line 261: "
line 262: " return -- the target location to clone this bundle to
line 263: " ---------------------------------------------------------------------------
line 264: func! s:bundle.path()
line 267: 
line 268: 
line 269: " ---------------------------------------------------------------------------
line 270: "  Determine if the bundle has the pinned attribute set in the config
line 271: "
line 272: "  return -- 1 if the bundle is pinned, 0 otherwise
line 273: " ---------------------------------------------------------------------------
line 274: func! s:bundle.is_pinned()
line 277: 
line 278: " vim: set expandtab sts=2 ts=2 sw=2 tw=78 norl:
finished sourcing /home/max/.vim/bundle/Vundle.vim/autoload/vundle/config.vim
continuing in function vundle#begin..vundle#rc
calling function vundle#begin..vundle#rc..vundle#config#init()

line 1:   if !exists('g:bundles') | let g:bundles = [] | endif
line 1:  let g:bundles = [] | endif
line 1:  endif
line 2:   call s:rtp_rm_a()
calling function vundle#begin..vundle#rc..vundle#config#init..<SNR>29_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/after
function vundle#begin..vundle#rc..vundle#config#init..<SNR>29_rtp_rm_a returning #0

continuing in function vundle#begin..vundle#rc..vundle#config#init

line 3:   let g:bundles = []
line 4:   let g:bundle_names = {}
function vundle#begin..vundle#rc..vundle#config#init returning #0

continuing in function vundle#begin..vundle#rc

function vundle#begin..vundle#rc returning #0

continuing in function vundle#begin

function vundle#begin returning #0

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 13: " alternatively, pass a path where Vundle should install plugins
line 14: "let path = '~/some/path/here'
line 15: "call vundle#rc(path)
line 16: 
line 17: 
line 18: 
line 19: " settings start here
line 20: " let Vundle manage Vundle, required
line 21: Plugin 'gmarik/vundle'
line 21: call vundle#config#bundle('gmarik/vundle')
calling function vundle#config#bundle('gmarik/vundle')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('gmarik/vundle', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('gmarik/vundle')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/gmarik/vu... 'vundle', 'name_spec': 'gmarik/vundle'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/gmarik/vu... 'gmarik/vundle', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/vundle')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/vundle'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/vundle'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/vundle'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/gmarik/vu... 'gmarik/vundle', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/gmarik/vu... 'gmarik/vundle', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/gmarik/vu... 'gmarik/vundle', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 22: " The following are examples of different formats supported.
line 23: " Keep Plugin commands between here and filetype plugin indent on.
line 24: " scripts on GitHub repos
line 25: Plugin 'tpope/vim-fugitive'
line 25: call vundle#config#bundle('tpope/vim-fugitive')
calling function vundle#config#bundle('tpope/vim-fugitive')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('tpope/vim-fugitive', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('tpope/vim-fugitive')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/tpope/vim...ive', 'name_spec': 'tpope/vim-fugitive'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/tpope/vim...pe/vim-fugitive', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/vim-fugitive')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/vim-fugitive'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/vim-fugitive'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/vim-fugitive'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/tpope/vim...pe/vim-fugitive', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/tpope/vim...pe/vim-fugitive', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/tpope/vim...pe/vim-fugitive', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 26: Plugin 'Lokaltog/vim-easymotion'
line 26: call vundle#config#bundle('Lokaltog/vim-easymotion')
calling function vundle#config#bundle('Lokaltog/vim-easymotion')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('Lokaltog/vim-easymotion', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('Lokaltog/vim-easymotion')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/Lokaltog/... 'name_spec': 'Lokaltog/vim-easymotion'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/Lokaltog/.../vim-easymotion', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/vim-easymotion')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/vim-easymotion'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/vim-easymotion'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/vim-easymotion'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/Lokaltog/.../vim-easymotion', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/Lokaltog/.../vim-easymotion', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/Lokaltog/.../vim-easymotion', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 27: Plugin 'tpope/vim-rails.git'
line 27: call vundle#config#bundle('tpope/vim-rails.git')
calling function vundle#config#bundle('tpope/vim-rails.git')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('tpope/vim-rails.git', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('tpope/vim-rails.git')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/tpope/vim...ls', 'name_spec': 'tpope/vim-rails.git'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/tpope/vim...e/vim-rails.git', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/vim-rails')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/vim-rails'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/vim-rails'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/vim-rails'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/tpope/vim...e/vim-rails.git', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/tpope/vim...e/vim-rails.git', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/tpope/vim...e/vim-rails.git', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 28: " The sparkup vim script is in a subdirectory of this repo called vim.
line 29: " Pass the path to set the runtimepath properly.
line 30: Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}
line 30: call vundle#config#bundle('rstacruz/sparkup', {'rtp': 'vim/'})
calling function vundle#config#bundle('rstacruz/sparkup', {'rtp': 'vim/'})

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('rstacruz/sparkup', [{'rtp': 'vim/'}])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([{'rtp': 'vim/'}])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
line 2:  endif
line 3: 
line 4:   if type(a:opts[0]) == type({})
line 5:     return a:opts[0]
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {'rtp': 'vim/'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('rstacruz/sparkup')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/rstacruz/...arkup', 'name_spec': 'rstacruz/sparkup'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/rstacruz/...stacruz/sparkup', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/sparkup')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/sparkup'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/sparkup'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..<SNR>29_expand_path('/home/max/.vim/bundle/sparkup/vim/')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..<SNR>29_expand_path returning '/home/max/.vim/bundle/sparkup/vim/'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/sparkup/vim/'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/rstacruz/...stacruz/sparkup', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/rstacruz/...stacruz/sparkup', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/rstacruz/...stacruz/sparkup', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 31: " scripts from http://vim-scripts.org/vim/scripts.html
line 32: Plugin 'L9'
line 32: call vundle#config#bundle('L9')
calling function vundle#config#bundle('L9')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('L9', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('L9')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/vim-scrip...9.git', 'name': 'L9', 'name_spec': 'L9'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/vim-scrip...name_spec': 'L9', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/L9')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/L9'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/L9'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/L9'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/vim-scrip...name_spec': 'L9', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/vim-scrip...name_spec': 'L9', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/vim-scrip...name_spec': 'L9', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 33: Plugin 'FuzzyFinder'
line 33: call vundle#config#bundle('FuzzyFinder')
calling function vundle#config#bundle('FuzzyFinder')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('FuzzyFinder', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('FuzzyFinder')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/vim-scrip...uzzyFinder', 'name_spec': 'FuzzyFinder'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/vim-scrip...': 'FuzzyFinder', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/FuzzyFinder')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/FuzzyFinder'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/FuzzyFinder'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/FuzzyFinder'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/vim-scrip...': 'FuzzyFinder', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/vim-scrip...': 'FuzzyFinder', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/vim-scrip...': 'FuzzyFinder', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 34: " scripts not on GitHub
line 35: Plugin 'git://git.wincent.com/command-t.git'
line 35: call vundle#config#bundle('git://git.wincent.com/command-t.git')
calling function vundle#config#bundle('git://git.wincent.com/command-t.git')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('git://git.wincent.com/command-t.git', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('git://git.wincent.com/command-t.git')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'git://git.wincent.com/comman...: 'git://git.wincent.com/command-t.git'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'git://git.wincent.com/comman...m/command-t.git', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/command-t')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/command-t'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/command-t'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/command-t'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'git://git.wincent.com/comman...m/command-t.git', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'git://git.wincent.com/comman...m/command-t.git', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'git://git.wincent.com/comman...m/command-t.git', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 36: " git repos on your local machine (i.e. when working on your own plugin)
line 37: " Plugin 'file:///home/gmarik/path/to/plugin'
line 38: " ...
line 39: 
line 40: " these are the ones I installed
line 41: " fuzzy autocomplete like in sublime
line 42: Plugin 'Valloric/YouCompleteMe'
line 42: call vundle#config#bundle('Valloric/YouCompleteMe')
calling function vundle#config#bundle('Valloric/YouCompleteMe')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('Valloric/YouCompleteMe', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('Valloric/YouCompleteMe')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/Valloric/..., 'name_spec': 'Valloric/YouCompleteMe'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/Valloric/...c/YouCompleteMe', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/YouCompleteMe')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/YouCompleteMe'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/YouCompleteMe'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/YouCompleteMe'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/Valloric/...c/YouCompleteMe', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/Valloric/...c/YouCompleteMe', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/Valloric/...c/YouCompleteMe', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 43: Plugin 'scrooloose/syntastic.git'
line 43: call vundle#config#bundle('scrooloose/syntastic.git')
calling function vundle#config#bundle('scrooloose/syntastic.git')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('scrooloose/syntastic.git', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('scrooloose/syntastic.git')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/scrooloos...'name_spec': 'scrooloose/syntastic.git'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/scrooloos...e/syntastic.git', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/syntastic')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/syntastic'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/syntastic'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/syntastic'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/scrooloos...e/syntastic.git', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/scrooloos...e/syntastic.git', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/scrooloos...e/syntastic.git', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 44: 
line 45: " finds files in git repo
line 46: Plugin 'kien/ctrlp.vim'
line 46: call vundle#config#bundle('kien/ctrlp.vim')
calling function vundle#config#bundle('kien/ctrlp.vim')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('kien/ctrlp.vim', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('kien/ctrlp.vim')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/kien/ctrl...rlp.vim', 'name_spec': 'kien/ctrlp.vim'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/kien/ctrl...'kien/ctrlp.vim', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/ctrlp.vim')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/ctrlp.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/ctrlp.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/ctrlp.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/kien/ctrl...'kien/ctrlp.vim', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/kien/ctrl...'kien/ctrlp.vim', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/kien/ctrl...'kien/ctrlp.vim', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 47: 
line 48: " All the go lang stuff you could need
line 49: Plugin 'jnwhiteh/vim-golang'
line 49: call vundle#config#bundle('jnwhiteh/vim-golang')
calling function vundle#config#bundle('jnwhiteh/vim-golang')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('jnwhiteh/vim-golang', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('jnwhiteh/vim-golang')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/jnwhiteh/...ng', 'name_spec': 'jnwhiteh/vim-golang'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/jnwhiteh/...iteh/vim-golang', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/vim-golang')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/vim-golang'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/vim-golang'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/vim-golang'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/jnwhiteh/...iteh/vim-golang', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/jnwhiteh/...iteh/vim-golang', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/jnwhiteh/...iteh/vim-golang', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 50: 
line 51: " sass stuff
line 52: Plugin 'cakebaker/scss-syntax.vim'
line 52: call vundle#config#bundle('cakebaker/scss-syntax.vim')
calling function vundle#config#bundle('cakebaker/scss-syntax.vim')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('cakebaker/scss-syntax.vim', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('cakebaker/scss-syntax.vim')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/cakebaker...name_spec': 'cakebaker/scss-syntax.vim'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/cakebaker...scss-syntax.vim', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/scss-syntax.vim')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/scss-syntax.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/scss-syntax.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/scss-syntax.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/cakebaker...scss-syntax.vim', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/cakebaker...scss-syntax.vim', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/cakebaker...scss-syntax.vim', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 53: 
line 54: " coffee
line 55: Plugin 'kchmck/vim-coffee-script'
line 55: call vundle#config#bundle('kchmck/vim-coffee-script')
calling function vundle#config#bundle('kchmck/vim-coffee-script')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('kchmck/vim-coffee-script', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('kchmck/vim-coffee-script')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/kchmck/vi...'name_spec': 'kchmck/vim-coffee-script'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/kchmck/vi...m-coffee-script', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/vim-coffee-script')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/vim-coffee-script'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/vim-coffee-script'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/vim-coffee-script'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/kchmck/vi...m-coffee-script', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/kchmck/vi...m-coffee-script', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/kchmck/vi...m-coffee-script', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 56: 
line 57: " latex
line 58: Plugin 'LaTeX-Box-Team/LaTeX-Box'
line 58: call vundle#config#bundle('LaTeX-Box-Team/LaTeX-Box')
calling function vundle#config#bundle('LaTeX-Box-Team/LaTeX-Box')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('LaTeX-Box-Team/LaTeX-Box', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('LaTeX-Box-Team/LaTeX-Box')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/LaTeX-Box...'name_spec': 'LaTeX-Box-Team/LaTeX-Box'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/LaTeX-Box...-Team/LaTeX-Box', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/LaTeX-Box')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/LaTeX-Box'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/LaTeX-Box'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/LaTeX-Box'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/LaTeX-Box...-Team/LaTeX-Box', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/LaTeX-Box...-Team/LaTeX-Box', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/LaTeX-Box...-Team/LaTeX-Box', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 59: 
line 60: " C++
line 61: Plugin 'vim-scripts/google.vim'
line 61: call vundle#config#bundle('vim-scripts/google.vim')
calling function vundle#config#bundle('vim-scripts/google.vim')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('vim-scripts/google.vim', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('vim-scripts/google.vim')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/vim-scrip..., 'name_spec': 'vim-scripts/google.vim'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/vim-scrip...ipts/google.vim', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/google.vim')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/google.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/google.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/google.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/vim-scrip...ipts/google.vim', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/vim-scrip...ipts/google.vim', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/vim-scrip...ipts/google.vim', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 62: 
line 63: call vundle#end()
calling function vundle#end()

line 1:   unlet g:vundle_lazy_load
line 2:   call vundle#config#activate_bundles()
calling function vundle#end..vundle#config#activate_bundles()

line 1:   call s:rtp_add_a()
calling function vundle#end..vundle#config#activate_bundles..<SNR>29_rtp_add_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/after,/home/max/.vim/bundle/command-t/after,/home/max/.vim/bundle/YouCompleteMe/after,/home/max/.vim/bundle/syntastic/after,/home/max/.vim/bundle/ctrlp.vim/after,/home/max/.vim/bundle/vim-golang/after,/home/max/.vim/bundle/scss-syntax.vim/after,/home/max/.vim/bundle/vim-coffee-script/after,/home/max/.vim/bundle/LaTeX-Box/after,/home/max/.vim/bundle/google.vim/after
function vundle#end..vundle#config#activate_bundles..<SNR>29_rtp_add_a returning #0

continuing in function vundle#end..vundle#config#activate_bundles

line 2:   call s:rtp_add_defaults()
calling function vundle#end..vundle#config#activate_bundles..<SNR>29_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/home/max/.vim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/home/max/.vim
line 10:   endif
function vundle#end..vundle#config#activate_bundles..<SNR>29_rtp_add_defaults returning #0

continuing in function vundle#end..vundle#config#activate_bundles

function vundle#end..vundle#config#activate_bundles returning #0

continuing in function vundle#end

function vundle#end returning #0

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 64: filetype plugin indent on     " required
Searching for "filetype.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/aft
Searching for "/home/max/.vim/filetype.vim"
Searching for "/home/max/.vim/bundle/vundle/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-rails/filetype.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/filetype.vim"
Searching for "/home/max/.vim/bundle/L9/filetype.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/filetype.vim"
Searching for "/home/max/.vim/bundle/command-t/filetype.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/filetype.vim"
Searching for "/home/max/.vim/bundle/syntastic/filetype.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-golang/filetype.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/filetype.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/filetype.vim"
Searching for "/home/max/.vim/bundle/google.vim/filetype.vim"
Searching for "/var/lib/vim/addons/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim74/filetype.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 64: sourcing "/usr/share/vim/vim74/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2013 Sep 22
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
line 9: endif
line 10: let did_load_filetypes = 1
line 11: 
line 12: " Line continuation is used here, remove 'C' from 'cpoptions'
line 13: let s:cpo_save = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup filetypedetect
line 17: 
line 18: " Ignored extensions
line 19: if exists("*fnameescape")
line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 33: elseif &verbose > 0
line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 35: endif
line 36: 
line 37: " Pattern used to match file names which should not be inspected.
line 38: " Currently finds compressed files.
line 39: if !exists("g:ft_ignore_pat")
line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 41: endif
line 42: 
line 43: " Function used for patterns that end in a star: don't set the filetype if the
line 44: " file name matches ft_ignore_pat.
line 45: func! s:StarSetf(ft)
line 50: 
line 51: " Abaqus or Trasys
line 52: au BufNewFile,BufRead *.inp^I^I^Icall s:Check_inp()
line 53: 
line 54: func! s:Check_inp()
line 73: 
line 74: " A-A-P recipe
line 75: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 76: 
line 77: " A2ps printing utility
line 78: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 79: 
line 80: " ABAB/4
line 81: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 82: 
line 83: " ABC music notation
line 84: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 85: 
line 86: " ABEL
line 87: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 88: 
line 89: " AceDB
line 90: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 91: 
line 92: " Ada (83, 9X, 95)
line 93: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 94: if has("vms")
line 95:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 96: else
line 97:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 98: endif
line 99: 
line 100: " AHDL
line 101: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 102: 
line 103: " AMPL
line 104: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 105: 
line 106: " Ant
line 107: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 108: 
line 109: " Apache style config file
line 110: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')
line 111: 
line 112: " Apache config file
line 113: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 114: 
line 115: " XA65 MOS6510 cross assembler
line 116: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 117: 
line 118: " Applescript
line 119: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 120: 
line 121: " Applix ELF
line 123: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
line 124: 
line 125: " ALSA configuration
line 126: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 127: 
line 128: " Arc Macro Language
line 129: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 130: 
line 131: " APT config file
line 132: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 133: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 134: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
line 135: 
line 136: " Arch Inventory file
line 137: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 138: 
line 139: " ART*Enterprise (formerly ART-IM)
line 140: au BufNewFile,BufRead *.art^I^I^Isetf art
line 141: 
line 142: " AsciiDoc
line 143: au BufNewFile,BufRead *.asciidoc^I^Isetf asciidoc
line 144: 
line 145: " ASN.1
line 146: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 147: 
line 148: " Active Server Pages (with Visual Basic Script)
line 154: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 155: 
line 156: " Active Server Pages (with Perl or Visual Basic Script)
line 164: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 165: 
line 166: " Grub (must be before catch *.lst)
line 167: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 168: 
line 169: " Assembly (all kinds)
line 170: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 171: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall s:FTasm()
line 172: 
line 173: " This function checks for the kind of assembly that is wanted by the user, or
line 174: " can be detected from the first five lines of the file.
line 175: func! s:FTasm()
line 196: 
line 197: func! s:FTasmsyntax()
line 209: 
line 210: " Macro (VAX)
line 211: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 212: 
line 213: " Atlas
line 214: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 215: 
line 216: " Autoit v3
line 217: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 218: 
line 219: " Autohotkey
line 220: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 221: 
line 222: " Automake
line 223: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 224: 
line 225: " Autotest .at files are actually m4
line 226: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 227: 
line 228: " Avenue
line 229: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 230: 
line 231: " Awk
line 232: au BufNewFile,BufRead *.awk^I^I^Isetf awk
line 233: 
line 234: " B
line 235: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 236: 
line 237: " BASIC or Visual Basic
line 238: au BufNewFile,BufRead *.bas^I^I^Icall s:FTVB("basic")
line 239: 
line 240: " Check if one of the first five lines contains "VB_Name".  In that case it is
line 241: " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
line 242: func! s:FTVB(alt)
line 249: 
line 250: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
line 251: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb
line 252: 
line 253: " IBasic file (similar to QBasic)
line 254: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 255: 
line 256: " FreeBasic file (similar to QBasic)
line 257: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic
line 258: 
line 259: " Batch file for MSDOS.
line 260: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch
line 261: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
line 263: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
line 264: 
line 265: " Batch file for 4DOS
line 266: au BufNewFile,BufRead *.btm^I^I^Icall s:FTbtm()
line 267: func! s:FTbtm()
line 274: 
line 275: " BC calculator
line 276: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 277: 
line 278: " BDF font
line 279: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 280: 
line 281: " BibTeX bibliography database file
line 282: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 283: 
line 284: " BibTeX Bibliography Style
line 285: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 286: 
line 287: " BIND configuration
line 288: au BufNewFile,BufRead named.conf,rndc.conf^Isetf named
line 289: 
line 290: " BIND zone
line 291: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 292: au BufNewFile,BufRead *.db^I^I^Icall s:BindzoneCheck('')
line 293: 
line 294: func! s:BindzoneCheck(default)
line 301: 
line 302: " Blank
line 303: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 304: 
line 305: " Blkid cache file
line 306: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 307: 
line 308: " C or lpc
line 309: au BufNewFile,BufRead *.c^I^I^Icall s:FTlpc()
line 310: 
line 311: func! s:FTlpc()
line 324: 
line 325: " Calendar
line 326: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 327: 
line 328: " C#
line 329: au BufNewFile,BufRead *.cs^I^I^Isetf cs
line 330: 
line 331: " CSDL
line 332: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 333: 
line 334: " Cabal
line 335: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 336: 
line 337: " Cdrdao TOC
line 338: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
line 339: 
line 340: " Cdrdao config
line 341: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 342: 
line 343: " Cfengine
line 344: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 345: 
line 346: " ChaiScript
line 347: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 348: 
line 349: " Comshare Dimension Definition Language
line 350: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 351: 
line 352: " Conary Recipe
line 353: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 354: 
line 355: " Controllable Regex Mutilator
line 356: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 357: 
line 358: " Cyn++
line 359: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 360: 
line 361: " Cynlib
line 362: " .cc and .cpp files can be C++ or Cynlib.
line 364: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 366: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 367: 
line 368: " C++
line 369: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 370: if has("fname_case")
line 371:   au BufNewFile,BufRead *.C,*.H setf cpp
line 372: endif
line 373: 
line 374: " .h files can be C, Ch C++, ObjC or ObjC++.
line 375: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 376: " detected automatically.
line 377: au BufNewFile,BufRead *.h^I^I^Icall s:FTheader()
line 378: 
line 379: func! s:FTheader()
line 394: 
line 395: " Ch (CHscript)
line 396: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 397: 
line 398: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 399: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 400: 
line 401: " Cascading Style Sheets
line 402: au BufNewFile,BufRead *.css^I^I^Isetf css
line 403: 
line 404: " Century Term Command Scripts (*.cmd too)
line 405: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 406: 
line 407: " Changelog
line 409: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog
line 410: 
line 416: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 417: 
line 421: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 422: 
line 423: " CHILL
line 424: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 425: 
line 426: " Changes for WEB and CWEB or CHILL
line 427: au BufNewFile,BufRead *.ch^I^I^Icall s:FTchange()
line 428: 
line 429: " This function checks if one of the first ten lines start with a '@'.  In
line 430: " that case it is probably a change file.
line 431: " If the first line starts with # or ! it's probably a ch file.
line 432: " If a line has "main", "include", "//" ir "/*" it's probably ch.
line 433: " Otherwise CHILL is assumed.
line 434: func! s:FTchange()
line 457: 
line 458: " ChordPro
line 459: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 460: 
line 461: " Clean
line 462: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 463: 
line 464: " Clever
line 465: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 466: 
line 467: " Clever or dtd
line 468: au BufNewFile,BufRead *.ent^I^I^Icall s:FTent()
line 469: 
line 470: func! s:FTent()
line 489: 
line 490: " Clipper (or FoxPro; could also be eviews)
line 496: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif
line 497: 
line 498: " Clojure
line 499: au BufNewFile,BufRead *.clj,*.cljs^I^Isetf clojure
line 500: 
line 501: " Cmake
line 502: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 503: 
line 504: " Cmusrc
line 505: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 506: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 507: 
line 508: " Cobol
line 509: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
line 510: "   cobol or zope form controller python script? (heuristic)
line 516: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 517: 
line 518: " Coco/R
line 519: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 520: 
line 521: " Cold Fusion
line 522: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 523: 
line 524: " Configure scripts
line 525: au BufNewFile,BufRead configure.in,configure.ac setf config
line 526: 
line 527: " CUDA  Cumpute Unified Device Architecture
line 528: au BufNewFile,BufRead *.cu^I^I^Isetf cuda
line 529: 
line 530: " WildPackets EtherPeek Decoder
line 531: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 532: 
line 533: " Enlightenment configuration files
line 534: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 535: 
line 536: " Eterm
line 537: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 538: 
line 539: " Lynx config files
line 540: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 541: 
line 542: " Quake
line 543: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 544: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 545: 
line 546: " Quake C
line 547: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 548: 
line 549: " Configure files
line 550: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg
line 551: 
line 552: " Cucumber
line 553: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 554: 
line 555: " Communicating Sequential Processes
line 556: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 557: 
line 558: " CUPL logic description and simulation
line 559: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 560: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 561: 
line 562: " Debian Control
line 563: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
line 567: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
line 568: 
line 569: " Debian Sources.list
line 570: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 571: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 572: 
line 573: " Deny hosts
line 574: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 575: 
line 576: " dnsmasq(8) configuration files
line 577: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 578: 
line 579: " ROCKLinux package description
line 580: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 581: 
line 582: " the D language or dtrace
line 583: au BufNewFile,BufRead *.d^I^I^Icall s:DtraceCheck()
line 584: 
line 585: func! s:DtraceCheck()
line 596: 
line 597: " Desktop files
line 598: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop
line 599: 
line 600: " Dict config
line 601: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 602: 
line 603: " Dictd config
line 604: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf
line 605: 
line 606: " Diff files
line 607: au BufNewFile,BufRead *.diff,*.rej,*.patch^Isetf diff
line 608: 
line 609: " Dircolors
line 610: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 611: 
line 612: " Diva (with Skill) or InstallShield
line 618: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 619: 
line 620: " DCL (Digital Command Language - vms) or DNS zone file
line 621: au BufNewFile,BufRead *.com^I^I^Icall s:BindzoneCheck('dcl')
line 622: 
line 623: " DOT
line 624: au BufNewFile,BufRead *.dot^I^I^Isetf dot
line 625: 
line 626: " Dylan - lid files
line 627: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 628: 
line 629: " Dylan - intr files (melange)
line 630: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 631: 
line 632: " Dylan
line 633: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 634: 
line 635: " Microsoft Module Definition
line 636: au BufNewFile,BufRead *.def^I^I^Isetf def
line 637: 
line 638: " Dracula
line 639: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
line 640: 
line 641: " Datascript
line 642: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 643: 
line 644: " dsl
line 645: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl
line 646: 
line 647: " DTD (Document Type Definition for XML)
line 648: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 649: 
line 650: " DTS/DSTI (device tree files)
line 651: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
line 652: 
line 653: " EDIF (*.edf,*.edif,*.edn,*.edo)
line 654: au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)^Isetf edif
line 655: 
line 656: " Embedix Component Description
line 657: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 658: 
line 659: " Eiffel or Specman
line 660: au BufNewFile,BufRead *.e,*.E^I^I^Icall s:FTe()
line 661: 
line 662: " Elinks configuration
line 663: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks
line 664: 
line 665: func! s:FTe()
line 676: 
line 677: " ERicsson LANGuage; Yaws is erlang too
line 678: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 679: 
line 680: " Elm Filter Rules file
line 681: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 682: 
line 683: " ESMTP rc file
line 684: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 685: 
line 686: " ESQL-C
line 687: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 688: 
line 689: " Esterel
line 690: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 691: 
line 692: " Essbase script
line 693: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 694: 
line 695: " Exim
line 696: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 697: 
line 698: " Expect
line 699: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 700: 
line 701: " Exports
line 702: au BufNewFile,BufRead exports^I^I^Isetf exports
line 703: 
line 704: " Falcon
line 705: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 706: 
line 707: " Fantom
line 708: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 709: 
line 710: " Factor
line 711: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 712: 
line 713: " Fetchmail RC file
line 714: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 715: 
line 716: " FlexWiki - disabled, because it has side effects when a .wiki file
line 717: " is not actually FlexWiki
line 718: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
line 719: 
line 720: " Focus Executable
line 721: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 722: 
line 723: " Focus Master file (but not for auto.master)
line 724: au BufNewFile,BufRead auto.master^I^Isetf conf
line 725: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 726: 
line 727: " Forth
line 728: au BufNewFile,BufRead *.fs,*.ft^I^I^Isetf forth
line 729: 
line 730: " Reva Forth
line 731: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 732: 
line 733: " Fortran
line 734: if has("fname_case")
line 735:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran
line 736: endif
line 737: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
line 738: 
line 739: " Framescript
line 740: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 741: 
line 742: " FStab
line 743: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 744: 
line 745: " GDB command files
line 746: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb
line 747: 
line 748: " GDMO
line 749: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 750: 
line 751: " Gedcom
line 752: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 753: 
line 754: " Git
line 755: au BufNewFile,BufRead *.git/COMMIT_EDITMSG^Isetf gitcommit
line 756: au BufNewFile,BufRead *.git/MERGE_MSG^I^Isetf gitcommit
line 757: au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
line 758: au BufNewFile,BufRead *.git/modules/*/COMMIT_EDITMSG setf gitcommit
line 759: au BufNewFile,BufRead *.git/modules/*/config^Isetf gitconfig
line 760: au BufNewFile,BufRead */.config/git/config^Isetf gitconfig
line 761: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase
line 765: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif
line 769: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif
line 770: 
line 771: " Gkrellmrc
line 772: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 773: 
line 774: " GP scripts (2.0 and onward)
line 775: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 776: 
line 777: " GPG
line 778: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 779: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 780: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 781: 
line 782: " gnash(1) configuration files
line 783: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 784: 
line 785: " Gitolite
line 786: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 787: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 788: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 789: 
line 790: " Gnuplot scripts
line 791: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot
line 792: 
line 793: " GrADS scripts
line 794: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 795: 
line 796: " Gretl
line 797: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 798: 
line 799: " Groovy
line 800: au BufNewFile,BufRead *.groovy^I^I^Isetf groovy
line 801: 
line 802: " GNU Server Pages
line 803: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 804: 
line 805: " Group file
line 806: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 807: 
line 808: " GTK RC
line 809: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 810: 
line 811: " Haml
line 812: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 813: 
line 814: " Hamster Classic | Playground files
line 815: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster
line 816: 
line 817: " Haskell
line 818: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell
line 819: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 820: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 821: 
line 822: " Haste
line 823: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 824: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 825: 
line 826: " Hercules
line 827: au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum^Isetf hercules
line 828: 
line 829: " HEX (Intel)
line 830: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
line 831: 
line 832: " Tilde (must be before HTML)
line 833: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 834: 
line 835: " HTML (.shtml and .stm for server side)
line 836: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
line 837: 
line 838: " Distinguish between HTML, XHTML and Django
line 839: func! s:FThtml()
line 854: 
line 855: " HTML with Ruby - eRuby
line 856: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 857: 
line 858: " HTML with M4
line 859: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 860: 
line 861: " HTML Cheetah template
line 862: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah
line 863: 
line 864: " Host config
line 865: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 866: 
line 867: " Hosts access
line 868: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 869: 
line 870: " Hyper Builder
line 871: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 872: 
line 873: " Httest
line 874: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 875: 
line 876: " Icon
line 877: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 878: 
line 879: " IDL (Interface Description Language)
line 880: au BufNewFile,BufRead *.idl^I^I^Icall s:FTidl()
line 881: 
line 882: " Distinguish between standard IDL and MS-IDL
line 883: func! s:FTidl()
line 894: 
line 895: " Microsoft IDL (Interface Description Language)  Also *.idl
line 896: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 897: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 898: 
line 899: " Icewm menu
line 900: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 901: 
line 902: " Indent profile (must come before IDL *.pro!)
line 903: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 904: au BufNewFile,BufRead indent.pro^I^Icall s:ProtoCheck('indent')
line 905: 
line 906: " IDL (Interactive Data Language)
line 907: au BufNewFile,BufRead *.pro^I^I^Icall s:ProtoCheck('idlang')
line 908: 
line 909: " Distinguish between "default" and Cproto prototype file. */
line 910: func! s:ProtoCheck(default)
line 922: 
line 923: 
line 924: " Indent RC
line 925: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 926: 
line 927: " Inform
line 928: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 929: 
line 930: " Initng
line 931: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 932: 
line 933: " Innovation Data Processing
line 934: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat
line 935: au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c ^Isetf upstreamlog
line 936: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 937: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog
line 938: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog
line 939: 
line 940: " Ipfilter
line 941: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 942: 
line 943: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 944: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 945: 
line 946: " .INI file for MSDOS
line 947: au BufNewFile,BufRead *.ini^I^I^Isetf dosini
line 948: 
line 949: " SysV Inittab
line 950: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 951: 
line 952: " Inno Setup
line 953: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 954: 
line 955: " J
line 956: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 957: 
line 958: " JAL
line 959: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 960: 
line 961: " Jam
line 962: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 963: 
line 964: " Java
line 965: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
line 966: 
line 967: " JavaCC
line 968: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 969: 
line 970: " JavaScript, ECMAScript
line 971: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.json   setf javascript
line 972: 
line 973: " Java Server Pages
line 974: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 975: 
line 976: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 977: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 978: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 979: 
line 980: " Jess
line 981: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 982: 
line 983: " Jgraph
line 984: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 985: 
line 986: " Jovial
line 987: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 988: 
line 989: " Kixtart
line 990: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 991: 
line 992: " Kimwitu[++]
line 993: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 994: 
line 995: " KDE script
line 996: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 997: 
line 998: " Kconfig
line 999: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
line 1000: 
line 1001: " Lace (ISE)
line 1002: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 1003: 
line 1004: " Latte
line 1005: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 1006: 
line 1007: " Limits
line 1008: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 1009: 
line 1010: " LambdaProlog (*.mod too, see Modsim)
line 1011: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog
line 1012: 
line 1013: " LDAP LDIF
line 1014: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 1015: 
line 1016: " Ld loader
line 1017: au BufNewFile,BufRead *.ld^I^I^Isetf ld
line 1018: 
line 1019: " Lex
line 1020: au BufNewFile,BufRead *.lex,*.l^I^I^Isetf lex
line 1021: 
line 1022: " Libao
line 1023: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 1024: 
line 1025: " Libsensors
line 1026: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 1027: 
line 1028: " LFTP
line 1029: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 1030: 
line 1031: " Lifelines (or Lex for C++!)
line 1032: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
line 1033: 
line 1034: " Lilo: Linux loader
line 1035: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 1036: 
line 1037: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
line 1038: if has("fname_case")
line 1039:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
line 1040: else
line 1041:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
line 1042: endif
line 1043: 
line 1044: " SBCL implementation of Common Lisp
line 1045: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 1046: 
line 1047: " Liquid
line 1048: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 1049: 
line 1050: " Lite
line 1051: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 1052: 
line 1053: " LiteStep RC files
line 1054: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 1055: 
line 1056: " Login access
line 1057: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 1058: 
line 1059: " Login defs
line 1060: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 1061: 
line 1062: " Logtalk
line 1063: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 1064: 
line 1065: " LOTOS
line 1066: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
line 1067: 
line 1068: " Lout (also: *.lt)
line 1069: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 1070: 
line 1071: " Lua
line 1072: au BufNewFile,BufRead *.lua^I^I^Isetf lua
line 1073: 
line 1074: " Linden Scripting Language (Second Life)
line 1075: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl
line 1076: 
line 1077: " Lynx style file (or LotusScript!)
line 1078: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 1079: 
line 1080: " M4
line 1082: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 1083: 
line 1084: " MaGic Point
line 1085: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 1086: 
line 1087: " Mail (for Elm, trn, mutt, muttng, rn, slrn)
line 1088: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 1089: 
line 1090: " Mail aliases
line 1091: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 1092: 
line 1093: " Mailcap configuration file
line 1094: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 1095: 
line 1096: " Makefile
line 1097: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
line 1098: 
line 1099: " MakeIndex
line 1100: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 1101: 
line 1102: " Mallard
line 1103: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 1104: 
line 1105: " Manpage
line 1106: au BufNewFile,BufRead *.man^I^I^Isetf man
line 1107: 
line 1108: " Man config
line 1109: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 1110: 
line 1111: " Maple V
line 1112: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 1113: 
line 1114: " Map (UMN mapserver config file)
line 1115: au BufNewFile,BufRead *.map^I^I^Isetf map
line 1116: 
line 1117: " Markdown
line 1118: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,README.md  setf markdown
line 1119: 
line 1120: " Mason
line 1121: au BufNewFile,BufRead *.mason,*.mhtml^I^Isetf mason
line 1122: 
line 1123: " Matlab or Objective C
line 1124: au BufNewFile,BufRead *.m^I^I^Icall s:FTm()
line 1125: 
line 1126: func! s:FTm()
line 1150: 
line 1151: " Mathematica notebook
line 1152: au BufNewFile,BufRead *.nb^I^I^Isetf mma
line 1153: 
line 1154: " Maya Extension Language
line 1155: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 1156: 
line 1157: " Mercurial (hg) commit file
line 1158: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 1159: 
line 1160: " Mercurial config (looks like generic config file)
line 1161: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 1162: 
line 1163: " Messages (logs mostly)
line 1164: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 1165: 
line 1166: " Metafont
line 1167: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 1168: 
line 1169: " MetaPost
line 1170: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 1171: 
line 1172: " MGL
line 1173: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 1174: 
line 1175: " MMIX or VMS makefile
line 1176: au BufNewFile,BufRead *.mms^I^I^Icall s:FTmms()
line 1177: 
line 1178: " Symbian meta-makefile definition (MMP)
line 1179: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 1180: 
line 1181: func! s:FTmms()
line 1197: 
line 1198: 
line 1199: " Modsim III (or LambdaProlog)
line 1205: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif
line 1206: 
line 1207: " Modula 2
line 1208: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.md,*.mi setf modula2
line 1209: 
line 1210: " Modula 3 (.m3, .i3, .mg, .ig)
line 1211: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1212: 
line 1213: " Monk
line 1214: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1215: 
line 1216: " MOO
line 1217: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1218: 
line 1219: " Modconf
line 1220: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1221: 
line 1222: " Mplayer config
line 1223: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1224: 
line 1225: " Moterola S record
line 1226: au BufNewFile,BufRead *.s19,*.s28,*.s37^I^Isetf srec
line 1227: 
line 1228: " Mrxvtrc
line 1229: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1230: 
line 1231: " Msql
line 1232: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1233: 
line 1234: " Mysql
line 1235: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
line 1236: 
line 1237: " Mutt setup files (must be before catch *.rc)
line 1238: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 1239: 
line 1240: " M$ Resource files
line 1241: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc
line 1242: 
line 1243: " MuPAD source
line 1244: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1245: 
line 1246: " Mush
line 1247: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1248: 
line 1249: " Mutt setup file (also for Muttng)
line 1250: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1251: 
line 1252: " Nano
line 1253: au BufNewFile,BufRead */etc/nanorc,.nanorc^Isetf nanorc
line 1254: 
line 1255: " Nastran input/DMAP
line 1256: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1257: 
line 1258: " Natural
line 1259: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1260: 
line 1261: " Netrc
line 1262: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1263: 
line 1264: " Ninja file
line 1265: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1266: 
line 1267: " Novell netware batch files
line 1268: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1269: 
line 1270: " Nroff/Troff (*.ms and *.t are checked below)
line 1274: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1275: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1276: au BufNewFile,BufRead *.[1-9]^I^I^Icall s:FTnroff()
line 1277: 
line 1278: " This function checks if one of the first five lines start with a dot.  In
line 1279: " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
line 1280: func! s:FTnroff()
line 1287: 
line 1288: " Nroff or Objective C++
line 1289: au BufNewFile,BufRead *.mm^I^I^Icall s:FTmm()
line 1290: 
line 1291: func! s:FTmm()
line 1303: 
line 1304: " Not Quite C
line 1305: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1306: 
line 1307: " NSIS
line 1308: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1309: 
line 1310: " OCAML
line 1311: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml
line 1312: 
line 1313: " Occam
line 1314: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1315: 
line 1316: " Omnimark
line 1317: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1318: 
line 1319: " OpenROAD
line 1320: au BufNewFile,BufRead *.or^I^I^Isetf openroad
line 1321: 
line 1322: " OPL
line 1323: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl
line 1324: 
line 1325: " Oracle config file
line 1326: au BufNewFile,BufRead *.ora^I^I^Isetf ora
line 1327: 
line 1328: " Packet filter conf
line 1329: au BufNewFile,BufRead pf.conf^I^I^Isetf pf
line 1330: 
line 1331: " Pam conf
line 1332: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf
line 1333: 
line 1334: " PApp
line 1335: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp
line 1336: 
line 1337: " Password file
line 1338: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1339: 
line 1340: " Pascal (also *.p)
line 1341: au BufNewFile,BufRead *.pas^I^I^Isetf pascal
line 1342: 
line 1343: " Delphi project file
line 1344: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal
line 1345: 
line 1346: " PDF
line 1347: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf
line 1348: 
line 1349: " Perl
line 1350: if has("fname_case")
line 1351:   au BufNewFile,BufRead *.pl,*.PL^I^Icall s:FTpl()
line 1352: else
line 1353:   au BufNewFile,BufRead *.pl^I^I^Icall s:FTpl()
line 1354: endif
line 1355: au BufNewFile,BufRead *.plx,*.al^I^Isetf perl
line 1356: au BufNewFile,BufRead *.p6,*.pm6^I^Isetf perl6
line 1357: 
line 1358: func! s:FTpl()
line 1372: 
line 1373: " Perl, XPM or XPM2
line 1381: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1382: 
line 1383: " Perl POD
line 1384: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1385: 
line 1386: " Php, php3, php4, etc.
line 1387: " Also Phtml (was used for PHP 2 in the past)
line 1388: " Also .ctp for Cake template file
line 1389: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php
line 1390: 
line 1391: " Pike
line 1392: au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
line 1393: 
line 1394: " Pinfo config
line 1395: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1396: 
line 1397: " Palm Resource compiler
line 1398: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1399: 
line 1400: " Pine config
line 1401: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1402: 
line 1403: " PL/1, PL/I
line 1404: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1405: 
line 1406: " PL/M (also: *.inp)
line 1407: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1408: 
line 1409: " PL/SQL
line 1410: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1411: 
line 1412: " PLP
line 1413: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1414: 
line 1415: " PO and PO template (GNU gettext)
line 1416: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1417: 
line 1418: " Postfix main config
line 1419: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain
line 1420: 
line 1421: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1422: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1423: 
line 1424: " PostScript Printer Description
line 1425: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1426: 
line 1427: " Povray
line 1428: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1429: 
line 1430: " Povray configuration
line 1431: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1432: 
line 1433: " Povray, PHP or assembly
line 1434: au BufNewFile,BufRead *.inc^I^I^Icall s:FTinc()
line 1435: 
line 1436: func! s:FTinc()
line 1457: 
line 1458: " Printcap and Termcap
line 1460: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1462: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1463: 
line 1464: " PCCTS / ANTRL
line 1465: "au BufNewFile,BufRead *.g^I^I^Isetf antrl
line 1466: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 1467: 
line 1468: " PPWizard
line 1469: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1470: 
line 1471: " Obj 3D file format
line 1472: " TODO: is there a way to avoid MS-Windows Object files?
line 1473: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1474: 
line 1475: " Oracle Pro*C/C++
line 1476: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1477: 
line 1478: " Privoxy actions file
line 1479: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1480: 
line 1481: " Procmail
line 1482: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1483: 
line 1484: " Progress or CWEB
line 1485: au BufNewFile,BufRead *.w^I^I^Icall s:FTprogress_cweb()
line 1486: 
line 1487: func! s:FTprogress_cweb()
line 1498: 
line 1499: " Progress or assembly
line 1500: au BufNewFile,BufRead *.i^I^I^Icall s:FTprogress_asm()
line 1501: 
line 1502: func! s:FTprogress_asm()
line 1524: 
line 1525: " Progress or Pascal
line 1526: au BufNewFile,BufRead *.p^I^I^Icall s:FTprogress_pascal()
line 1527: 
line 1528: func! s:FTprogress_pascal()
line 1552: 
line 1553: 
line 1554: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1555: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1559: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1560: 
line 1561: " Prolog
line 1562: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1563: 
line 1564: " Promela
line 1565: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 1566: 
line 1567: " Google protocol buffers
line 1568: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 1569: 
line 1570: " Protocols
line 1571: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 1572: 
line 1573: " Pyrex
line 1574: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
line 1575: 
line 1576: " Python
line 1577: au BufNewFile,BufRead *.py,*.pyw^I^Isetf python
line 1578: 
line 1579: " Quixote (Python-based web framework)
line 1580: au BufNewFile,BufRead *.ptl^I^I^Isetf python
line 1581: 
line 1582: " Radiance
line 1583: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 1584: 
line 1585: " Ratpoison config/command files
line 1586: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 1587: 
line 1588: " RCS file
line 1589: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 1590: 
line 1591: " Readline
line 1592: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 1593: 
line 1594: " Registry for MS-Windows
line 1596: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 1597: 
line 1598: " Renderman Interface Bytestream
line 1599: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 1600: 
line 1601: " Rexx
line 1602: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 1603: 
line 1604: " R (Splus)
line 1605: if has("fname_case")
line 1606:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r
line 1607: else
line 1608:   au BufNewFile,BufRead *.s^I^I^Isetf r
line 1609: endif
line 1610: 
line 1611: " R Help file
line 1612: if has("fname_case")
line 1613:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 1614: else
line 1615:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 1616: endif
line 1617: 
line 1618: " R noweb file
line 1619: if has("fname_case")
line 1620:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 1621: else
line 1622:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 1623: endif
line 1624: 
line 1625: " Rexx, Rebol or R
line 1626: au BufNewFile,BufRead *.r,*.R^I^I^Icall s:FTr()
line 1627: 
line 1628: func! s:FTr()
line 1660: 
line 1661: " Remind
line 1662: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 1663: 
line 1664: " Resolv.conf
line 1665: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 1666: 
line 1667: " Relax NG Compact
line 1668: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 1669: 
line 1670: " Relax NG XML
line 1671: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 1672: 
line 1673: " RPL/2
line 1674: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 1675: 
line 1676: " Robots.txt
line 1677: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 1678: 
line 1679: " Rpcgen
line 1680: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 1681: 
line 1682: " reStructuredText Documentation Format
line 1683: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 1684: 
line 1685: " RTF
line 1686: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 1687: 
line 1688: " Interactive Ruby shell
line 1689: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
line 1690: 
line 1691: " Ruby
line 1692: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 1693: 
line 1694: " RubyGems
line 1695: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 1696: 
line 1697: " Rackup
line 1698: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 1699: 
line 1700: " Bundler
line 1701: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 1702: 
line 1703: " Ruby on Rails
line 1704: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 1705: 
line 1706: " Rantfile and Rakefile is like Ruby
line 1707: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 1708: 
line 1709: " S-lang (or shader language, or SmallLisp)
line 1710: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 1711: 
line 1712: " Samba config
line 1713: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 1714: 
line 1715: " SAS script
line 1716: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 1717: 
line 1718: " Sass
line 1719: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 1720: 
line 1721: " Sather
line 1722: au BufNewFile,BufRead *.sa^I^I^Isetf sather
line 1723: 
line 1724: " Scilab
line 1725: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 1726: 
line 1727: " SCSS
line 1728: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 1729: 
line 1730: " SD: Streaming Descriptors
line 1731: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 1732: 
line 1733: " SDL
line 1734: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 1735: 
line 1736: " sed
line 1737: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 1738: 
line 1739: " Sieve (RFC 3028)
line 1740: au BufNewFile,BufRead *.siv^I^I^Isetf sieve
line 1741: 
line 1742: " Sendmail
line 1743: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 1744: 
line 1745: " Sendmail .mc files are actually m4.  Could also be MS Message text file.
line 1746: au BufNewFile,BufRead *.mc^I^I^Icall s:McSetf()
line 1747: 
line 1748: func! s:McSetf()
line 1763: 
line 1764: " Services
line 1765: au BufNewFile,BufRead */etc/services^I^Isetf services
line 1766: 
line 1767: " Service Location config
line 1768: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 1769: 
line 1770: " Service Location registration
line 1771: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 1772: 
line 1773: " Service Location SPI
line 1774: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 1775: 
line 1776: " Setserial config
line 1777: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 1778: 
line 1779: " SGML
line 1789: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 1790: 
line 1791: " SGMLDECL
line 1795: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 1796: 
line 1797: " SGML catalog file
line 1798: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 1799: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 1800: 
line 1801: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 1802: " Gentoo ebuilds are actually bash scripts
line 1803: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash_profile*,.bash_logout*,*.bash,*.ebuild call SetFileTypeSH("bash")
line 1804: au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
line 1805: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
line 1806: 
line 1807: " Also called from scripts.vim.
line 1808: func! SetFileTypeSH(name)
line 1851: 
line 1852: " For shell-like file types, check for an "exec" command hidden in a comment,
line 1853: " as used for Tcl.
line 1854: " Also called from scripts.vim, thus can't be local to this script.
line 1855: func! SetFileTypeShell(name)
line 1874: 
line 1875: " tcsh scripts
line 1876: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall SetFileTypeShell("tcsh")
line 1877: 
line 1878: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 1879: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
line 1880: 
line 1881: func! s:CSH()
line 1890: 
line 1891: " Z-Shell script
line 1892: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 1893: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 1894: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
line 1895: 
line 1896: " Scheme
line 1897: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme
line 1898: 
line 1899: " Screen RC
line 1900: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 1901: 
line 1902: " Simula
line 1903: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 1904: 
line 1905: " SINDA
line 1906: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 1907: 
line 1908: " SiSU
line 1909: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 1910: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 1911: 
line 1912: " SKILL
line 1913: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 1914: 
line 1915: " SLRN
line 1916: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 1917: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 1918: 
line 1919: " Smalltalk (and TeX)
line 1920: au BufNewFile,BufRead *.st^I^I^Isetf st
line 1928: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif
line 1929: 
line 1930: " Smarty templates
line 1931: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 1932: 
line 1933: " SMIL or XML
line 1939: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 1940: 
line 1941: " SMIL or SNMP MIB file
line 1947: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 1948: 
line 1949: " SMITH
line 1950: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 1951: 
line 1952: " Snobol4 and spitbol
line 1953: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 1954: 
line 1955: " SNMP MIB files
line 1956: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 1957: 
line 1958: " Snort Configuration
line 1959: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 1960: au BufNewFile,BufRead *.rules^I^I^Icall s:FTRules()
line 1961: 
line 1962: let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
line 1963: func! s:FTRules()
line 1991: 
line 1992: 
line 1993: " Spec (Linux RPM)
line 1994: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 1995: 
line 1996: " Speedup (AspenTech plant simulator)
line 1997: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 1998: 
line 1999: " Slice
line 2000: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 2001: 
line 2002: " Spice
line 2003: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 2004: 
line 2005: " Spyce
line 2006: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 2007: 
line 2008: " Squid
line 2009: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 2010: 
line 2011: " SQL for Oracle Designer
line 2012: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql
line 2013: 
line 2014: " SQL
line 2015: au BufNewFile,BufRead *.sql^I^I^Icall s:SQL()
line 2016: 
line 2017: func! s:SQL()
line 2024: 
line 2025: " SQLJ
line 2026: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 2027: 
line 2028: " SQR
line 2029: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 2030: 
line 2031: " OpenSSH configuration
line 2032: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig
line 2033: 
line 2034: " OpenSSH server configuration
line 2035: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig
line 2036: 
line 2037: " Stata
line 2038: au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata
line 2039: 
line 2040: " SMCL
line 2041: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 2042: 
line 2043: " Stored Procedures
line 2044: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 2045: 
line 2046: " Standard ML
line 2047: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 2048: 
line 2049: " Sratus VOS command macro
line 2050: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 2051: 
line 2052: " Sysctl
line 2053: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 2054: 
line 2055: " Synopsys Design Constraints
line 2056: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 2057: 
line 2058: " Sudoers
line 2059: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 2060: 
line 2061: " SVG (Scalable Vector Graphics)
line 2062: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 2063: 
line 2064: " If the file has an extension of 't' and is in a directory 't' then it is
line 2065: " almost certainly a Perl test file.
line 2066: " If the first line starts with '#' and contains 'perl' it's probably a Perl
line 2067: " file.
line 2068: " (Slow test) If a file contains a 'use' statement then it is almost certainly
line 2069: " a Perl file.
line 2070: func! s:FTperl()
line 2085: 
line 2086: " Tads (or Nroff or Perl test file)
line 2088: au BufNewFile,BufRead *.t if !s:FTnroff() && !s:FTperl() | setf tads | endif
line 2089: 
line 2090: " Tags
line 2091: au BufNewFile,BufRead tags^I^I^Isetf tags
line 2092: 
line 2093: " TAK
line 2094: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 2095: 
line 2096: " Task
line 2097: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 2098: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 2099: 
line 2100: " Tcl (JACL too)
line 2101: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl
line 2102: 
line 2103: " TealInfo
line 2104: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 2105: 
line 2106: " Telix Salt
line 2107: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 2108: 
line 2109: " Terminfo
line 2110: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 2111: 
line 2112: " TeX
line 2113: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 2114: au BufNewFile,BufRead *.tex^I^I^Icall s:FTtex()
line 2115: 
line 2116: " Choose context, plaintex, or tex (LaTeX) based on these rules:
line 2117: " 1. Check the first line of the file for "%&<format>".
line 2118: " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
line 2119: " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
line 2120: func! s:FTtex()
line 2167: 
line 2168: " ConTeXt
line 2169: au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context
line 2170: 
line 2171: " Texinfo
line 2172: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 2173: 
line 2174: " TeX configuration
line 2175: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 2176: 
line 2177: " Tidy config
line 2178: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy
line 2179: 
line 2180: " TF mud client
line 2181: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf
line 2182: 
line 2183: " TPP - Text Presentation Program
line 2184: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp
line 2185: 
line 2186: " Treetop
line 2187: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 2188: 
line 2189: " Trustees
line 2190: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 2191: 
line 2192: " TSS - Geometry
line 2193: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 2194: 
line 2195: " TSS - Optics
line 2196: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 2197: 
line 2198: " TSS - Command Line (temporary)
line 2199: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 2200: 
line 2201: " TWIG files
line 2202: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 2203: 
line 2204: " Motif UIT/UIL files
line 2205: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 2206: 
line 2207: " Udev conf
line 2208: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 2209: 
line 2210: " Udev permissions
line 2211: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 2212: "
line 2213: " Udev symlinks config
line 2214: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 2215: 
line 2216: " UnrealScript
line 2217: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 2218: 
line 2219: " Updatedb
line 2220: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 2221: 
line 2222: " Upstart (init(8)) config files
line 2223: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 2224: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 2225: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 2226: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart
line 2227: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 2228: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 2229: 
line 2230: " Vera
line 2231: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 2232: 
line 2233: " Verilog HDL
line 2234: au BufNewFile,BufRead *.v^I^I^Isetf verilog
line 2235: 
line 2236: " Verilog-AMS HDL
line 2237: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 2238: 
line 2239: " VHDL
line 2240: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
line 2241: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 2242: 
line 2243: " Vim script
line 2244: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim
line 2245: 
line 2246: " Viminfo file
line 2247: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 2248: 
line 2249: " Virata Config Script File or Drupal module
line 2255: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 2256: 
line 2257: " Visual Basic (also uses *.bas) or FORM
line 2258: au BufNewFile,BufRead *.frm^I^I^Icall s:FTVB("form")
line 2259: 
line 2260: " SaxBasic is close to Visual Basic
line 2261: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 2262: 
line 2263: " Vgrindefs file
line 2264: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 2265: 
line 2266: " VRML V1.0c
line 2267: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 2268: 
line 2269: " Webmacro
line 2270: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 2271: 
line 2272: " Wget config
line 2273: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 2274: 
line 2275: " Website MetaLanguage
line 2276: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 2277: 
line 2278: " Winbatch
line 2279: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 2280: 
line 2281: " WSML
line 2282: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 2283: 
line 2284: " WvDial
line 2285: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 2286: 
line 2287: " CVS RC file
line 2288: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 2289: 
line 2290: " CVS commit file
line 2291: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 2292: 
line 2293: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 2294: " lines in a WEB file).
line 2300: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 2301: 
line 2302: " Windows Scripting Host and Windows Script Component
line 2303: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 2304: 
line 2305: " XHTML
line 2306: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 2307: 
line 2308: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
line 2314: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 2315: au BufEnter *.xpm2^I^I^I^Isetf xpm2
line 2316: 
line 2317: " XFree86 config
line 2322: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 2325: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2326: 
line 2327: " Xorg config
line 2328: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2329: 
line 2330: " Xinetd conf
line 2331: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 2332: 
line 2333: " XS Perl extension interface language
line 2334: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 2335: 
line 2336: " X resources file
line 2337: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 2338: 
line 2339: " Xmath
line 2340: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 2342: au BufNewFile,BufRead *.ms if !s:FTnroff() | setf xmath | endif
line 2343: 
line 2344: " XML  specific variants: docbk and xbl
line 2345: au BufNewFile,BufRead *.xml^I^I^Icall s:FTxml()
line 2346: 
line 2347: func! s:FTxml()
line 2372: 
line 2373: " XMI (holding UML models) is also XML
line 2374: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 2375: 
line 2376: " CSPROJ files are Visual Studio.NET's XML-based project config files
line 2377: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 2378: 
line 2379: " Qt Linguist translation source and Qt User Interface Files are XML
line 2380: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml
line 2381: 
line 2382: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 2383: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 2384: 
line 2385: " Xdg menus
line 2386: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 2387: 
line 2388: " ATI graphics driver configuration
line 2389: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 2390: 
line 2391: " XLIFF (XML Localisation Interchange File Format) is also XML
line 2392: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 2393: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 2394: 
line 2395: " XML User Interface Language
line 2396: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 2397: 
line 2398: " X11 xmodmap (also see below)
line 2399: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 2400: 
line 2401: " Xquery
line 2402: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 2403: 
line 2404: " XSD
line 2405: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 2406: 
line 2407: " Xslt
line 2408: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 2409: 
line 2410: " Yacc
line 2411: au BufNewFile,BufRead *.yy^I^I^Isetf yacc
line 2412: 
line 2413: " Yacc or racc
line 2414: au BufNewFile,BufRead *.y^I^I^Icall s:FTy()
line 2415: 
line 2416: func! s:FTy()
line 2432: 
line 2433: 
line 2434: " Yaml
line 2435: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml
line 2436: 
line 2437: " yum conf (close enough to dosini)
line 2438: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 2439: 
line 2440: " Zimbu
line 2441: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 2442: 
line 2443: " Zope
line 2444: "   dtml (zope dynamic template markup language), pt (zope page template),
line 2445: "   cpt (zope form controller page template)
line 2446: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall s:FThtml()
line 2447: "   zsql (zope sql method)
line 2448: au BufNewFile,BufRead *.zsql^I^I^Icall s:SQL()
line 2449: 
line 2450: " Z80 assembler asz80
line 2451: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 2452: 
line 2453: augroup END
line 2454: 
line 2455: 
line 2456: " Source the user-specified filetype file, for backwards compatibility with
line 2457: " Vim 5.x.
line 2458: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 2459:   execute "source " . myfiletypefile
line 2460: endif
line 2461: 
line 2462: 
line 2463: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 2464: " when there are no matching file name extensions.
line 2465: " Don't do this for compressed files.
line 2466: augroup filetypedetect
line 2469: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 2470: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 2471: 
line 2472: 
line 2473: " Extra checks for when no filetype has been detected now.  Mostly used for
line 2474: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 2475: " script file.
line 2476: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 2477: " like are used.
line 2478: 
line 2479: " More Apache config files
line 2480: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
line 2481: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
line 2482: 
line 2483: " Asterisk config file
line 2484: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 2485: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 2486: 
line 2487: " Bazaar version control
line 2488: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 2489: 
line 2490: " BIND zone
line 2491: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 2492: 
line 2493: " Calendar
line 2496: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 2497: 
line 2498: " Changelog
line 2504: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 2505: 
line 2506: " Crontab
line 2507: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 2508: 
line 2509: " dnsmasq(8) configuration
line 2510: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 2511: 
line 2512: " Dracula
line 2513: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 2514: 
line 2515: " Fvwm
line 2516: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 2518: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 2524: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 2525: 
line 2526: " Gedcom
line 2527: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 2528: 
line 2529: " GTK RC
line 2530: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 2531: 
line 2532: " Jam
line 2533: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 2534: 
line 2535: " Jargon
line 2539: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 2540: 
line 2541: " Kconfig
line 2542: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
line 2543: 
line 2544: " Lilo: Linux loader
line 2545: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 2546: 
line 2547: " Logcheck
line 2548: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 2549: 
line 2550: " Makefile
line 2551: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 2552: 
line 2553: " Ruby Makefile
line 2554: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 2555: 
line 2556: " Mail (also matches muttrc.vim, so this is below the other checks)
line 2557: au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 2558: 
line 2559: " Modconf
line 2563: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 2564: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 2565: 
line 2566: " Mutt setup file
line 2567: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 2568: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 2569: 
line 2570: " Nroff macros
line 2571: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 2572: 
line 2573: " Pam conf
line 2574: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 2575: 
line 2576: " Printcap and Termcap
line 2580: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 2584: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 2585: 
line 2586: " ReDIF
line 2587: " Only used when the .rdf file was not detected to be XML.
line 2588: au BufRead,BufNewFile *.rdf^I^I^Icall s:Redif()
line 2589: func! s:Redif()
line 2599: 
line 2600: " Remind
line 2601: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 2602: 
line 2603: " Vim script
line 2604: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 2605: 
line 2606: " Subversion commit file
line 2607: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 2608: 
line 2609: " X resources file
line 2610: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 2611: 
line 2612: " XFree86 config
line 2614: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 2619: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 2620: 
line 2621: " X11 xmodmap
line 2622: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 2623: 
line 2624: " Xinetd conf
line 2625: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 2626: 
line 2627: " yum conf (close enough to dosini)
line 2628: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 2629: 
line 2630: " Z-Shell script
line 2631: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 2632: 
line 2633: 
line 2634: " Plain text files, needs to be far down to not override others.  This avoids
line 2635: " the "conf" type being used if there is a line starting with '#'.
line 2636: au BufNewFile,BufRead *.txt,*.text^I^Isetf text
line 2637: 
line 2638: 
line 2639: " Use the filetype detect plugins.  They may overrule any of the previously
line 2640: " detected filetypes.
line 2641: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/a
Searching for "/home/max/.vim/ftdetect/*.vim"
chdir(/home/max/.vim/ftdetect)
fchdir() to previous dir
line 2641: sourcing "/home/max/.vim/ftdetect/gofiletype.vim"
line 1: " We take care to preserve the user's fileencodings and fileformats,
line 2: " because those settings are global (not buffer local), yet we want
line 3: " to override them for loading Go files, which are defined to be UTF-8.
line 4: let s:current_fileformats = ''
line 5: let s:current_fileencodings = ''
line 6: 
line 7: " define fileencodings to open as utf-8 encoding even if it's ascii.
line 8: function! s:gofiletype_pre()
line 14: 
line 15: " restore fileencodings as others
line 16: function! s:gofiletype_post()
line 20: 
line 21: au BufNewFile *.go setlocal filetype=go fileencoding=utf-8 fileformat=unix
line 22: au BufRead *.go call s:gofiletype_pre()
line 23: au BufReadPost *.go call s:gofiletype_post()
finished sourcing /home/max/.vim/ftdetect/gofiletype.vim
continuing in /usr/share/vim/vim74/filetype.vim
Searching for "/home/max/.vim/bundle/vundle/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-rails/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/L9/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/command-t/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/syntastic/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-golang/ftdetect/*.vim"
chdir(/home/max/.vim/bundle/vim-golang/ftdetect)
fchdir() to previous dir
line 2641: sourcing "/home/max/.vim/bundle/vim-golang/ftdetect/gofiletype.vim"
line 1: " We take care to preserve the user's fileencodings and fileformats,
line 2: " because those settings are global (not buffer local), yet we want
line 3: " to override them for loading Go files, which are defined to be UTF-8.
line 4: let s:current_fileformats = ''
line 5: let s:current_fileencodings = ''
line 6: 
line 7: " define fileencodings to open as utf-8 encoding even if it's ascii.
line 8: function! s:gofiletype_pre()
line 14: 
line 15: " restore fileencodings as others
line 16: function! s:gofiletype_post()
line 20: 
line 21: au BufNewFile *.go setlocal filetype=go fileencoding=utf-8 fileformat=unix
line 22: au BufRead *.go call s:gofiletype_pre()
line 23: au BufReadPost *.go call s:gofiletype_post()
finished sourcing /home/max/.vim/bundle/vim-golang/ftdetect/gofiletype.vim
continuing in /usr/share/vim/vim74/filetype.vim
Searching for "/home/max/.vim/bundle/scss-syntax.vim/ftdetect/*.vim"
chdir(/home/max/.vim/bundle/scss-syntax.vim/ftdetect)
fchdir() to previous dir
line 2641: sourcing "/home/max/.vim/bundle/scss-syntax.vim/ftdetect/scss.vim"
line 1: au BufRead,BufNewFile *.scss set filetype=scss
line 2: au BufEnter *.scss :syntax sync fromstart
finished sourcing /home/max/.vim/bundle/scss-syntax.vim/ftdetect/scss.vim
continuing in /usr/share/vim/vim74/filetype.vim
Searching for "/home/max/.vim/bundle/vim-coffee-script/ftdetect/*.vim"
chdir(/home/max/.vim/bundle/vim-coffee-script/ftdetect)
fchdir() to previous dir
line 2641: sourcing "/home/max/.vim/bundle/vim-coffee-script/ftdetect/coffee.vim"
line 1: " Language:    CoffeeScript
line 2: " Maintainer:  Mick Koch <kchmck@gmail.com>
line 3: " URL:         http://github.com/kchmck/vim-coffee-script
line 4: " License:     WTFPL
line 5: 
line 6: autocmd BufNewFile,BufRead *.coffee set filetype=coffee
line 7: autocmd BufNewFile,BufRead *Cakefile set filetype=coffee
line 8: autocmd BufNewFile,BufRead *.coffeekup,*.ck set filetype=coffee
line 9: autocmd BufNewFile,BufRead *._coffee set filetype=coffee
line 10: 
line 11: function! s:DetectCoffee()
line 16: 
line 17: autocmd BufNewFile,BufRead * call s:DetectCoffee()
finished sourcing /home/max/.vim/bundle/vim-coffee-script/ftdetect/coffee.vim
continuing in /usr/share/vim/vim74/filetype.vim
Searching for "/home/max/.vim/bundle/LaTeX-Box/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/google.vim/ftdetect/*.vim"
Searching for "/var/lib/vim/addons/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"
Searching for "/usr/share/vim/vim74/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"
Searching for "/var/lib/vim/addons/after/ftdetect/*.vim"
Searching for "/home/max/.vim/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vundle/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/L9/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/command-t/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/ftdetect/*.vim"
line 2642: 
line 2643: " NOTE: The above command could have ended the filetypedetect autocmd group
line 2644: " and started another one. Let's make sure it has ended to get to a consistent
line 2645: " state.
line 2646: augroup END
line 2647: 
line 2648: " Generic configuration file (check this last, it's just guessing!)
line 2654: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf conf | endif
line 2655: 
line 2656: 
line 2657: " If the GUI is already running, may still need to install the Syntax menu.
line 2658: " Don't do it when the 'M' flag is included in 'guioptions'.
line 2660: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 2661:   source <sfile>:p:h/menu.vim
line 2662: endif
line 2663: 
line 2664: " Function called for testing all functions defined here.  These are
line 2665: " script-local, thus need to be executed here.
line 2666: " Returns a string with error messages (hopefully empty).
line 2667: func! TestFiletypeFuncs(testlist)
line 2678: 
line 2679: " Restore 'cpoptions'
line 2680: let &cpo = s:cpo_save
line 2681: unlet s:cpo_save
finished sourcing /usr/share/vim/vim74/filetype.vim
continuing in /home/max/.vim/plugin/settings/vundle.vim
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/var/lib/vim/addons/after/filetype.vim"
Searching for "/home/max/.vim/after/filetype.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/filetype.vim"
Searching for "/home/max/.vim/bundle/vundle/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/filetype.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/filetype.vim"
Searching for "/home/max/.vim/bundle/L9/after/filetype.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/filetype.vim"
Searching for "/home/max/.vim/bundle/command-t/after/filetype.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/filetype.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/filetype.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/filetype.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/filetype.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/filetype.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/filetype.vim"
Searching for "ftplugin.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/aft
Searching for "/home/max/.vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vundle/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-rails/ftplugin.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/L9/ftplugin.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/ftplugin.vim"
Searching for "/home/max/.vim/bundle/command-t/ftplugin.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/ftplugin.vim"
Searching for "/home/max/.vim/bundle/syntastic/ftplugin.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-golang/ftplugin.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/ftplugin.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/ftplugin.vim"
Searching for "/home/max/.vim/bundle/google.vim/ftplugin.vim"
Searching for "/var/lib/vim/addons/ftplugin.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"
Searching for "/usr/share/vim/vim74/ftplugin.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 64: sourcing "/usr/share/vim/vim74/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
finished sourcing /usr/share/vim/vim74/ftplugin.vim
continuing in /home/max/.vim/plugin/settings/vundle.vim
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"
Searching for "/var/lib/vim/addons/after/ftplugin.vim"
Searching for "/home/max/.vim/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vundle/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/L9/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/command-t/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/ftplugin.vim"
Searching for "indent.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/after
Searching for "/home/max/.vim/indent.vim"
Searching for "/home/max/.vim/bundle/vundle/indent.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/indent.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/indent.vim"
Searching for "/home/max/.vim/bundle/vim-rails/indent.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/indent.vim"
Searching for "/home/max/.vim/bundle/L9/indent.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/indent.vim"
Searching for "/home/max/.vim/bundle/command-t/indent.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/indent.vim"
Searching for "/home/max/.vim/bundle/syntastic/indent.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/indent.vim"
Searching for "/home/max/.vim/bundle/vim-golang/indent.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/indent.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/indent.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/indent.vim"
Searching for "/home/max/.vim/bundle/google.vim/indent.vim"
Searching for "/var/lib/vim/addons/indent.vim"
Searching for "/usr/share/vim/vimfiles/indent.vim"
Searching for "/usr/share/vim/vim74/indent.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 64: sourcing "/usr/share/vim/vim74/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
line 5: 
line 6: if exists("did_indent_on")
line 7:   finish
finished sourcing /usr/share/vim/vim74/indent.vim
continuing in /home/max/.vim/plugin/settings/vundle.vim
Searching for "/usr/share/vim/vimfiles/after/indent.vim"
Searching for "/var/lib/vim/addons/after/indent.vim"
Searching for "/home/max/.vim/after/indent.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/indent.vim"
Searching for "/home/max/.vim/bundle/vundle/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/indent.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/indent.vim"
Searching for "/home/max/.vim/bundle/L9/after/indent.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/indent.vim"
Searching for "/home/max/.vim/bundle/command-t/after/indent.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/indent.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/indent.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/indent.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/indent.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/indent.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/indent.vim"
line 65: " To ignore plugin indent changes, instead use:
line 66: "filetype plugin on
line 67: "
line 68: " Brief help
line 69: " :PluginList          - list configured plugins
line 70: " :PluginInstall(!)    - install (update) plugins
line 71: " :PluginSearch(!) foo - search (or refresh cache first) for foo
line 72: " :PluginClean(!)      - confirm (or auto-approve) removal of unused plugins
line 73: "
line 74: " see :h vundle for more details or wiki for FAQ
line 75: " NOTE: comments after Plugin commands are not allowed.
line 76: " Put your stuff after this line
finished sourcing /home/max/.vim/plugin/settings/vundle.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 2: source /home/max/.vim/plugin/settings/youcompleteme.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/plugin/settings/youcompleteme.vim"
line 1: " youcompleteme.vim
line 2: " /home/max/.vim/plugins/settings/youcompleteme.vim
line 3: " 
line 4: " used to setup youcompleteme settings
line 5: 
line 6: " blacklist some files
line 9: let g:ycm_filetype_blacklist = { 'go' :1}
finished sourcing /home/max/.vim/plugin/settings/youcompleteme.vim
continuing in /home/max/.vimrc
line 3: endfor
line 1: for f in split(glob('~/.vim/plugin/settings/*.vim'), '\n')
line 2:   exe 'source' f
line 3: endfor
finished sourcing $HOME/.vimrc
Searching for "plugin/**/*.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/
Searching for "/home/max/.vim/plugin/**/*.vim"
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/autocomplete.vim"
line 1: " autocomplete.vim
line 2: " ~/.vimrc/plugin/settings/autocomplete.vm
line 3: " use this to map the autocomplete key to tab and also other settings
line 4: 
line 5: " map tab to ctrl p
line 6: imap <Tab> <C-P>
finished sourcing /home/max/.vim/plugin/settings/autocomplete.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/base.vim"
line 1: " When started as "evim", evim.vim will already have done these settings.
line 2: if v:progname =~? "evim"
line 3:   finish
line 4: endif
line 5: 
line 6: " Use Vim settings, rather than Vi settings (much better!).
line 7: " This must be first, because it changes other options as a side effect.
line 8: set nocompatible
line 9: 
line 10: " allow backspacing over everything in insert mode
line 11: set backspace=indent,eol,start
line 12: 
line 13: if has("vms")
line 14:   set nobackup^I^I" do not keep a backup file, use versions instead
line 15: else
line 16:   set backup^I^I" keep a backup file
line 17: endif
line 18: set history=50^I^I" keep 50 lines of command line history
line 19: set ruler^I^I" show the cursor position all the time
line 20: set showcmd^I^I" display incomplete commands
line 21: set incsearch^I^I" do incremental searching
line 22: 
line 23: " For Win32 GUI: remove 't' flag from 'guioptions': no tearoff menu entries
line 24: " let &guioptions = substitute(&guioptions, "t", "", "g")
line 25: 
line 26: " Don't use Ex mode, use Q for formatting
line 27: map Q gq
line 28: 
line 29: " CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
line 30: " so that you can undo CTRL-U after inserting a line break.
line 31: inoremap <C-U> <C-G>u<C-U>
line 32: 
line 33: " In many terminal emulators the mouse works just fine, thus enable it.
line 34: if has('mouse')
line 35:   set mouse=a
line 36: endif
line 37: 
line 38: " Switch syntax highlighting on, when the terminal has colors
line 39: " Also switch on highlighting the last used search pattern.
line 40: if &t_Co > 2 || has("gui_running")
line 41:   syntax on
line 41: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 41: sourcing "/usr/share/vim/vim74/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 04
line 4: 
line 5: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 15: sourcing "/usr/share/vim/vim74/syntax/nosyntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2006 Apr 16
line 4: 
line 5: " This file is used for ":syntax off".
line 6: " It removes the autocommands and stops highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " Remove all autocommands for the Syntax event.  This also avoids that
line 13: " "syntax=foo" in a modeline triggers the SynSet() function of synload.vim.
line 14: au! Syntax
line 15: 
line 16: " remove all syntax autocommands and remove the syntax for each buffer
line 17: augroup syntaxset
line 18:   au!
line 19:   au BufEnter * syn clear
line 20:   au BufEnter * if exists("b:current_syntax") | unlet b:current_syntax | endif
line 21:   doautoall syntaxset BufEnter *
line 22:   au!
line 23: augroup END
line 24: 
line 25: if exists("syntax_on")
line 26:   unlet syntax_on
line 27: endif
line 28: if exists("syntax_manual")
line 29:   unlet syntax_manual
line 30: endif
finished sourcing /usr/share/vim/vim74/syntax/nosyntax.vim
continuing in /usr/share/vim/vim74/syntax/syntax.vim
line 16: endif
line 17: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFind
Searching for "/home/max/.vim/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/vundle/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/vim-rails/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/L9/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/command-t/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/syntastic/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/vim-golang/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/syntax/synload.vim"
Searching for "/home/max/.vim/bundle/google.vim/syntax/synload.vim"
Searching for "/var/lib/vim/addons/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim74/syntax/synload.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 19: sourcing "/usr/share/vim/vim74/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2012 Sep 25
line 4: 
line 5: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
line 10: if !has("syntax")
line 11:   finish
line 12: endif
line 13: 
line 14: " let others know that syntax has been switched on
line 15: let syntax_on = 1
line 16: 
line 17: " Set the default highlighting colors.  Use a color scheme if specified.
line 18: if exists("colors_name")
line 19:   exe "colors " . colors_name
line 19: colors monokai
Searching for "colors/monokai.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFind
Searching for "/home/max/.vim/colors/monokai.vim"
chdir(/home/max/.vim/colors)
fchdir() to previous dir
line 19: sourcing "/home/max/.vim/colors/monokai.vim"
line 1: " Vim color file
line 2: " Converted from Textmate theme Monokai using Coloration v0.3.2 (http://github.com/sickill/coloration)
line 3: 
line 4: set background=dark
line 5: highlight clear
Searching for "syntax/syncolor.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFin
Searching for "/home/max/.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vundle/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-rails/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/L9/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/command-t/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/syntastic/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-golang/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/google.vim/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 5: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim
continuing in /home/max/.vim/colors/monokai.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vundle/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/L9/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/command-t/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/syntax/syncolor.vim"
line 6: 
line 7: if exists("syntax_on")
line 8:   syntax reset
line 8: runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFin
Searching for "/home/max/.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vundle/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-rails/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/L9/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/command-t/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/syntastic/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-golang/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/google.vim/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 8: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi! link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi! link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi! link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi! link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi! link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi! link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi! link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi! link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi! link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi! link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi! link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi! link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi! link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi! link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi! link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi! link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi! link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi! link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi! link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi! link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi! link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi! link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi! link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi! link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim
continuing in /home/max/.vim/colors/monokai.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vundle/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/L9/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/command-t/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/syntax/syncolor.vim"
line 9: endif
line 10: 
line 11: let g:colors_name = "monokai"
line 12: 
line 13: hi Cursor ctermfg=235 ctermbg=231 cterm=NONE guifg=#272822 guibg=#f8f8f0 gui=NONE
line 14: hi Visual ctermfg=NONE ctermbg=59 cterm=NONE guifg=NONE guibg=#49483e gui=NONE
line 15: hi CursorLine ctermfg=NONE ctermbg=237 cterm=NONE guifg=NONE guibg=#3c3d37 gui=NONE
line 16: hi CursorColumn ctermfg=NONE ctermbg=237 cterm=NONE guifg=NONE guibg=#3c3d37 gui=NONE
line 17: hi ColorColumn ctermfg=NONE ctermbg=237 cterm=NONE guifg=NONE guibg=#3c3d37 gui=NONE
line 18: hi LineNr ctermfg=102 ctermbg=237 cterm=NONE guifg=#90908a guibg=#3c3d37 gui=NONE
line 19: hi VertSplit ctermfg=241 ctermbg=241 cterm=NONE guifg=#64645e guibg=#64645e gui=NONE
line 20: hi MatchParen ctermfg=197 ctermbg=NONE cterm=underline guifg=#f92672 guibg=NONE gui=underline
line 21: hi StatusLine ctermfg=231 ctermbg=241 cterm=bold guifg=#f8f8f2 guibg=#64645e gui=bold
line 22: hi StatusLineNC ctermfg=231 ctermbg=241 cterm=NONE guifg=#f8f8f2 guibg=#64645e gui=NONE
line 23: hi Pmenu ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 24: hi PmenuSel ctermfg=NONE ctermbg=59 cterm=NONE guifg=NONE guibg=#49483e gui=NONE
line 25: hi IncSearch ctermfg=235 ctermbg=186 cterm=NONE guifg=#272822 guibg=#e6db74 gui=NONE
line 26: hi Search ctermfg=NONE ctermbg=NONE cterm=underline guifg=NONE guibg=NONE gui=underline
line 27: hi Directory ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 28: hi Folded ctermfg=242 ctermbg=235 cterm=NONE guifg=#75715e guibg=#272822 gui=NONE
line 29: 
line 30: hi Normal ctermfg=231 ctermbg=235 cterm=NONE guifg=#f8f8f2 guibg=#272822 gui=NONE
line 31: hi Boolean ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 32: hi Character ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 33: hi Comment ctermfg=242 ctermbg=NONE cterm=NONE guifg=#75715e guibg=NONE gui=NONE
line 34: hi Conditional ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 35: hi Constant ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 36: hi Define ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 37: hi DiffAdd ctermfg=231 ctermbg=64 cterm=bold guifg=#f8f8f2 guibg=#46830c gui=bold
line 38: hi DiffDelete ctermfg=88 ctermbg=NONE cterm=NONE guifg=#8b0807 guibg=NONE gui=NONE
line 39: hi DiffChange ctermfg=231 ctermbg=23 cterm=NONE guifg=#f8f8f2 guibg=#243955 gui=NONE
line 40: hi DiffText ctermfg=231 ctermbg=24 cterm=bold guifg=#f8f8f2 guibg=#204a87 gui=bold
line 41: hi ErrorMsg ctermfg=231 ctermbg=197 cterm=NONE guifg=#f8f8f0 guibg=#f92672 gui=NONE
line 42: hi WarningMsg ctermfg=231 ctermbg=197 cterm=NONE guifg=#f8f8f0 guibg=#f92672 gui=NONE
line 43: hi Float ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 44: hi Function ctermfg=148 ctermbg=NONE cterm=NONE guifg=#a6e22e guibg=NONE gui=NONE
line 45: hi Identifier ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 46: hi Keyword ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 47: hi Label ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 48: hi NonText ctermfg=59 ctermbg=236 cterm=NONE guifg=#49483e guibg=#31322c gui=NONE
line 49: hi Number ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 50: hi Operator ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 51: hi PreProc ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 52: hi Special ctermfg=231 ctermbg=NONE cterm=NONE guifg=#f8f8f2 guibg=NONE gui=NONE
line 53: hi SpecialKey ctermfg=59 ctermbg=237 cterm=NONE guifg=#49483e guibg=#3c3d37 gui=NONE
line 54: hi Statement ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 55: hi StorageClass ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 56: hi String ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 57: hi Tag ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 58: hi Title ctermfg=231 ctermbg=NONE cterm=bold guifg=#f8f8f2 guibg=NONE gui=bold
line 59: hi Todo ctermfg=95 ctermbg=NONE cterm=inverse,bold guifg=#75715e guibg=NONE gui=inverse,bold
line 60: hi Type ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 61: hi Underlined ctermfg=NONE ctermbg=NONE cterm=underline guifg=NONE guibg=NONE gui=underline
line 62: hi rubyClass ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 63: hi rubyFunction ctermfg=148 ctermbg=NONE cterm=NONE guifg=#a6e22e guibg=NONE gui=NONE
line 64: hi rubyInterpolationDelimiter ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 65: hi rubySymbol ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 66: hi rubyConstant ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 67: hi rubyStringDelimiter ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 68: hi rubyBlockParameter ctermfg=208 ctermbg=NONE cterm=NONE guifg=#fd971f guibg=NONE gui=italic
line 69: hi rubyInstanceVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 70: hi rubyInclude ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 71: hi rubyGlobalVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 72: hi rubyRegexp ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 73: hi rubyRegexpDelimiter ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 74: hi rubyEscape ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 75: hi rubyControl ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 76: hi rubyClassVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 77: hi rubyOperator ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 78: hi rubyException ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 79: hi rubyPseudoVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 80: hi rubyRailsUserClass ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 81: hi rubyRailsARAssociationMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 82: hi rubyRailsARMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 83: hi rubyRailsRenderMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 84: hi rubyRailsMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 85: hi erubyDelimiter ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 86: hi erubyComment ctermfg=95 ctermbg=NONE cterm=NONE guifg=#75715e guibg=NONE gui=NONE
line 87: hi erubyRailsMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 88: hi htmlTag ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 89: hi htmlEndTag ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 90: hi htmlTagName ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 91: hi htmlArg ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 92: hi htmlSpecialChar ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 93: hi javaScriptFunction ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 94: hi javaScriptRailsFunction ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 95: hi javaScriptBraces ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 96: hi yamlKey ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 97: hi yamlAnchor ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 98: hi yamlAlias ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 99: hi yamlDocumentHeader ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 100: hi cssURL ctermfg=208 ctermbg=NONE cterm=NONE guifg=#fd971f guibg=NONE gui=italic
line 101: hi cssFunctionName ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 102: hi cssColor ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 103: hi cssPseudoClassId ctermfg=148 ctermbg=NONE cterm=NONE guifg=#a6e22e guibg=NONE gui=NONE
line 104: hi cssClassName ctermfg=148 ctermbg=NONE cterm=NONE guifg=#a6e22e guibg=NONE gui=NONE
line 105: hi cssValueLength ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 106: hi cssCommonAttr ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 107: hi cssBraces ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
finished sourcing /home/max/.vim/colors/monokai.vim
continuing in /usr/share/vim/vim74/syntax/synload.vim
line 20: else
line 21:   runtime! syntax/syncolor.vim
line 22: endif
line 23: 
line 24: " Line continuation is used here, remove 'C' from 'cpoptions'
line 25: let s:cpo_save = &cpo
line 26: set cpo&vim
line 27: 
line 28: " First remove all old syntax autocommands.
line 29: au! Syntax
line 30: 
line 31: au Syntax *^I^Icall s:SynSet()
line 32: 
line 33: fun! s:SynSet()
line 61: 
line 62: 
line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL)
line 68: au Syntax c,cpp,cs,idl,php if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 69: 
line 70: 
line 71: " Source the user-specified syntax highlighting file
line 72: if exists("mysyntaxfile") && filereadable(expand(mysyntaxfile))
line 73:   execute "source " . mysyntaxfile
line 74: endif
line 75: 
line 76: " Restore 'cpoptions'
line 77: let &cpo = s:cpo_save
line 78: unlet s:cpo_save
finished sourcing /usr/share/vim/vim74/syntax/synload.vim
continuing in /usr/share/vim/vim74/syntax/syntax.vim
line 20: 
line 21: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
line 24: else
line 25:   filetype on
line 26:   let s:did_ft = 0
line 27: endif
line 28: 
line 29: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected.
line 31: augroup syntaxset
line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
line 33: augroup END
line 34: 
line 35: 
line 36: " Execute the syntax autocommands for the each buffer.
line 37: " If the filetype wasn't detected yet, do that now.
line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 39: " already was set manually (e.g., help buffers).
line 40: doautoall syntaxset FileType
line 41: if !s:did_ft
line 42:   doautoall filetypedetect BufRead
line 43: endif
finished sourcing /usr/share/vim/vim74/syntax/syntax.vim
continuing in /home/max/.vim/plugin/settings/base.vim
line 42:   set hlsearch
line 43: endif
line 44: 
line 45: " Only do this part when compiled with support for autocommands.
line 46: if has("autocmd")
line 47: 
line 48:   " Enable file type detection.
line 49:   " Use the default filetype settings, so that mail gets 'tw' set to 72,
line 50:   " 'cindent' is on in C files, etc.
line 51:   " Also load indent files, to automatically do language-dependent indenting.
line 52:   filetype plugin indent on
Searching for "filetype.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/aft
Searching for "/home/max/.vim/filetype.vim"
Searching for "/home/max/.vim/bundle/vundle/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-rails/filetype.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/filetype.vim"
Searching for "/home/max/.vim/bundle/L9/filetype.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/filetype.vim"
Searching for "/home/max/.vim/bundle/command-t/filetype.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/filetype.vim"
Searching for "/home/max/.vim/bundle/syntastic/filetype.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-golang/filetype.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/filetype.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/filetype.vim"
Searching for "/home/max/.vim/bundle/google.vim/filetype.vim"
Searching for "/var/lib/vim/addons/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim74/filetype.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 52: sourcing "/usr/share/vim/vim74/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2013 Sep 22
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
finished sourcing /usr/share/vim/vim74/filetype.vim
continuing in /home/max/.vim/plugin/settings/base.vim
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/var/lib/vim/addons/after/filetype.vim"
Searching for "/home/max/.vim/after/filetype.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/filetype.vim"
Searching for "/home/max/.vim/bundle/vundle/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/filetype.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/filetype.vim"
Searching for "/home/max/.vim/bundle/L9/after/filetype.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/filetype.vim"
Searching for "/home/max/.vim/bundle/command-t/after/filetype.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/filetype.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/filetype.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/filetype.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/filetype.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/filetype.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/filetype.vim"
Searching for "ftplugin.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/aft
Searching for "/home/max/.vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vundle/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-rails/ftplugin.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/L9/ftplugin.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/ftplugin.vim"
Searching for "/home/max/.vim/bundle/command-t/ftplugin.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/ftplugin.vim"
Searching for "/home/max/.vim/bundle/syntastic/ftplugin.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-golang/ftplugin.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/ftplugin.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/ftplugin.vim"
Searching for "/home/max/.vim/bundle/google.vim/ftplugin.vim"
Searching for "/var/lib/vim/addons/ftplugin.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"
Searching for "/usr/share/vim/vim74/ftplugin.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 52: sourcing "/usr/share/vim/vim74/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
finished sourcing /usr/share/vim/vim74/ftplugin.vim
continuing in /home/max/.vim/plugin/settings/base.vim
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"
Searching for "/var/lib/vim/addons/after/ftplugin.vim"
Searching for "/home/max/.vim/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vundle/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/L9/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/command-t/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/ftplugin.vim"
Searching for "indent.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/after
Searching for "/home/max/.vim/indent.vim"
Searching for "/home/max/.vim/bundle/vundle/indent.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/indent.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/indent.vim"
Searching for "/home/max/.vim/bundle/vim-rails/indent.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/indent.vim"
Searching for "/home/max/.vim/bundle/L9/indent.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/indent.vim"
Searching for "/home/max/.vim/bundle/command-t/indent.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/indent.vim"
Searching for "/home/max/.vim/bundle/syntastic/indent.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/indent.vim"
Searching for "/home/max/.vim/bundle/vim-golang/indent.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/indent.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/indent.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/indent.vim"
Searching for "/home/max/.vim/bundle/google.vim/indent.vim"
Searching for "/var/lib/vim/addons/indent.vim"
Searching for "/usr/share/vim/vimfiles/indent.vim"
Searching for "/usr/share/vim/vim74/indent.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 52: sourcing "/usr/share/vim/vim74/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
line 5: 
line 6: if exists("did_indent_on")
line 7:   finish
finished sourcing /usr/share/vim/vim74/indent.vim
continuing in /home/max/.vim/plugin/settings/base.vim
Searching for "/usr/share/vim/vimfiles/after/indent.vim"
Searching for "/var/lib/vim/addons/after/indent.vim"
Searching for "/home/max/.vim/after/indent.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/indent.vim"
Searching for "/home/max/.vim/bundle/vundle/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/indent.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/indent.vim"
Searching for "/home/max/.vim/bundle/L9/after/indent.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/indent.vim"
Searching for "/home/max/.vim/bundle/command-t/after/indent.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/indent.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/indent.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/indent.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/indent.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/indent.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/indent.vim"
line 53: 
line 54:   " Put these in an autocmd group, so that we can delete them easily.
line 55:   augroup vimrcEx
line 56:   au!
line 57: 
line 58:   " For all text files set 'textwidth' to 78 characters.
line 59:   autocmd FileType text setlocal textwidth=78
line 60: 
line 61:   " When editing a file, always jump to the last known cursor position.
line 62:   " Don't do it when the position is invalid or when inside an event handler
line 63:   " (happens when dropping a file on gvim).
line 64:   " Also don't do it when the mark is in the first line, that is the default
line 65:   " position when opening a file.
line 69:   autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") |   exe "normal! g`\"" | endif
line 70: 
line 71:   augroup END
line 72: 
line 73: else
line 74: 
line 75:   set autoindent^I^I" always set autoindenting on
line 76: 
line 77: endif " has("autocmd")
line 78: 
line 79: " Convenient command to see the difference between the current buffer and the
line 80: " file it was loaded from, thus the changes you made.
line 81: " Only define it when not defined already.
line 82: if !exists(":DiffOrig")
line 84:   command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis | wincmd p | diffthis
line 85: endif
finished sourcing /home/max/.vim/plugin/settings/base.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/c++.vim"
line 1: " c++.vim
line 2: " ~/.vimrc/plugin/settings/c++.vim
line 3: " Sets the c++ file extension for the different filetypes
line 4: 
line 5: au BufRead,BufNewFile *.h setfiletype cpp
line 6: au BufRead,BufNewFile *.cc setfiletype cpp
finished sourcing /home/max/.vim/plugin/settings/c++.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/colors.vim"
line 1: " colors.vim
line 2: " ~/.vim/plugin/settings/colors.vim
line 3: " use this to set default (non file specific) colors
line 4: set t_Co=256
line 5: colorscheme monokai
Searching for "colors/monokai.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFind
Searching for "/home/max/.vim/colors/monokai.vim"
chdir(/home/max/.vim/colors)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/colors/monokai.vim"
line 1: " Vim color file
line 2: " Converted from Textmate theme Monokai using Coloration v0.3.2 (http://github.com/sickill/coloration)
line 3: 
line 4: set background=dark
line 5: highlight clear
Searching for "syntax/syncolor.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFin
Searching for "/home/max/.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vundle/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-rails/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/L9/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/command-t/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/syntastic/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-golang/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/google.vim/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 5: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim
continuing in /home/max/.vim/colors/monokai.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vundle/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/L9/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/command-t/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/syntax/syncolor.vim"
line 6: 
line 7: if exists("syntax_on")
line 8:   syntax reset
line 8: runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFin
Searching for "/home/max/.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vundle/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-rails/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/L9/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/command-t/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/syntastic/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-golang/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/google.vim/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 8: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi! link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi! link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi! link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi! link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi! link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi! link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi! link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi! link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi! link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi! link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi! link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi! link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi! link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi! link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi! link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi! link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi! link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi! link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi! link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi! link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi! link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi! link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi! link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi! link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim
continuing in /home/max/.vim/colors/monokai.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vundle/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/L9/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/command-t/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/syntax/syncolor.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/syntax/syncolor.vim"
line 9: endif
line 10: 
line 11: let g:colors_name = "monokai"
line 12: 
line 13: hi Cursor ctermfg=235 ctermbg=231 cterm=NONE guifg=#272822 guibg=#f8f8f0 gui=NONE
line 14: hi Visual ctermfg=NONE ctermbg=59 cterm=NONE guifg=NONE guibg=#49483e gui=NONE
line 15: hi CursorLine ctermfg=NONE ctermbg=237 cterm=NONE guifg=NONE guibg=#3c3d37 gui=NONE
line 16: hi CursorColumn ctermfg=NONE ctermbg=237 cterm=NONE guifg=NONE guibg=#3c3d37 gui=NONE
line 17: hi ColorColumn ctermfg=NONE ctermbg=237 cterm=NONE guifg=NONE guibg=#3c3d37 gui=NONE
line 18: hi LineNr ctermfg=102 ctermbg=237 cterm=NONE guifg=#90908a guibg=#3c3d37 gui=NONE
line 19: hi VertSplit ctermfg=241 ctermbg=241 cterm=NONE guifg=#64645e guibg=#64645e gui=NONE
line 20: hi MatchParen ctermfg=197 ctermbg=NONE cterm=underline guifg=#f92672 guibg=NONE gui=underline
line 21: hi StatusLine ctermfg=231 ctermbg=241 cterm=bold guifg=#f8f8f2 guibg=#64645e gui=bold
line 22: hi StatusLineNC ctermfg=231 ctermbg=241 cterm=NONE guifg=#f8f8f2 guibg=#64645e gui=NONE
line 23: hi Pmenu ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 24: hi PmenuSel ctermfg=NONE ctermbg=59 cterm=NONE guifg=NONE guibg=#49483e gui=NONE
line 25: hi IncSearch ctermfg=235 ctermbg=186 cterm=NONE guifg=#272822 guibg=#e6db74 gui=NONE
line 26: hi Search ctermfg=NONE ctermbg=NONE cterm=underline guifg=NONE guibg=NONE gui=underline
line 27: hi Directory ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 28: hi Folded ctermfg=242 ctermbg=235 cterm=NONE guifg=#75715e guibg=#272822 gui=NONE
line 29: 
line 30: hi Normal ctermfg=231 ctermbg=235 cterm=NONE guifg=#f8f8f2 guibg=#272822 gui=NONE
line 31: hi Boolean ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 32: hi Character ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 33: hi Comment ctermfg=242 ctermbg=NONE cterm=NONE guifg=#75715e guibg=NONE gui=NONE
line 34: hi Conditional ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 35: hi Constant ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 36: hi Define ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 37: hi DiffAdd ctermfg=231 ctermbg=64 cterm=bold guifg=#f8f8f2 guibg=#46830c gui=bold
line 38: hi DiffDelete ctermfg=88 ctermbg=NONE cterm=NONE guifg=#8b0807 guibg=NONE gui=NONE
line 39: hi DiffChange ctermfg=231 ctermbg=23 cterm=NONE guifg=#f8f8f2 guibg=#243955 gui=NONE
line 40: hi DiffText ctermfg=231 ctermbg=24 cterm=bold guifg=#f8f8f2 guibg=#204a87 gui=bold
line 41: hi ErrorMsg ctermfg=231 ctermbg=197 cterm=NONE guifg=#f8f8f0 guibg=#f92672 gui=NONE
line 42: hi WarningMsg ctermfg=231 ctermbg=197 cterm=NONE guifg=#f8f8f0 guibg=#f92672 gui=NONE
line 43: hi Float ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 44: hi Function ctermfg=148 ctermbg=NONE cterm=NONE guifg=#a6e22e guibg=NONE gui=NONE
line 45: hi Identifier ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 46: hi Keyword ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 47: hi Label ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 48: hi NonText ctermfg=59 ctermbg=236 cterm=NONE guifg=#49483e guibg=#31322c gui=NONE
line 49: hi Number ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 50: hi Operator ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 51: hi PreProc ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 52: hi Special ctermfg=231 ctermbg=NONE cterm=NONE guifg=#f8f8f2 guibg=NONE gui=NONE
line 53: hi SpecialKey ctermfg=59 ctermbg=237 cterm=NONE guifg=#49483e guibg=#3c3d37 gui=NONE
line 54: hi Statement ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 55: hi StorageClass ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 56: hi String ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 57: hi Tag ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 58: hi Title ctermfg=231 ctermbg=NONE cterm=bold guifg=#f8f8f2 guibg=NONE gui=bold
line 59: hi Todo ctermfg=95 ctermbg=NONE cterm=inverse,bold guifg=#75715e guibg=NONE gui=inverse,bold
line 60: hi Type ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 61: hi Underlined ctermfg=NONE ctermbg=NONE cterm=underline guifg=NONE guibg=NONE gui=underline
line 62: hi rubyClass ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 63: hi rubyFunction ctermfg=148 ctermbg=NONE cterm=NONE guifg=#a6e22e guibg=NONE gui=NONE
line 64: hi rubyInterpolationDelimiter ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 65: hi rubySymbol ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 66: hi rubyConstant ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 67: hi rubyStringDelimiter ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 68: hi rubyBlockParameter ctermfg=208 ctermbg=NONE cterm=NONE guifg=#fd971f guibg=NONE gui=italic
line 69: hi rubyInstanceVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 70: hi rubyInclude ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 71: hi rubyGlobalVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 72: hi rubyRegexp ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 73: hi rubyRegexpDelimiter ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 74: hi rubyEscape ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 75: hi rubyControl ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 76: hi rubyClassVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 77: hi rubyOperator ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 78: hi rubyException ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 79: hi rubyPseudoVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 80: hi rubyRailsUserClass ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 81: hi rubyRailsARAssociationMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 82: hi rubyRailsARMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 83: hi rubyRailsRenderMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 84: hi rubyRailsMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 85: hi erubyDelimiter ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 86: hi erubyComment ctermfg=95 ctermbg=NONE cterm=NONE guifg=#75715e guibg=NONE gui=NONE
line 87: hi erubyRailsMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 88: hi htmlTag ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 89: hi htmlEndTag ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 90: hi htmlTagName ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 91: hi htmlArg ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 92: hi htmlSpecialChar ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 93: hi javaScriptFunction ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic
line 94: hi javaScriptRailsFunction ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 95: hi javaScriptBraces ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 96: hi yamlKey ctermfg=197 ctermbg=NONE cterm=NONE guifg=#f92672 guibg=NONE gui=NONE
line 97: hi yamlAnchor ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 98: hi yamlAlias ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
line 99: hi yamlDocumentHeader ctermfg=186 ctermbg=NONE cterm=NONE guifg=#e6db74 guibg=NONE gui=NONE
line 100: hi cssURL ctermfg=208 ctermbg=NONE cterm=NONE guifg=#fd971f guibg=NONE gui=italic
line 101: hi cssFunctionName ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 102: hi cssColor ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 103: hi cssPseudoClassId ctermfg=148 ctermbg=NONE cterm=NONE guifg=#a6e22e guibg=NONE gui=NONE
line 104: hi cssClassName ctermfg=148 ctermbg=NONE cterm=NONE guifg=#a6e22e guibg=NONE gui=NONE
line 105: hi cssValueLength ctermfg=141 ctermbg=NONE cterm=NONE guifg=#ae81ff guibg=NONE gui=NONE
line 106: hi cssCommonAttr ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=NONE
line 107: hi cssBraces ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE
finished sourcing /home/max/.vim/colors/monokai.vim
continuing in /home/max/.vim/plugin/settings/colors.vim
finished sourcing /home/max/.vim/plugin/settings/colors.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/easymotion.vim"
line 1: " easymotion.vim
line 2: " ~/.vim/plugin/settings/easymotion.vim
line 3: " https://github.com/Lokaltog/vim-easymotion
line 4: " use this file to set easymotion settings
line 5: 
line 6: " set leader key
line 7: map <Space> <Plug>(easymotion-prefix)
line 8: let g:EasyMotion_do_mapping = 0 " Disable default mappings
line 9: 
line 10: " Bi-directional find motion
line 11: " Jump to anywhere you want with minimal keystrokes, with just one key
line 12: " binding.
line 13: " s{char}{label}
line 14: " nmap s <Plug>(easymotion-s)
line 15: " nmap t <Plug>(easymotion-t2)
line 16: " s{char}{char}{label}
line 17: " need one more keystroke but on average it may be more comfortable
line 18: " nmap s <Plug>(easymotion-s2)
line 19: 
line 20: " Turn on case sensitive feature
line 21: let g:EasyMotion_smartcase = 1
line 22: 
line 23: " JK motions: line motions
line 24: map <Leader>j <Plug>(easymotion-j)
line 25: map <Leader>k <Plug>(easymotion-k)
finished sourcing /home/max/.vim/plugin/settings/easymotion.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/numbering.vim"
line 1: " numbering.vim
line 2: " ~/.vim/plugin/settings/numbering.vim
line 3: " use this to turn on number and maybe settings later
line 4: set nu
finished sourcing /home/max/.vim/plugin/settings/numbering.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/python.vim"
finished sourcing /home/max/.vim/plugin/settings/python.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/pythondebug.vim"
line 1: map <Leader>d oimport ipdb;ipdb.set_trace()<CR><ESC>
finished sourcing /home/max/.vim/plugin/settings/pythondebug.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/spacing.vim"
line 1: " spacing.vim
line 2: " ~/.vim/plugin/settings/spacing.vim
line 3: " use this to set default non file specific spacing
line 4: " set the tab width
line 5: set ts=2 sts=2 sw=2
line 6: 
line 7: "allow for inserting line break without entering insert
line 8: nmap <S-Enter> O<Esc>
line 9: nmap <CR> o<Esc>
finished sourcing /home/max/.vim/plugin/settings/spacing.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/splits.vim"
line 1: " splits.vim
line 2: " ~/.vim/plugin/settings/splits.vim
line 3: " http://robots.thoughtbot.com/vim-splits-move-faster-and-more-naturally
line 4: " use this to set split settings
line 5: 
line 6: " set natural splitting
line 7: " i.e. split below and split right by default
line 8: set splitbelow
line 9: set splitright
line 10: 
line 11: " set easy split switching
line 12: nnoremap <C-J> <C-W><C-J>
line 13: nnoremap <C-K> <C-W><C-K>
line 14: nnoremap <C-L> <C-W><C-L>
line 15: nnoremap <C-H> <C-W><C-H>
finished sourcing /home/max/.vim/plugin/settings/splits.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/syntastic.vim"
line 1: " syntastic.vim
line 2: " ~/.vim/plugin/settings/syntastic.vim
line 3: " used to set settings for syntastic
line 4: " https://github.com/scrooloose/syntastic
line 5: let g:syntastic_cpp_checkers=['cpplint']
line 6: let g:syntastic_cpp_check_headers=1
line 7: 
line 8: " custom pylintrc file
line 9: let g:syntastic_python_checkers=['pylint']
line 10: let g:syntastic_python_pylint_args='--rcfile=/home/max/.pylintrc'
line 11: let g:syntastic_python_pylint_post_args = '--rcfile=/home/max/.pylintrc'
line 12: " hopefully setting the bottom list thing
line 13: let g:syntastic_always_populate_loc_list = 1
line 14: " this is probably going to do the bottom thing
line 15: let g:syntastic_aggregate_errors = 1
line 16: 
line 17: let g:syntastic_check_on_open=1
line 18: let g:syntastic_enable_signs=1
line 19: 
line 20: " this really give me the thing on the bottom
line 21: let g:syntastic_auto_loc_list=0
line 22: 
line 23: " c++ 11 support
line 24: let g:syntastic_cpp_compiler_options = ' -std=c++11'
line 25: 
finished sourcing /home/max/.vim/plugin/settings/syntastic.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/vimtemp.vim"
line 1: " vimtemp.vim
line 2: " /home/max/plugin/settings/vimtemp.vim
line 3: "
line 4: " Changes the vim temp directory
line 5: 
line 6: set backupdir=//home//max//.vim//vimtemp//
line 7: 
finished sourcing /home/max/.vim/plugin/settings/vimtemp.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/vimundo.vim"
line 1: " vimundo.vim
line 2: " /home/max/.vim/plugin/settings/vimundo.vim
line 3: " turns on persistant undoing
line 4: set undofile " save undo's after closing file
line 5: set undodir=/home/max/.vim/vimundo " where to save to
finished sourcing /home/max/.vim/plugin/settings/vimundo.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/vundle.vim"
line 1: " vundle.vim
line 2: " ~/.vim/plugin/settings/*.vim
line 3: " https://github.com/gmarik/Vundle.vim
line 4: " use this to set settings for Vundle
line 5: " vundle is a plugin manager used to install and update plugins cleanly
line 6: " ignore all settings up to the Plugin point
line 7: set nocompatible              " be iMproved, required
line 8: filetype off                  " required
Searching for "ftoff.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/after,
Searching for "/home/max/.vim/ftoff.vim"
Searching for "/home/max/.vim/bundle/vundle/ftoff.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/ftoff.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/ftoff.vim"
Searching for "/home/max/.vim/bundle/vim-rails/ftoff.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/ftoff.vim"
Searching for "/home/max/.vim/bundle/L9/ftoff.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/ftoff.vim"
Searching for "/home/max/.vim/bundle/command-t/ftoff.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/ftoff.vim"
Searching for "/home/max/.vim/bundle/syntastic/ftoff.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/ftoff.vim"
Searching for "/home/max/.vim/bundle/vim-golang/ftoff.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/ftoff.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/ftoff.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/ftoff.vim"
Searching for "/home/max/.vim/bundle/google.vim/ftoff.vim"
Searching for "/var/lib/vim/addons/ftoff.vim"
Searching for "/usr/share/vim/vimfiles/ftoff.vim"
Searching for "/usr/share/vim/vim74/ftoff.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 8: sourcing "/usr/share/vim/vim74/ftoff.vim"
line 1: " Vim support file to switch off detection of file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2001 Jun 11
line 5: 
line 6: if exists("did_load_filetypes")
line 7:   unlet did_load_filetypes
line 8: endif
line 9: 
line 10: " Remove all autocommands in the filetypedetect group
line 11: silent! au! filetypedetect *
finished sourcing /usr/share/vim/vim74/ftoff.vim
continuing in /home/max/.vim/plugin/settings/vundle.vim
Searching for "/usr/share/vim/vimfiles/after/ftoff.vim"
Searching for "/var/lib/vim/addons/after/ftoff.vim"
Searching for "/home/max/.vim/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/ftoff.vim"
Searching for "/home/max/.vim/bundle/vundle/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/ftoff.vim"
Searching for "/home/max/.vim/bundle/L9/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/command-t/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/ftoff.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/ftoff.vim"
line 9: 
line 10: " set the runtime path to include Vundle and initialize
line 11: set rtp+=/home/max/.vim/bundle/Vundle.vim
line 12: call vundle#begin()
calling function vundle#begin()

line 1:   let g:vundle_lazy_load = 1
line 2:   call call('vundle#rc', a:000)
calling function vundle#begin..vundle#rc()

line 1:   let g:bundle_dir = len(a:000) > 0 ? expand(a:1, 1) : expand('$HOME/.vim/bundle', 1)
line 2:   let g:updated_bundles = []
line 3:   let g:vundle_log = []
line 4:   let g:vundle_changelog = ['Updated Plugins:']
line 5:   call vundle#config#init()
calling function vundle#begin..vundle#rc..vundle#config#init()

line 1:   if !exists('g:bundles') | let g:bundles = [] | endif
line 1:  let g:bundles = [] | endif
line 1:  endif
line 2:   call s:rtp_rm_a()
calling function vundle#begin..vundle#rc..vundle#config#init..<SNR>29_rtp_rm_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp-='.fnameescape(prepends)
line 4: set rtp-=/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim
line 5:   exec 'set rtp-='.fnameescape(appends)
line 5: set rtp-=/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/after,/home/max/.vim/bundle/command-t/after,/home/max/.vim/bundle/YouCompleteMe/after,/home/max/.vim/bundle/syntastic/after,/home/max/.vim/bundle/ctrlp.vim/after,/home/max/.vim/bundle/vim-golang/after,/home/max/.vim/bundle/scss-syntax.vim/after,/home/max/.vim/bundle/vim-coffee-script/after,/home/max/.vim/bundle/LaTeX-Box/after,/home/max/.vim/bundle/google.vim/after
function vundle#begin..vundle#rc..vundle#config#init..<SNR>29_rtp_rm_a returning #0

continuing in function vundle#begin..vundle#rc..vundle#config#init

line 3:   let g:bundles = []
line 4:   let g:bundle_names = {}
function vundle#begin..vundle#rc..vundle#config#init returning #0

continuing in function vundle#begin..vundle#rc

function vundle#begin..vundle#rc returning #0

continuing in function vundle#begin

function vundle#begin returning #0

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 13: " alternatively, pass a path where Vundle should install plugins
line 14: "let path = '~/some/path/here'
line 15: "call vundle#rc(path)
line 16: 
line 17: 
line 18: 
line 19: " settings start here
line 20: " let Vundle manage Vundle, required
line 21: Plugin 'gmarik/vundle'
line 21: call vundle#config#bundle('gmarik/vundle')
calling function vundle#config#bundle('gmarik/vundle')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('gmarik/vundle', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('gmarik/vundle')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/gmarik/vu... 'vundle', 'name_spec': 'gmarik/vundle'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/gmarik/vu... 'gmarik/vundle', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/vundle')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/vundle'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/vundle'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/vundle'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/gmarik/vu... 'gmarik/vundle', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/gmarik/vu... 'gmarik/vundle', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/gmarik/vu... 'gmarik/vundle', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 22: " The following are examples of different formats supported.
line 23: " Keep Plugin commands between here and filetype plugin indent on.
line 24: " scripts on GitHub repos
line 25: Plugin 'tpope/vim-fugitive'
line 25: call vundle#config#bundle('tpope/vim-fugitive')
calling function vundle#config#bundle('tpope/vim-fugitive')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('tpope/vim-fugitive', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('tpope/vim-fugitive')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/tpope/vim...ive', 'name_spec': 'tpope/vim-fugitive'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/tpope/vim...pe/vim-fugitive', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/vim-fugitive')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/vim-fugitive'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/vim-fugitive'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/vim-fugitive'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/tpope/vim...pe/vim-fugitive', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/tpope/vim...pe/vim-fugitive', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/tpope/vim...pe/vim-fugitive', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 26: Plugin 'Lokaltog/vim-easymotion'
line 26: call vundle#config#bundle('Lokaltog/vim-easymotion')
calling function vundle#config#bundle('Lokaltog/vim-easymotion')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('Lokaltog/vim-easymotion', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('Lokaltog/vim-easymotion')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/Lokaltog/... 'name_spec': 'Lokaltog/vim-easymotion'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/Lokaltog/.../vim-easymotion', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/vim-easymotion')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/vim-easymotion'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/vim-easymotion'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/vim-easymotion'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/Lokaltog/.../vim-easymotion', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/Lokaltog/.../vim-easymotion', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/Lokaltog/.../vim-easymotion', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 27: Plugin 'tpope/vim-rails.git'
line 27: call vundle#config#bundle('tpope/vim-rails.git')
calling function vundle#config#bundle('tpope/vim-rails.git')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('tpope/vim-rails.git', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('tpope/vim-rails.git')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/tpope/vim...ls', 'name_spec': 'tpope/vim-rails.git'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/tpope/vim...e/vim-rails.git', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/vim-rails')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/vim-rails'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/vim-rails'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/vim-rails'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/tpope/vim...e/vim-rails.git', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/tpope/vim...e/vim-rails.git', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/tpope/vim...e/vim-rails.git', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 28: " The sparkup vim script is in a subdirectory of this repo called vim.
line 29: " Pass the path to set the runtimepath properly.
line 30: Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}
line 30: call vundle#config#bundle('rstacruz/sparkup', {'rtp': 'vim/'})
calling function vundle#config#bundle('rstacruz/sparkup', {'rtp': 'vim/'})

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('rstacruz/sparkup', [{'rtp': 'vim/'}])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([{'rtp': 'vim/'}])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
line 2:  endif
line 3: 
line 4:   if type(a:opts[0]) == type({})
line 5:     return a:opts[0]
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {'rtp': 'vim/'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('rstacruz/sparkup')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/rstacruz/...arkup', 'name_spec': 'rstacruz/sparkup'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/rstacruz/...stacruz/sparkup', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/sparkup')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/sparkup'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/sparkup'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..<SNR>29_expand_path('/home/max/.vim/bundle/sparkup/vim/')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..<SNR>29_expand_path returning '/home/max/.vim/bundle/sparkup/vim/'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/sparkup/vim/'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/rstacruz/...stacruz/sparkup', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/rstacruz/...stacruz/sparkup', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/rstacruz/...stacruz/sparkup', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 31: " scripts from http://vim-scripts.org/vim/scripts.html
line 32: Plugin 'L9'
line 32: call vundle#config#bundle('L9')
calling function vundle#config#bundle('L9')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('L9', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('L9')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/vim-scrip...9.git', 'name': 'L9', 'name_spec': 'L9'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/vim-scrip...name_spec': 'L9', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/L9')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/L9'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/L9'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/L9'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/vim-scrip...name_spec': 'L9', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/vim-scrip...name_spec': 'L9', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/vim-scrip...name_spec': 'L9', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 33: Plugin 'FuzzyFinder'
line 33: call vundle#config#bundle('FuzzyFinder')
calling function vundle#config#bundle('FuzzyFinder')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('FuzzyFinder', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('FuzzyFinder')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/vim-scrip...uzzyFinder', 'name_spec': 'FuzzyFinder'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/vim-scrip...': 'FuzzyFinder', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/FuzzyFinder')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/FuzzyFinder'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/FuzzyFinder'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/FuzzyFinder'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/vim-scrip...': 'FuzzyFinder', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/vim-scrip...': 'FuzzyFinder', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/vim-scrip...': 'FuzzyFinder', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 34: " scripts not on GitHub
line 35: Plugin 'git://git.wincent.com/command-t.git'
line 35: call vundle#config#bundle('git://git.wincent.com/command-t.git')
calling function vundle#config#bundle('git://git.wincent.com/command-t.git')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('git://git.wincent.com/command-t.git', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('git://git.wincent.com/command-t.git')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'git://git.wincent.com/comman...: 'git://git.wincent.com/command-t.git'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'git://git.wincent.com/comman...m/command-t.git', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/command-t')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/command-t'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/command-t'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/command-t'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'git://git.wincent.com/comman...m/command-t.git', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'git://git.wincent.com/comman...m/command-t.git', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'git://git.wincent.com/comman...m/command-t.git', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 36: " git repos on your local machine (i.e. when working on your own plugin)
line 37: " Plugin 'file:///home/gmarik/path/to/plugin'
line 38: " ...
line 39: 
line 40: " these are the ones I installed
line 41: " fuzzy autocomplete like in sublime
line 42: Plugin 'Valloric/YouCompleteMe'
line 42: call vundle#config#bundle('Valloric/YouCompleteMe')
calling function vundle#config#bundle('Valloric/YouCompleteMe')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('Valloric/YouCompleteMe', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('Valloric/YouCompleteMe')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/Valloric/..., 'name_spec': 'Valloric/YouCompleteMe'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/Valloric/...c/YouCompleteMe', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/YouCompleteMe')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/YouCompleteMe'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/YouCompleteMe'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/YouCompleteMe'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/Valloric/...c/YouCompleteMe', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/Valloric/...c/YouCompleteMe', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/Valloric/...c/YouCompleteMe', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 43: Plugin 'scrooloose/syntastic.git'
line 43: call vundle#config#bundle('scrooloose/syntastic.git')
calling function vundle#config#bundle('scrooloose/syntastic.git')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('scrooloose/syntastic.git', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('scrooloose/syntastic.git')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/scrooloos...'name_spec': 'scrooloose/syntastic.git'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/scrooloos...e/syntastic.git', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/syntastic')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/syntastic'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/syntastic'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/syntastic'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/scrooloos...e/syntastic.git', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/scrooloos...e/syntastic.git', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/scrooloos...e/syntastic.git', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 44: 
line 45: " finds files in git repo
line 46: Plugin 'kien/ctrlp.vim'
line 46: call vundle#config#bundle('kien/ctrlp.vim')
calling function vundle#config#bundle('kien/ctrlp.vim')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('kien/ctrlp.vim', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('kien/ctrlp.vim')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/kien/ctrl...rlp.vim', 'name_spec': 'kien/ctrlp.vim'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/kien/ctrl...'kien/ctrlp.vim', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/ctrlp.vim')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/ctrlp.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/ctrlp.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/ctrlp.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/kien/ctrl...'kien/ctrlp.vim', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/kien/ctrl...'kien/ctrlp.vim', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/kien/ctrl...'kien/ctrlp.vim', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 47: 
line 48: " All the go lang stuff you could need
line 49: Plugin 'jnwhiteh/vim-golang'
line 49: call vundle#config#bundle('jnwhiteh/vim-golang')
calling function vundle#config#bundle('jnwhiteh/vim-golang')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('jnwhiteh/vim-golang', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('jnwhiteh/vim-golang')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/jnwhiteh/...ng', 'name_spec': 'jnwhiteh/vim-golang'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/jnwhiteh/...iteh/vim-golang', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/vim-golang')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/vim-golang'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/vim-golang'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/vim-golang'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/jnwhiteh/...iteh/vim-golang', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/jnwhiteh/...iteh/vim-golang', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/jnwhiteh/...iteh/vim-golang', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 50: 
line 51: " sass stuff
line 52: Plugin 'cakebaker/scss-syntax.vim'
line 52: call vundle#config#bundle('cakebaker/scss-syntax.vim')
calling function vundle#config#bundle('cakebaker/scss-syntax.vim')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('cakebaker/scss-syntax.vim', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('cakebaker/scss-syntax.vim')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/cakebaker...name_spec': 'cakebaker/scss-syntax.vim'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/cakebaker...scss-syntax.vim', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/scss-syntax.vim')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/scss-syntax.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/scss-syntax.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/scss-syntax.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/cakebaker...scss-syntax.vim', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/cakebaker...scss-syntax.vim', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/cakebaker...scss-syntax.vim', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 53: 
line 54: " coffee
line 55: Plugin 'kchmck/vim-coffee-script'
line 55: call vundle#config#bundle('kchmck/vim-coffee-script')
calling function vundle#config#bundle('kchmck/vim-coffee-script')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('kchmck/vim-coffee-script', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('kchmck/vim-coffee-script')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/kchmck/vi...'name_spec': 'kchmck/vim-coffee-script'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/kchmck/vi...m-coffee-script', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/vim-coffee-script')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/vim-coffee-script'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/vim-coffee-script'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/vim-coffee-script'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/kchmck/vi...m-coffee-script', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/kchmck/vi...m-coffee-script', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/kchmck/vi...m-coffee-script', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 56: 
line 57: " latex
line 58: Plugin 'LaTeX-Box-Team/LaTeX-Box'
line 58: call vundle#config#bundle('LaTeX-Box-Team/LaTeX-Box')
calling function vundle#config#bundle('LaTeX-Box-Team/LaTeX-Box')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('LaTeX-Box-Team/LaTeX-Box', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('LaTeX-Box-Team/LaTeX-Box')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/LaTeX-Box...'name_spec': 'LaTeX-Box-Team/LaTeX-Box'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/LaTeX-Box...-Team/LaTeX-Box', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/LaTeX-Box')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/LaTeX-Box'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/LaTeX-Box'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/LaTeX-Box'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/LaTeX-Box...-Team/LaTeX-Box', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/LaTeX-Box...-Team/LaTeX-Box', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/LaTeX-Box...-Team/LaTeX-Box', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 59: 
line 60: " C++
line 61: Plugin 'vim-scripts/google.vim'
line 61: call vundle#config#bundle('vim-scripts/google.vim')
calling function vundle#config#bundle('vim-scripts/google.vim')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)
calling function vundle#config#bundle..vundle#config#init_bundle('vim-scripts/google.vim', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')
line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"
line 3:   endif
line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options([])

line 1:   " TODO: improve this
line 2:   if len(a:opts) != 1 | return {} | endif
line 2:  return {} | endif
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_options returning {}

continuing in function vundle#config#bundle..vundle#config#init_bundle

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name('vim-scripts/google.vim')

line 1:   let arg = a:arg
line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'
line 3: 
line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'
line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1]
line 7:     if uri !~? '\.git$'
line 8:       let uri .= '.git'
line 9:     endif
line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')
line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'
line 14:     let uri = arg
line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1]
line 16:   else
line 17:     let name = arg
line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'
line 19:   endif
line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_parse_name returning {'uri': 'https://github.com/vim-scrip..., 'name_spec': 'vim-scripts/google.vim'}

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 5:   let b = extend(opts, copy(s:bundle))
line 6:   let b.rtpath = s:rtpath(opts)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath({'uri': 'https://github.com/vim-scrip...ipts/google.vim', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)
calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path('/home/max/.vim/bundle/google.vim')

line 1:   return simplify(expand(a:path, 1))
function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1..<SNR>29_expand_path returning '/home/max/.vim/bundle/google.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath..1 returning '/home/max/.vim/bundle/google.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath

function vundle#config#bundle..vundle#config#init_bundle..<SNR>29_rtpath returning '/home/max/.vim/bundle/google.vim'

continuing in function vundle#config#bundle..vundle#config#init_bundle

line 7:   return b
function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/vim-scrip...ipts/google.vim', 'path': function('1')}

continuing in function vundle#config#bundle

line 2:   if !s:check_bundle_name(bundle)
calling function vundle#config#bundle..<SNR>29_check_bundle_name({'uri': 'https://github.com/vim-scrip...ipts/google.vim', 'path': function('1')})

line 1:   if has_key(g:bundle_names, a:bundle.name)
line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . g:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'
line 6:     return 0
line 7:   endif
line 8:   let g:bundle_names[a:bundle.name] = a:bundle.name_spec
line 9:   return 1
function vundle#config#bundle..<SNR>29_check_bundle_name returning #1

continuing in function vundle#config#bundle

line 3:     return
line 4:   endif
line 5:   if exists('g:vundle_lazy_load') && g:vundle_lazy_load
line 6:     call add(g:bundles, bundle)
line 7:   else
line 8:     call s:rtp_rm_a()
line 9:     call add(g:bundles, bundle)
line 10:     call s:rtp_add_a()
line 11:     call s:rtp_add_defaults()
line 12:   endif
line 13:   return bundle
function vundle#config#bundle returning {'uri': 'https://github.com/vim-scrip...ipts/google.vim', 'path': function('1')}

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 62: 
line 63: call vundle#end()
calling function vundle#end()

line 1:   unlet g:vundle_lazy_load
line 2:   call vundle#config#activate_bundles()
calling function vundle#end..vundle#config#activate_bundles()

line 1:   call s:rtp_add_a()
calling function vundle#end..vundle#config#activate_bundles..<SNR>29_rtp_add_a()

line 1:   let paths = map(copy(g:bundles), 'v:val.rtpath')
line 2:   let prepends = join(paths, ',')
line 3:   let appends = join(paths, '/after,').'/after'
line 4:   exec 'set rtp^='.fnameescape(prepends)
line 4: set rtp^=/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim
line 5:   exec 'set rtp+='.fnameescape(appends)
line 5: set rtp+=/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/after,/home/max/.vim/bundle/command-t/after,/home/max/.vim/bundle/YouCompleteMe/after,/home/max/.vim/bundle/syntastic/after,/home/max/.vim/bundle/ctrlp.vim/after,/home/max/.vim/bundle/vim-golang/after,/home/max/.vim/bundle/scss-syntax.vim/after,/home/max/.vim/bundle/vim-coffee-script/after,/home/max/.vim/bundle/LaTeX-Box/after,/home/max/.vim/bundle/google.vim/after
function vundle#end..vundle#config#activate_bundles..<SNR>29_rtp_add_a returning #0

continuing in function vundle#end..vundle#config#activate_bundles

line 2:   call s:rtp_add_defaults()
calling function vundle#end..vundle#config#activate_bundles..<SNR>29_rtp_add_defaults()

line 1:   let current = &rtp
line 2:   set rtp&vim
line 3:   let default = &rtp
line 4:   let &rtp = current
line 5:   let default_rtp_items = split(default, ',')
line 6:   if !empty(default_rtp_items)
line 7:     let first_item = fnameescape(default_rtp_items[0])
line 8:     exec 'set rtp-=' . first_item
line 8: set rtp-=/home/max/.vim
line 9:     exec 'set rtp^=' . first_item
line 9: set rtp^=/home/max/.vim
line 10:   endif
function vundle#end..vundle#config#activate_bundles..<SNR>29_rtp_add_defaults returning #0

continuing in function vundle#end..vundle#config#activate_bundles

function vundle#end..vundle#config#activate_bundles returning #0

continuing in function vundle#end

function vundle#end returning #0

continuing in /home/max/.vim/plugin/settings/vundle.vim

line 64: filetype plugin indent on     " required
Searching for "filetype.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/aft
Searching for "/home/max/.vim/filetype.vim"
Searching for "/home/max/.vim/bundle/vundle/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-rails/filetype.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/filetype.vim"
Searching for "/home/max/.vim/bundle/L9/filetype.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/filetype.vim"
Searching for "/home/max/.vim/bundle/command-t/filetype.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/filetype.vim"
Searching for "/home/max/.vim/bundle/syntastic/filetype.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-golang/filetype.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/filetype.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/filetype.vim"
Searching for "/home/max/.vim/bundle/google.vim/filetype.vim"
Searching for "/var/lib/vim/addons/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim74/filetype.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 64: sourcing "/usr/share/vim/vim74/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2013 Sep 22
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
line 9: endif
line 10: let did_load_filetypes = 1
line 11: 
line 12: " Line continuation is used here, remove 'C' from 'cpoptions'
line 13: let s:cpo_save = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup filetypedetect
line 17: 
line 18: " Ignored extensions
line 19: if exists("*fnameescape")
line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 33: elseif &verbose > 0
line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 35: endif
line 36: 
line 37: " Pattern used to match file names which should not be inspected.
line 38: " Currently finds compressed files.
line 39: if !exists("g:ft_ignore_pat")
line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 41: endif
line 42: 
line 43: " Function used for patterns that end in a star: don't set the filetype if the
line 44: " file name matches ft_ignore_pat.
line 45: func! s:StarSetf(ft)
line 50: 
line 51: " Abaqus or Trasys
line 52: au BufNewFile,BufRead *.inp^I^I^Icall s:Check_inp()
line 53: 
line 54: func! s:Check_inp()
line 73: 
line 74: " A-A-P recipe
line 75: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 76: 
line 77: " A2ps printing utility
line 78: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 79: 
line 80: " ABAB/4
line 81: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 82: 
line 83: " ABC music notation
line 84: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 85: 
line 86: " ABEL
line 87: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 88: 
line 89: " AceDB
line 90: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 91: 
line 92: " Ada (83, 9X, 95)
line 93: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 94: if has("vms")
line 95:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 96: else
line 97:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 98: endif
line 99: 
line 100: " AHDL
line 101: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 102: 
line 103: " AMPL
line 104: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 105: 
line 106: " Ant
line 107: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 108: 
line 109: " Apache style config file
line 110: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')
line 111: 
line 112: " Apache config file
line 113: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 114: 
line 115: " XA65 MOS6510 cross assembler
line 116: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 117: 
line 118: " Applescript
line 119: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 120: 
line 121: " Applix ELF
line 123: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
line 124: 
line 125: " ALSA configuration
line 126: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 127: 
line 128: " Arc Macro Language
line 129: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 130: 
line 131: " APT config file
line 132: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 133: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 134: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
line 135: 
line 136: " Arch Inventory file
line 137: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 138: 
line 139: " ART*Enterprise (formerly ART-IM)
line 140: au BufNewFile,BufRead *.art^I^I^Isetf art
line 141: 
line 142: " AsciiDoc
line 143: au BufNewFile,BufRead *.asciidoc^I^Isetf asciidoc
line 144: 
line 145: " ASN.1
line 146: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 147: 
line 148: " Active Server Pages (with Visual Basic Script)
line 154: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 155: 
line 156: " Active Server Pages (with Perl or Visual Basic Script)
line 164: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 165: 
line 166: " Grub (must be before catch *.lst)
line 167: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 168: 
line 169: " Assembly (all kinds)
line 170: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 171: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall s:FTasm()
line 172: 
line 173: " This function checks for the kind of assembly that is wanted by the user, or
line 174: " can be detected from the first five lines of the file.
line 175: func! s:FTasm()
line 196: 
line 197: func! s:FTasmsyntax()
line 209: 
line 210: " Macro (VAX)
line 211: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 212: 
line 213: " Atlas
line 214: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 215: 
line 216: " Autoit v3
line 217: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 218: 
line 219: " Autohotkey
line 220: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 221: 
line 222: " Automake
line 223: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 224: 
line 225: " Autotest .at files are actually m4
line 226: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 227: 
line 228: " Avenue
line 229: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 230: 
line 231: " Awk
line 232: au BufNewFile,BufRead *.awk^I^I^Isetf awk
line 233: 
line 234: " B
line 235: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 236: 
line 237: " BASIC or Visual Basic
line 238: au BufNewFile,BufRead *.bas^I^I^Icall s:FTVB("basic")
line 239: 
line 240: " Check if one of the first five lines contains "VB_Name".  In that case it is
line 241: " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
line 242: func! s:FTVB(alt)
line 249: 
line 250: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
line 251: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb
line 252: 
line 253: " IBasic file (similar to QBasic)
line 254: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 255: 
line 256: " FreeBasic file (similar to QBasic)
line 257: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic
line 258: 
line 259: " Batch file for MSDOS.
line 260: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch
line 261: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
line 263: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
line 264: 
line 265: " Batch file for 4DOS
line 266: au BufNewFile,BufRead *.btm^I^I^Icall s:FTbtm()
line 267: func! s:FTbtm()
line 274: 
line 275: " BC calculator
line 276: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 277: 
line 278: " BDF font
line 279: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 280: 
line 281: " BibTeX bibliography database file
line 282: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 283: 
line 284: " BibTeX Bibliography Style
line 285: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 286: 
line 287: " BIND configuration
line 288: au BufNewFile,BufRead named.conf,rndc.conf^Isetf named
line 289: 
line 290: " BIND zone
line 291: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 292: au BufNewFile,BufRead *.db^I^I^Icall s:BindzoneCheck('')
line 293: 
line 294: func! s:BindzoneCheck(default)
line 301: 
line 302: " Blank
line 303: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 304: 
line 305: " Blkid cache file
line 306: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 307: 
line 308: " C or lpc
line 309: au BufNewFile,BufRead *.c^I^I^Icall s:FTlpc()
line 310: 
line 311: func! s:FTlpc()
line 324: 
line 325: " Calendar
line 326: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 327: 
line 328: " C#
line 329: au BufNewFile,BufRead *.cs^I^I^Isetf cs
line 330: 
line 331: " CSDL
line 332: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 333: 
line 334: " Cabal
line 335: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 336: 
line 337: " Cdrdao TOC
line 338: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
line 339: 
line 340: " Cdrdao config
line 341: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 342: 
line 343: " Cfengine
line 344: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 345: 
line 346: " ChaiScript
line 347: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 348: 
line 349: " Comshare Dimension Definition Language
line 350: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 351: 
line 352: " Conary Recipe
line 353: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 354: 
line 355: " Controllable Regex Mutilator
line 356: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 357: 
line 358: " Cyn++
line 359: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 360: 
line 361: " Cynlib
line 362: " .cc and .cpp files can be C++ or Cynlib.
line 364: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 366: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 367: 
line 368: " C++
line 369: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 370: if has("fname_case")
line 371:   au BufNewFile,BufRead *.C,*.H setf cpp
line 372: endif
line 373: 
line 374: " .h files can be C, Ch C++, ObjC or ObjC++.
line 375: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 376: " detected automatically.
line 377: au BufNewFile,BufRead *.h^I^I^Icall s:FTheader()
line 378: 
line 379: func! s:FTheader()
line 394: 
line 395: " Ch (CHscript)
line 396: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 397: 
line 398: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 399: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 400: 
line 401: " Cascading Style Sheets
line 402: au BufNewFile,BufRead *.css^I^I^Isetf css
line 403: 
line 404: " Century Term Command Scripts (*.cmd too)
line 405: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 406: 
line 407: " Changelog
line 409: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog
line 410: 
line 416: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 417: 
line 421: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 422: 
line 423: " CHILL
line 424: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 425: 
line 426: " Changes for WEB and CWEB or CHILL
line 427: au BufNewFile,BufRead *.ch^I^I^Icall s:FTchange()
line 428: 
line 429: " This function checks if one of the first ten lines start with a '@'.  In
line 430: " that case it is probably a change file.
line 431: " If the first line starts with # or ! it's probably a ch file.
line 432: " If a line has "main", "include", "//" ir "/*" it's probably ch.
line 433: " Otherwise CHILL is assumed.
line 434: func! s:FTchange()
line 457: 
line 458: " ChordPro
line 459: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 460: 
line 461: " Clean
line 462: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 463: 
line 464: " Clever
line 465: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 466: 
line 467: " Clever or dtd
line 468: au BufNewFile,BufRead *.ent^I^I^Icall s:FTent()
line 469: 
line 470: func! s:FTent()
line 489: 
line 490: " Clipper (or FoxPro; could also be eviews)
line 496: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif
line 497: 
line 498: " Clojure
line 499: au BufNewFile,BufRead *.clj,*.cljs^I^Isetf clojure
line 500: 
line 501: " Cmake
line 502: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 503: 
line 504: " Cmusrc
line 505: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 506: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 507: 
line 508: " Cobol
line 509: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
line 510: "   cobol or zope form controller python script? (heuristic)
line 516: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 517: 
line 518: " Coco/R
line 519: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 520: 
line 521: " Cold Fusion
line 522: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 523: 
line 524: " Configure scripts
line 525: au BufNewFile,BufRead configure.in,configure.ac setf config
line 526: 
line 527: " CUDA  Cumpute Unified Device Architecture
line 528: au BufNewFile,BufRead *.cu^I^I^Isetf cuda
line 529: 
line 530: " WildPackets EtherPeek Decoder
line 531: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 532: 
line 533: " Enlightenment configuration files
line 534: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 535: 
line 536: " Eterm
line 537: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 538: 
line 539: " Lynx config files
line 540: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 541: 
line 542: " Quake
line 543: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 544: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 545: 
line 546: " Quake C
line 547: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 548: 
line 549: " Configure files
line 550: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg
line 551: 
line 552: " Cucumber
line 553: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 554: 
line 555: " Communicating Sequential Processes
line 556: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 557: 
line 558: " CUPL logic description and simulation
line 559: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 560: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 561: 
line 562: " Debian Control
line 563: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
line 567: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
line 568: 
line 569: " Debian Sources.list
line 570: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 571: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 572: 
line 573: " Deny hosts
line 574: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 575: 
line 576: " dnsmasq(8) configuration files
line 577: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 578: 
line 579: " ROCKLinux package description
line 580: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 581: 
line 582: " the D language or dtrace
line 583: au BufNewFile,BufRead *.d^I^I^Icall s:DtraceCheck()
line 584: 
line 585: func! s:DtraceCheck()
line 596: 
line 597: " Desktop files
line 598: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop
line 599: 
line 600: " Dict config
line 601: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 602: 
line 603: " Dictd config
line 604: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf
line 605: 
line 606: " Diff files
line 607: au BufNewFile,BufRead *.diff,*.rej,*.patch^Isetf diff
line 608: 
line 609: " Dircolors
line 610: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 611: 
line 612: " Diva (with Skill) or InstallShield
line 618: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 619: 
line 620: " DCL (Digital Command Language - vms) or DNS zone file
line 621: au BufNewFile,BufRead *.com^I^I^Icall s:BindzoneCheck('dcl')
line 622: 
line 623: " DOT
line 624: au BufNewFile,BufRead *.dot^I^I^Isetf dot
line 625: 
line 626: " Dylan - lid files
line 627: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 628: 
line 629: " Dylan - intr files (melange)
line 630: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 631: 
line 632: " Dylan
line 633: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 634: 
line 635: " Microsoft Module Definition
line 636: au BufNewFile,BufRead *.def^I^I^Isetf def
line 637: 
line 638: " Dracula
line 639: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
line 640: 
line 641: " Datascript
line 642: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 643: 
line 644: " dsl
line 645: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl
line 646: 
line 647: " DTD (Document Type Definition for XML)
line 648: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 649: 
line 650: " DTS/DSTI (device tree files)
line 651: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
line 652: 
line 653: " EDIF (*.edf,*.edif,*.edn,*.edo)
line 654: au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)^Isetf edif
line 655: 
line 656: " Embedix Component Description
line 657: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 658: 
line 659: " Eiffel or Specman
line 660: au BufNewFile,BufRead *.e,*.E^I^I^Icall s:FTe()
line 661: 
line 662: " Elinks configuration
line 663: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks
line 664: 
line 665: func! s:FTe()
line 676: 
line 677: " ERicsson LANGuage; Yaws is erlang too
line 678: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 679: 
line 680: " Elm Filter Rules file
line 681: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 682: 
line 683: " ESMTP rc file
line 684: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 685: 
line 686: " ESQL-C
line 687: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 688: 
line 689: " Esterel
line 690: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 691: 
line 692: " Essbase script
line 693: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 694: 
line 695: " Exim
line 696: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 697: 
line 698: " Expect
line 699: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 700: 
line 701: " Exports
line 702: au BufNewFile,BufRead exports^I^I^Isetf exports
line 703: 
line 704: " Falcon
line 705: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 706: 
line 707: " Fantom
line 708: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 709: 
line 710: " Factor
line 711: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 712: 
line 713: " Fetchmail RC file
line 714: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 715: 
line 716: " FlexWiki - disabled, because it has side effects when a .wiki file
line 717: " is not actually FlexWiki
line 718: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
line 719: 
line 720: " Focus Executable
line 721: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 722: 
line 723: " Focus Master file (but not for auto.master)
line 724: au BufNewFile,BufRead auto.master^I^Isetf conf
line 725: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 726: 
line 727: " Forth
line 728: au BufNewFile,BufRead *.fs,*.ft^I^I^Isetf forth
line 729: 
line 730: " Reva Forth
line 731: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 732: 
line 733: " Fortran
line 734: if has("fname_case")
line 735:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran
line 736: endif
line 737: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
line 738: 
line 739: " Framescript
line 740: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 741: 
line 742: " FStab
line 743: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 744: 
line 745: " GDB command files
line 746: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb
line 747: 
line 748: " GDMO
line 749: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 750: 
line 751: " Gedcom
line 752: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 753: 
line 754: " Git
line 755: au BufNewFile,BufRead *.git/COMMIT_EDITMSG^Isetf gitcommit
line 756: au BufNewFile,BufRead *.git/MERGE_MSG^I^Isetf gitcommit
line 757: au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
line 758: au BufNewFile,BufRead *.git/modules/*/COMMIT_EDITMSG setf gitcommit
line 759: au BufNewFile,BufRead *.git/modules/*/config^Isetf gitconfig
line 760: au BufNewFile,BufRead */.config/git/config^Isetf gitconfig
line 761: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase
line 765: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif
line 769: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif
line 770: 
line 771: " Gkrellmrc
line 772: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 773: 
line 774: " GP scripts (2.0 and onward)
line 775: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 776: 
line 777: " GPG
line 778: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 779: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 780: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 781: 
line 782: " gnash(1) configuration files
line 783: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 784: 
line 785: " Gitolite
line 786: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 787: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 788: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 789: 
line 790: " Gnuplot scripts
line 791: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot
line 792: 
line 793: " GrADS scripts
line 794: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 795: 
line 796: " Gretl
line 797: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 798: 
line 799: " Groovy
line 800: au BufNewFile,BufRead *.groovy^I^I^Isetf groovy
line 801: 
line 802: " GNU Server Pages
line 803: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 804: 
line 805: " Group file
line 806: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 807: 
line 808: " GTK RC
line 809: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 810: 
line 811: " Haml
line 812: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 813: 
line 814: " Hamster Classic | Playground files
line 815: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster
line 816: 
line 817: " Haskell
line 818: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell
line 819: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 820: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 821: 
line 822: " Haste
line 823: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 824: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 825: 
line 826: " Hercules
line 827: au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum^Isetf hercules
line 828: 
line 829: " HEX (Intel)
line 830: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
line 831: 
line 832: " Tilde (must be before HTML)
line 833: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 834: 
line 835: " HTML (.shtml and .stm for server side)
line 836: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
line 837: 
line 838: " Distinguish between HTML, XHTML and Django
line 839: func! s:FThtml()
line 854: 
line 855: " HTML with Ruby - eRuby
line 856: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 857: 
line 858: " HTML with M4
line 859: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 860: 
line 861: " HTML Cheetah template
line 862: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah
line 863: 
line 864: " Host config
line 865: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 866: 
line 867: " Hosts access
line 868: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 869: 
line 870: " Hyper Builder
line 871: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 872: 
line 873: " Httest
line 874: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 875: 
line 876: " Icon
line 877: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 878: 
line 879: " IDL (Interface Description Language)
line 880: au BufNewFile,BufRead *.idl^I^I^Icall s:FTidl()
line 881: 
line 882: " Distinguish between standard IDL and MS-IDL
line 883: func! s:FTidl()
line 894: 
line 895: " Microsoft IDL (Interface Description Language)  Also *.idl
line 896: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 897: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 898: 
line 899: " Icewm menu
line 900: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 901: 
line 902: " Indent profile (must come before IDL *.pro!)
line 903: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 904: au BufNewFile,BufRead indent.pro^I^Icall s:ProtoCheck('indent')
line 905: 
line 906: " IDL (Interactive Data Language)
line 907: au BufNewFile,BufRead *.pro^I^I^Icall s:ProtoCheck('idlang')
line 908: 
line 909: " Distinguish between "default" and Cproto prototype file. */
line 910: func! s:ProtoCheck(default)
line 922: 
line 923: 
line 924: " Indent RC
line 925: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 926: 
line 927: " Inform
line 928: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 929: 
line 930: " Initng
line 931: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 932: 
line 933: " Innovation Data Processing
line 934: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat
line 935: au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c ^Isetf upstreamlog
line 936: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 937: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog
line 938: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog
line 939: 
line 940: " Ipfilter
line 941: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 942: 
line 943: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 944: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 945: 
line 946: " .INI file for MSDOS
line 947: au BufNewFile,BufRead *.ini^I^I^Isetf dosini
line 948: 
line 949: " SysV Inittab
line 950: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 951: 
line 952: " Inno Setup
line 953: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 954: 
line 955: " J
line 956: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 957: 
line 958: " JAL
line 959: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 960: 
line 961: " Jam
line 962: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 963: 
line 964: " Java
line 965: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
line 966: 
line 967: " JavaCC
line 968: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 969: 
line 970: " JavaScript, ECMAScript
line 971: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.json   setf javascript
line 972: 
line 973: " Java Server Pages
line 974: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 975: 
line 976: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 977: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 978: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 979: 
line 980: " Jess
line 981: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 982: 
line 983: " Jgraph
line 984: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 985: 
line 986: " Jovial
line 987: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 988: 
line 989: " Kixtart
line 990: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 991: 
line 992: " Kimwitu[++]
line 993: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 994: 
line 995: " KDE script
line 996: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 997: 
line 998: " Kconfig
line 999: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
line 1000: 
line 1001: " Lace (ISE)
line 1002: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 1003: 
line 1004: " Latte
line 1005: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 1006: 
line 1007: " Limits
line 1008: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 1009: 
line 1010: " LambdaProlog (*.mod too, see Modsim)
line 1011: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog
line 1012: 
line 1013: " LDAP LDIF
line 1014: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 1015: 
line 1016: " Ld loader
line 1017: au BufNewFile,BufRead *.ld^I^I^Isetf ld
line 1018: 
line 1019: " Lex
line 1020: au BufNewFile,BufRead *.lex,*.l^I^I^Isetf lex
line 1021: 
line 1022: " Libao
line 1023: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 1024: 
line 1025: " Libsensors
line 1026: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 1027: 
line 1028: " LFTP
line 1029: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 1030: 
line 1031: " Lifelines (or Lex for C++!)
line 1032: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
line 1033: 
line 1034: " Lilo: Linux loader
line 1035: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 1036: 
line 1037: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
line 1038: if has("fname_case")
line 1039:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
line 1040: else
line 1041:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
line 1042: endif
line 1043: 
line 1044: " SBCL implementation of Common Lisp
line 1045: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 1046: 
line 1047: " Liquid
line 1048: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 1049: 
line 1050: " Lite
line 1051: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 1052: 
line 1053: " LiteStep RC files
line 1054: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 1055: 
line 1056: " Login access
line 1057: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 1058: 
line 1059: " Login defs
line 1060: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 1061: 
line 1062: " Logtalk
line 1063: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 1064: 
line 1065: " LOTOS
line 1066: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
line 1067: 
line 1068: " Lout (also: *.lt)
line 1069: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 1070: 
line 1071: " Lua
line 1072: au BufNewFile,BufRead *.lua^I^I^Isetf lua
line 1073: 
line 1074: " Linden Scripting Language (Second Life)
line 1075: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl
line 1076: 
line 1077: " Lynx style file (or LotusScript!)
line 1078: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 1079: 
line 1080: " M4
line 1082: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 1083: 
line 1084: " MaGic Point
line 1085: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 1086: 
line 1087: " Mail (for Elm, trn, mutt, muttng, rn, slrn)
line 1088: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 1089: 
line 1090: " Mail aliases
line 1091: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 1092: 
line 1093: " Mailcap configuration file
line 1094: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 1095: 
line 1096: " Makefile
line 1097: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
line 1098: 
line 1099: " MakeIndex
line 1100: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 1101: 
line 1102: " Mallard
line 1103: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 1104: 
line 1105: " Manpage
line 1106: au BufNewFile,BufRead *.man^I^I^Isetf man
line 1107: 
line 1108: " Man config
line 1109: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 1110: 
line 1111: " Maple V
line 1112: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 1113: 
line 1114: " Map (UMN mapserver config file)
line 1115: au BufNewFile,BufRead *.map^I^I^Isetf map
line 1116: 
line 1117: " Markdown
line 1118: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,README.md  setf markdown
line 1119: 
line 1120: " Mason
line 1121: au BufNewFile,BufRead *.mason,*.mhtml^I^Isetf mason
line 1122: 
line 1123: " Matlab or Objective C
line 1124: au BufNewFile,BufRead *.m^I^I^Icall s:FTm()
line 1125: 
line 1126: func! s:FTm()
line 1150: 
line 1151: " Mathematica notebook
line 1152: au BufNewFile,BufRead *.nb^I^I^Isetf mma
line 1153: 
line 1154: " Maya Extension Language
line 1155: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 1156: 
line 1157: " Mercurial (hg) commit file
line 1158: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 1159: 
line 1160: " Mercurial config (looks like generic config file)
line 1161: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 1162: 
line 1163: " Messages (logs mostly)
line 1164: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 1165: 
line 1166: " Metafont
line 1167: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 1168: 
line 1169: " MetaPost
line 1170: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 1171: 
line 1172: " MGL
line 1173: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 1174: 
line 1175: " MMIX or VMS makefile
line 1176: au BufNewFile,BufRead *.mms^I^I^Icall s:FTmms()
line 1177: 
line 1178: " Symbian meta-makefile definition (MMP)
line 1179: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 1180: 
line 1181: func! s:FTmms()
line 1197: 
line 1198: 
line 1199: " Modsim III (or LambdaProlog)
line 1205: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif
line 1206: 
line 1207: " Modula 2
line 1208: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.md,*.mi setf modula2
line 1209: 
line 1210: " Modula 3 (.m3, .i3, .mg, .ig)
line 1211: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1212: 
line 1213: " Monk
line 1214: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1215: 
line 1216: " MOO
line 1217: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1218: 
line 1219: " Modconf
line 1220: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1221: 
line 1222: " Mplayer config
line 1223: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1224: 
line 1225: " Moterola S record
line 1226: au BufNewFile,BufRead *.s19,*.s28,*.s37^I^Isetf srec
line 1227: 
line 1228: " Mrxvtrc
line 1229: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1230: 
line 1231: " Msql
line 1232: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1233: 
line 1234: " Mysql
line 1235: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
line 1236: 
line 1237: " Mutt setup files (must be before catch *.rc)
line 1238: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 1239: 
line 1240: " M$ Resource files
line 1241: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc
line 1242: 
line 1243: " MuPAD source
line 1244: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1245: 
line 1246: " Mush
line 1247: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1248: 
line 1249: " Mutt setup file (also for Muttng)
line 1250: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1251: 
line 1252: " Nano
line 1253: au BufNewFile,BufRead */etc/nanorc,.nanorc^Isetf nanorc
line 1254: 
line 1255: " Nastran input/DMAP
line 1256: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1257: 
line 1258: " Natural
line 1259: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1260: 
line 1261: " Netrc
line 1262: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1263: 
line 1264: " Ninja file
line 1265: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1266: 
line 1267: " Novell netware batch files
line 1268: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1269: 
line 1270: " Nroff/Troff (*.ms and *.t are checked below)
line 1274: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1275: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1276: au BufNewFile,BufRead *.[1-9]^I^I^Icall s:FTnroff()
line 1277: 
line 1278: " This function checks if one of the first five lines start with a dot.  In
line 1279: " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
line 1280: func! s:FTnroff()
line 1287: 
line 1288: " Nroff or Objective C++
line 1289: au BufNewFile,BufRead *.mm^I^I^Icall s:FTmm()
line 1290: 
line 1291: func! s:FTmm()
line 1303: 
line 1304: " Not Quite C
line 1305: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1306: 
line 1307: " NSIS
line 1308: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1309: 
line 1310: " OCAML
line 1311: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml
line 1312: 
line 1313: " Occam
line 1314: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1315: 
line 1316: " Omnimark
line 1317: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1318: 
line 1319: " OpenROAD
line 1320: au BufNewFile,BufRead *.or^I^I^Isetf openroad
line 1321: 
line 1322: " OPL
line 1323: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl
line 1324: 
line 1325: " Oracle config file
line 1326: au BufNewFile,BufRead *.ora^I^I^Isetf ora
line 1327: 
line 1328: " Packet filter conf
line 1329: au BufNewFile,BufRead pf.conf^I^I^Isetf pf
line 1330: 
line 1331: " Pam conf
line 1332: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf
line 1333: 
line 1334: " PApp
line 1335: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp
line 1336: 
line 1337: " Password file
line 1338: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1339: 
line 1340: " Pascal (also *.p)
line 1341: au BufNewFile,BufRead *.pas^I^I^Isetf pascal
line 1342: 
line 1343: " Delphi project file
line 1344: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal
line 1345: 
line 1346: " PDF
line 1347: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf
line 1348: 
line 1349: " Perl
line 1350: if has("fname_case")
line 1351:   au BufNewFile,BufRead *.pl,*.PL^I^Icall s:FTpl()
line 1352: else
line 1353:   au BufNewFile,BufRead *.pl^I^I^Icall s:FTpl()
line 1354: endif
line 1355: au BufNewFile,BufRead *.plx,*.al^I^Isetf perl
line 1356: au BufNewFile,BufRead *.p6,*.pm6^I^Isetf perl6
line 1357: 
line 1358: func! s:FTpl()
line 1372: 
line 1373: " Perl, XPM or XPM2
line 1381: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1382: 
line 1383: " Perl POD
line 1384: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1385: 
line 1386: " Php, php3, php4, etc.
line 1387: " Also Phtml (was used for PHP 2 in the past)
line 1388: " Also .ctp for Cake template file
line 1389: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php
line 1390: 
line 1391: " Pike
line 1392: au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
line 1393: 
line 1394: " Pinfo config
line 1395: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1396: 
line 1397: " Palm Resource compiler
line 1398: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1399: 
line 1400: " Pine config
line 1401: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1402: 
line 1403: " PL/1, PL/I
line 1404: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1405: 
line 1406: " PL/M (also: *.inp)
line 1407: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1408: 
line 1409: " PL/SQL
line 1410: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1411: 
line 1412: " PLP
line 1413: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1414: 
line 1415: " PO and PO template (GNU gettext)
line 1416: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1417: 
line 1418: " Postfix main config
line 1419: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain
line 1420: 
line 1421: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1422: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1423: 
line 1424: " PostScript Printer Description
line 1425: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1426: 
line 1427: " Povray
line 1428: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1429: 
line 1430: " Povray configuration
line 1431: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1432: 
line 1433: " Povray, PHP or assembly
line 1434: au BufNewFile,BufRead *.inc^I^I^Icall s:FTinc()
line 1435: 
line 1436: func! s:FTinc()
line 1457: 
line 1458: " Printcap and Termcap
line 1460: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1462: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1463: 
line 1464: " PCCTS / ANTRL
line 1465: "au BufNewFile,BufRead *.g^I^I^Isetf antrl
line 1466: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 1467: 
line 1468: " PPWizard
line 1469: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1470: 
line 1471: " Obj 3D file format
line 1472: " TODO: is there a way to avoid MS-Windows Object files?
line 1473: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1474: 
line 1475: " Oracle Pro*C/C++
line 1476: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1477: 
line 1478: " Privoxy actions file
line 1479: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1480: 
line 1481: " Procmail
line 1482: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1483: 
line 1484: " Progress or CWEB
line 1485: au BufNewFile,BufRead *.w^I^I^Icall s:FTprogress_cweb()
line 1486: 
line 1487: func! s:FTprogress_cweb()
line 1498: 
line 1499: " Progress or assembly
line 1500: au BufNewFile,BufRead *.i^I^I^Icall s:FTprogress_asm()
line 1501: 
line 1502: func! s:FTprogress_asm()
line 1524: 
line 1525: " Progress or Pascal
line 1526: au BufNewFile,BufRead *.p^I^I^Icall s:FTprogress_pascal()
line 1527: 
line 1528: func! s:FTprogress_pascal()
line 1552: 
line 1553: 
line 1554: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1555: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1559: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1560: 
line 1561: " Prolog
line 1562: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1563: 
line 1564: " Promela
line 1565: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 1566: 
line 1567: " Google protocol buffers
line 1568: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 1569: 
line 1570: " Protocols
line 1571: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 1572: 
line 1573: " Pyrex
line 1574: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
line 1575: 
line 1576: " Python
line 1577: au BufNewFile,BufRead *.py,*.pyw^I^Isetf python
line 1578: 
line 1579: " Quixote (Python-based web framework)
line 1580: au BufNewFile,BufRead *.ptl^I^I^Isetf python
line 1581: 
line 1582: " Radiance
line 1583: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 1584: 
line 1585: " Ratpoison config/command files
line 1586: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 1587: 
line 1588: " RCS file
line 1589: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 1590: 
line 1591: " Readline
line 1592: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 1593: 
line 1594: " Registry for MS-Windows
line 1596: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 1597: 
line 1598: " Renderman Interface Bytestream
line 1599: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 1600: 
line 1601: " Rexx
line 1602: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 1603: 
line 1604: " R (Splus)
line 1605: if has("fname_case")
line 1606:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r
line 1607: else
line 1608:   au BufNewFile,BufRead *.s^I^I^Isetf r
line 1609: endif
line 1610: 
line 1611: " R Help file
line 1612: if has("fname_case")
line 1613:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 1614: else
line 1615:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 1616: endif
line 1617: 
line 1618: " R noweb file
line 1619: if has("fname_case")
line 1620:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 1621: else
line 1622:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 1623: endif
line 1624: 
line 1625: " Rexx, Rebol or R
line 1626: au BufNewFile,BufRead *.r,*.R^I^I^Icall s:FTr()
line 1627: 
line 1628: func! s:FTr()
line 1660: 
line 1661: " Remind
line 1662: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 1663: 
line 1664: " Resolv.conf
line 1665: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 1666: 
line 1667: " Relax NG Compact
line 1668: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 1669: 
line 1670: " Relax NG XML
line 1671: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 1672: 
line 1673: " RPL/2
line 1674: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 1675: 
line 1676: " Robots.txt
line 1677: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 1678: 
line 1679: " Rpcgen
line 1680: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 1681: 
line 1682: " reStructuredText Documentation Format
line 1683: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 1684: 
line 1685: " RTF
line 1686: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 1687: 
line 1688: " Interactive Ruby shell
line 1689: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
line 1690: 
line 1691: " Ruby
line 1692: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 1693: 
line 1694: " RubyGems
line 1695: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 1696: 
line 1697: " Rackup
line 1698: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 1699: 
line 1700: " Bundler
line 1701: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 1702: 
line 1703: " Ruby on Rails
line 1704: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 1705: 
line 1706: " Rantfile and Rakefile is like Ruby
line 1707: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 1708: 
line 1709: " S-lang (or shader language, or SmallLisp)
line 1710: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 1711: 
line 1712: " Samba config
line 1713: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 1714: 
line 1715: " SAS script
line 1716: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 1717: 
line 1718: " Sass
line 1719: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 1720: 
line 1721: " Sather
line 1722: au BufNewFile,BufRead *.sa^I^I^Isetf sather
line 1723: 
line 1724: " Scilab
line 1725: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 1726: 
line 1727: " SCSS
line 1728: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 1729: 
line 1730: " SD: Streaming Descriptors
line 1731: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 1732: 
line 1733: " SDL
line 1734: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 1735: 
line 1736: " sed
line 1737: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 1738: 
line 1739: " Sieve (RFC 3028)
line 1740: au BufNewFile,BufRead *.siv^I^I^Isetf sieve
line 1741: 
line 1742: " Sendmail
line 1743: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 1744: 
line 1745: " Sendmail .mc files are actually m4.  Could also be MS Message text file.
line 1746: au BufNewFile,BufRead *.mc^I^I^Icall s:McSetf()
line 1747: 
line 1748: func! s:McSetf()
line 1763: 
line 1764: " Services
line 1765: au BufNewFile,BufRead */etc/services^I^Isetf services
line 1766: 
line 1767: " Service Location config
line 1768: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 1769: 
line 1770: " Service Location registration
line 1771: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 1772: 
line 1773: " Service Location SPI
line 1774: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 1775: 
line 1776: " Setserial config
line 1777: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 1778: 
line 1779: " SGML
line 1789: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 1790: 
line 1791: " SGMLDECL
line 1795: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 1796: 
line 1797: " SGML catalog file
line 1798: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 1799: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 1800: 
line 1801: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 1802: " Gentoo ebuilds are actually bash scripts
line 1803: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash_profile*,.bash_logout*,*.bash,*.ebuild call SetFileTypeSH("bash")
line 1804: au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
line 1805: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
line 1806: 
line 1807: " Also called from scripts.vim.
line 1808: func! SetFileTypeSH(name)
line 1851: 
line 1852: " For shell-like file types, check for an "exec" command hidden in a comment,
line 1853: " as used for Tcl.
line 1854: " Also called from scripts.vim, thus can't be local to this script.
line 1855: func! SetFileTypeShell(name)
line 1874: 
line 1875: " tcsh scripts
line 1876: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall SetFileTypeShell("tcsh")
line 1877: 
line 1878: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 1879: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
line 1880: 
line 1881: func! s:CSH()
line 1890: 
line 1891: " Z-Shell script
line 1892: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 1893: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 1894: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
line 1895: 
line 1896: " Scheme
line 1897: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme
line 1898: 
line 1899: " Screen RC
line 1900: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 1901: 
line 1902: " Simula
line 1903: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 1904: 
line 1905: " SINDA
line 1906: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 1907: 
line 1908: " SiSU
line 1909: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 1910: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 1911: 
line 1912: " SKILL
line 1913: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 1914: 
line 1915: " SLRN
line 1916: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 1917: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 1918: 
line 1919: " Smalltalk (and TeX)
line 1920: au BufNewFile,BufRead *.st^I^I^Isetf st
line 1928: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif
line 1929: 
line 1930: " Smarty templates
line 1931: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 1932: 
line 1933: " SMIL or XML
line 1939: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 1940: 
line 1941: " SMIL or SNMP MIB file
line 1947: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 1948: 
line 1949: " SMITH
line 1950: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 1951: 
line 1952: " Snobol4 and spitbol
line 1953: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 1954: 
line 1955: " SNMP MIB files
line 1956: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 1957: 
line 1958: " Snort Configuration
line 1959: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 1960: au BufNewFile,BufRead *.rules^I^I^Icall s:FTRules()
line 1961: 
line 1962: let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
line 1963: func! s:FTRules()
line 1991: 
line 1992: 
line 1993: " Spec (Linux RPM)
line 1994: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 1995: 
line 1996: " Speedup (AspenTech plant simulator)
line 1997: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 1998: 
line 1999: " Slice
line 2000: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 2001: 
line 2002: " Spice
line 2003: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 2004: 
line 2005: " Spyce
line 2006: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 2007: 
line 2008: " Squid
line 2009: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 2010: 
line 2011: " SQL for Oracle Designer
line 2012: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql
line 2013: 
line 2014: " SQL
line 2015: au BufNewFile,BufRead *.sql^I^I^Icall s:SQL()
line 2016: 
line 2017: func! s:SQL()
line 2024: 
line 2025: " SQLJ
line 2026: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 2027: 
line 2028: " SQR
line 2029: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 2030: 
line 2031: " OpenSSH configuration
line 2032: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig
line 2033: 
line 2034: " OpenSSH server configuration
line 2035: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig
line 2036: 
line 2037: " Stata
line 2038: au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata
line 2039: 
line 2040: " SMCL
line 2041: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 2042: 
line 2043: " Stored Procedures
line 2044: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 2045: 
line 2046: " Standard ML
line 2047: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 2048: 
line 2049: " Sratus VOS command macro
line 2050: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 2051: 
line 2052: " Sysctl
line 2053: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 2054: 
line 2055: " Synopsys Design Constraints
line 2056: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 2057: 
line 2058: " Sudoers
line 2059: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 2060: 
line 2061: " SVG (Scalable Vector Graphics)
line 2062: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 2063: 
line 2064: " If the file has an extension of 't' and is in a directory 't' then it is
line 2065: " almost certainly a Perl test file.
line 2066: " If the first line starts with '#' and contains 'perl' it's probably a Perl
line 2067: " file.
line 2068: " (Slow test) If a file contains a 'use' statement then it is almost certainly
line 2069: " a Perl file.
line 2070: func! s:FTperl()
line 2085: 
line 2086: " Tads (or Nroff or Perl test file)
line 2088: au BufNewFile,BufRead *.t if !s:FTnroff() && !s:FTperl() | setf tads | endif
line 2089: 
line 2090: " Tags
line 2091: au BufNewFile,BufRead tags^I^I^Isetf tags
line 2092: 
line 2093: " TAK
line 2094: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 2095: 
line 2096: " Task
line 2097: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 2098: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 2099: 
line 2100: " Tcl (JACL too)
line 2101: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl
line 2102: 
line 2103: " TealInfo
line 2104: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 2105: 
line 2106: " Telix Salt
line 2107: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 2108: 
line 2109: " Terminfo
line 2110: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 2111: 
line 2112: " TeX
line 2113: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 2114: au BufNewFile,BufRead *.tex^I^I^Icall s:FTtex()
line 2115: 
line 2116: " Choose context, plaintex, or tex (LaTeX) based on these rules:
line 2117: " 1. Check the first line of the file for "%&<format>".
line 2118: " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
line 2119: " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
line 2120: func! s:FTtex()
line 2167: 
line 2168: " ConTeXt
line 2169: au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context
line 2170: 
line 2171: " Texinfo
line 2172: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 2173: 
line 2174: " TeX configuration
line 2175: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 2176: 
line 2177: " Tidy config
line 2178: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy
line 2179: 
line 2180: " TF mud client
line 2181: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf
line 2182: 
line 2183: " TPP - Text Presentation Program
line 2184: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp
line 2185: 
line 2186: " Treetop
line 2187: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 2188: 
line 2189: " Trustees
line 2190: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 2191: 
line 2192: " TSS - Geometry
line 2193: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 2194: 
line 2195: " TSS - Optics
line 2196: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 2197: 
line 2198: " TSS - Command Line (temporary)
line 2199: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 2200: 
line 2201: " TWIG files
line 2202: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 2203: 
line 2204: " Motif UIT/UIL files
line 2205: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 2206: 
line 2207: " Udev conf
line 2208: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 2209: 
line 2210: " Udev permissions
line 2211: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 2212: "
line 2213: " Udev symlinks config
line 2214: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 2215: 
line 2216: " UnrealScript
line 2217: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 2218: 
line 2219: " Updatedb
line 2220: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 2221: 
line 2222: " Upstart (init(8)) config files
line 2223: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 2224: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 2225: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 2226: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart
line 2227: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 2228: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 2229: 
line 2230: " Vera
line 2231: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 2232: 
line 2233: " Verilog HDL
line 2234: au BufNewFile,BufRead *.v^I^I^Isetf verilog
line 2235: 
line 2236: " Verilog-AMS HDL
line 2237: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 2238: 
line 2239: " VHDL
line 2240: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
line 2241: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 2242: 
line 2243: " Vim script
line 2244: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim
line 2245: 
line 2246: " Viminfo file
line 2247: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 2248: 
line 2249: " Virata Config Script File or Drupal module
line 2255: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 2256: 
line 2257: " Visual Basic (also uses *.bas) or FORM
line 2258: au BufNewFile,BufRead *.frm^I^I^Icall s:FTVB("form")
line 2259: 
line 2260: " SaxBasic is close to Visual Basic
line 2261: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 2262: 
line 2263: " Vgrindefs file
line 2264: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 2265: 
line 2266: " VRML V1.0c
line 2267: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 2268: 
line 2269: " Webmacro
line 2270: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 2271: 
line 2272: " Wget config
line 2273: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 2274: 
line 2275: " Website MetaLanguage
line 2276: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 2277: 
line 2278: " Winbatch
line 2279: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 2280: 
line 2281: " WSML
line 2282: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 2283: 
line 2284: " WvDial
line 2285: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 2286: 
line 2287: " CVS RC file
line 2288: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 2289: 
line 2290: " CVS commit file
line 2291: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 2292: 
line 2293: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 2294: " lines in a WEB file).
line 2300: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 2301: 
line 2302: " Windows Scripting Host and Windows Script Component
line 2303: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 2304: 
line 2305: " XHTML
line 2306: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 2307: 
line 2308: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
line 2314: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 2315: au BufEnter *.xpm2^I^I^I^Isetf xpm2
line 2316: 
line 2317: " XFree86 config
line 2322: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 2325: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2326: 
line 2327: " Xorg config
line 2328: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2329: 
line 2330: " Xinetd conf
line 2331: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 2332: 
line 2333: " XS Perl extension interface language
line 2334: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 2335: 
line 2336: " X resources file
line 2337: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 2338: 
line 2339: " Xmath
line 2340: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 2342: au BufNewFile,BufRead *.ms if !s:FTnroff() | setf xmath | endif
line 2343: 
line 2344: " XML  specific variants: docbk and xbl
line 2345: au BufNewFile,BufRead *.xml^I^I^Icall s:FTxml()
line 2346: 
line 2347: func! s:FTxml()
line 2372: 
line 2373: " XMI (holding UML models) is also XML
line 2374: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 2375: 
line 2376: " CSPROJ files are Visual Studio.NET's XML-based project config files
line 2377: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 2378: 
line 2379: " Qt Linguist translation source and Qt User Interface Files are XML
line 2380: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml
line 2381: 
line 2382: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 2383: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 2384: 
line 2385: " Xdg menus
line 2386: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 2387: 
line 2388: " ATI graphics driver configuration
line 2389: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 2390: 
line 2391: " XLIFF (XML Localisation Interchange File Format) is also XML
line 2392: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 2393: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 2394: 
line 2395: " XML User Interface Language
line 2396: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 2397: 
line 2398: " X11 xmodmap (also see below)
line 2399: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 2400: 
line 2401: " Xquery
line 2402: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 2403: 
line 2404: " XSD
line 2405: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 2406: 
line 2407: " Xslt
line 2408: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 2409: 
line 2410: " Yacc
line 2411: au BufNewFile,BufRead *.yy^I^I^Isetf yacc
line 2412: 
line 2413: " Yacc or racc
line 2414: au BufNewFile,BufRead *.y^I^I^Icall s:FTy()
line 2415: 
line 2416: func! s:FTy()
line 2432: 
line 2433: 
line 2434: " Yaml
line 2435: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml
line 2436: 
line 2437: " yum conf (close enough to dosini)
line 2438: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 2439: 
line 2440: " Zimbu
line 2441: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 2442: 
line 2443: " Zope
line 2444: "   dtml (zope dynamic template markup language), pt (zope page template),
line 2445: "   cpt (zope form controller page template)
line 2446: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall s:FThtml()
line 2447: "   zsql (zope sql method)
line 2448: au BufNewFile,BufRead *.zsql^I^I^Icall s:SQL()
line 2449: 
line 2450: " Z80 assembler asz80
line 2451: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 2452: 
line 2453: augroup END
line 2454: 
line 2455: 
line 2456: " Source the user-specified filetype file, for backwards compatibility with
line 2457: " Vim 5.x.
line 2458: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 2459:   execute "source " . myfiletypefile
line 2460: endif
line 2461: 
line 2462: 
line 2463: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 2464: " when there are no matching file name extensions.
line 2465: " Don't do this for compressed files.
line 2466: augroup filetypedetect
line 2469: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 2470: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 2471: 
line 2472: 
line 2473: " Extra checks for when no filetype has been detected now.  Mostly used for
line 2474: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 2475: " script file.
line 2476: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 2477: " like are used.
line 2478: 
line 2479: " More Apache config files
line 2480: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
line 2481: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
line 2482: 
line 2483: " Asterisk config file
line 2484: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 2485: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 2486: 
line 2487: " Bazaar version control
line 2488: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 2489: 
line 2490: " BIND zone
line 2491: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 2492: 
line 2493: " Calendar
line 2496: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 2497: 
line 2498: " Changelog
line 2504: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 2505: 
line 2506: " Crontab
line 2507: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 2508: 
line 2509: " dnsmasq(8) configuration
line 2510: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 2511: 
line 2512: " Dracula
line 2513: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 2514: 
line 2515: " Fvwm
line 2516: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 2518: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 2524: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 2525: 
line 2526: " Gedcom
line 2527: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 2528: 
line 2529: " GTK RC
line 2530: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 2531: 
line 2532: " Jam
line 2533: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 2534: 
line 2535: " Jargon
line 2539: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 2540: 
line 2541: " Kconfig
line 2542: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
line 2543: 
line 2544: " Lilo: Linux loader
line 2545: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 2546: 
line 2547: " Logcheck
line 2548: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 2549: 
line 2550: " Makefile
line 2551: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 2552: 
line 2553: " Ruby Makefile
line 2554: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 2555: 
line 2556: " Mail (also matches muttrc.vim, so this is below the other checks)
line 2557: au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 2558: 
line 2559: " Modconf
line 2563: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 2564: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 2565: 
line 2566: " Mutt setup file
line 2567: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 2568: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 2569: 
line 2570: " Nroff macros
line 2571: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 2572: 
line 2573: " Pam conf
line 2574: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 2575: 
line 2576: " Printcap and Termcap
line 2580: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 2584: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 2585: 
line 2586: " ReDIF
line 2587: " Only used when the .rdf file was not detected to be XML.
line 2588: au BufRead,BufNewFile *.rdf^I^I^Icall s:Redif()
line 2589: func! s:Redif()
line 2599: 
line 2600: " Remind
line 2601: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 2602: 
line 2603: " Vim script
line 2604: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 2605: 
line 2606: " Subversion commit file
line 2607: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 2608: 
line 2609: " X resources file
line 2610: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 2611: 
line 2612: " XFree86 config
line 2614: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 2619: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 2620: 
line 2621: " X11 xmodmap
line 2622: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 2623: 
line 2624: " Xinetd conf
line 2625: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 2626: 
line 2627: " yum conf (close enough to dosini)
line 2628: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 2629: 
line 2630: " Z-Shell script
line 2631: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 2632: 
line 2633: 
line 2634: " Plain text files, needs to be far down to not override others.  This avoids
line 2635: " the "conf" type being used if there is a line starting with '#'.
line 2636: au BufNewFile,BufRead *.txt,*.text^I^Isetf text
line 2637: 
line 2638: 
line 2639: " Use the filetype detect plugins.  They may overrule any of the previously
line 2640: " detected filetypes.
line 2641: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/a
Searching for "/home/max/.vim/ftdetect/*.vim"
chdir(/home/max/.vim/ftdetect)
fchdir() to previous dir
line 2641: sourcing "/home/max/.vim/ftdetect/gofiletype.vim"
line 1: " We take care to preserve the user's fileencodings and fileformats,
line 2: " because those settings are global (not buffer local), yet we want
line 3: " to override them for loading Go files, which are defined to be UTF-8.
line 4: let s:current_fileformats = ''
line 5: let s:current_fileencodings = ''
line 6: 
line 7: " define fileencodings to open as utf-8 encoding even if it's ascii.
line 8: function! s:gofiletype_pre()
line 14: 
line 15: " restore fileencodings as others
line 16: function! s:gofiletype_post()
line 20: 
line 21: au BufNewFile *.go setlocal filetype=go fileencoding=utf-8 fileformat=unix
line 22: au BufRead *.go call s:gofiletype_pre()
line 23: au BufReadPost *.go call s:gofiletype_post()
finished sourcing /home/max/.vim/ftdetect/gofiletype.vim
continuing in /usr/share/vim/vim74/filetype.vim
Searching for "/home/max/.vim/bundle/vundle/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-rails/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/L9/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/command-t/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/syntastic/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-golang/ftdetect/*.vim"
chdir(/home/max/.vim/bundle/vim-golang/ftdetect)
fchdir() to previous dir
line 2641: sourcing "/home/max/.vim/bundle/vim-golang/ftdetect/gofiletype.vim"
line 1: " We take care to preserve the user's fileencodings and fileformats,
line 2: " because those settings are global (not buffer local), yet we want
line 3: " to override them for loading Go files, which are defined to be UTF-8.
line 4: let s:current_fileformats = ''
line 5: let s:current_fileencodings = ''
line 6: 
line 7: " define fileencodings to open as utf-8 encoding even if it's ascii.
line 8: function! s:gofiletype_pre()
line 14: 
line 15: " restore fileencodings as others
line 16: function! s:gofiletype_post()
line 20: 
line 21: au BufNewFile *.go setlocal filetype=go fileencoding=utf-8 fileformat=unix
line 22: au BufRead *.go call s:gofiletype_pre()
line 23: au BufReadPost *.go call s:gofiletype_post()
finished sourcing /home/max/.vim/bundle/vim-golang/ftdetect/gofiletype.vim
continuing in /usr/share/vim/vim74/filetype.vim
Searching for "/home/max/.vim/bundle/scss-syntax.vim/ftdetect/*.vim"
chdir(/home/max/.vim/bundle/scss-syntax.vim/ftdetect)
fchdir() to previous dir
line 2641: sourcing "/home/max/.vim/bundle/scss-syntax.vim/ftdetect/scss.vim"
line 1: au BufRead,BufNewFile *.scss set filetype=scss
line 2: au BufEnter *.scss :syntax sync fromstart
finished sourcing /home/max/.vim/bundle/scss-syntax.vim/ftdetect/scss.vim
continuing in /usr/share/vim/vim74/filetype.vim
Searching for "/home/max/.vim/bundle/vim-coffee-script/ftdetect/*.vim"
chdir(/home/max/.vim/bundle/vim-coffee-script/ftdetect)
fchdir() to previous dir
line 2641: sourcing "/home/max/.vim/bundle/vim-coffee-script/ftdetect/coffee.vim"
line 1: " Language:    CoffeeScript
line 2: " Maintainer:  Mick Koch <kchmck@gmail.com>
line 3: " URL:         http://github.com/kchmck/vim-coffee-script
line 4: " License:     WTFPL
line 5: 
line 6: autocmd BufNewFile,BufRead *.coffee set filetype=coffee
line 7: autocmd BufNewFile,BufRead *Cakefile set filetype=coffee
line 8: autocmd BufNewFile,BufRead *.coffeekup,*.ck set filetype=coffee
line 9: autocmd BufNewFile,BufRead *._coffee set filetype=coffee
line 10: 
line 11: function! s:DetectCoffee()
line 16: 
line 17: autocmd BufNewFile,BufRead * call s:DetectCoffee()
finished sourcing /home/max/.vim/bundle/vim-coffee-script/ftdetect/coffee.vim
continuing in /usr/share/vim/vim74/filetype.vim
Searching for "/home/max/.vim/bundle/LaTeX-Box/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/google.vim/ftdetect/*.vim"
Searching for "/var/lib/vim/addons/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"
Searching for "/usr/share/vim/vim74/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"
Searching for "/var/lib/vim/addons/after/ftdetect/*.vim"
Searching for "/home/max/.vim/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vundle/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/L9/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/command-t/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/ftdetect/*.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/ftdetect/*.vim"
line 2642: 
line 2643: " NOTE: The above command could have ended the filetypedetect autocmd group
line 2644: " and started another one. Let's make sure it has ended to get to a consistent
line 2645: " state.
line 2646: augroup END
line 2647: 
line 2648: " Generic configuration file (check this last, it's just guessing!)
line 2654: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf conf | endif
line 2655: 
line 2656: 
line 2657: " If the GUI is already running, may still need to install the Syntax menu.
line 2658: " Don't do it when the 'M' flag is included in 'guioptions'.
line 2660: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 2661:   source <sfile>:p:h/menu.vim
line 2662: endif
line 2663: 
line 2664: " Function called for testing all functions defined here.  These are
line 2665: " script-local, thus need to be executed here.
line 2666: " Returns a string with error messages (hopefully empty).
line 2667: func! TestFiletypeFuncs(testlist)
line 2678: 
line 2679: " Restore 'cpoptions'
line 2680: let &cpo = s:cpo_save
line 2681: unlet s:cpo_save
finished sourcing /usr/share/vim/vim74/filetype.vim
continuing in /home/max/.vim/plugin/settings/vundle.vim
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/var/lib/vim/addons/after/filetype.vim"
Searching for "/home/max/.vim/after/filetype.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/filetype.vim"
Searching for "/home/max/.vim/bundle/vundle/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/filetype.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/filetype.vim"
Searching for "/home/max/.vim/bundle/L9/after/filetype.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/filetype.vim"
Searching for "/home/max/.vim/bundle/command-t/after/filetype.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/filetype.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/filetype.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/filetype.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/filetype.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/filetype.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/filetype.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/filetype.vim"
Searching for "ftplugin.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/aft
Searching for "/home/max/.vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vundle/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-rails/ftplugin.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/L9/ftplugin.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/ftplugin.vim"
Searching for "/home/max/.vim/bundle/command-t/ftplugin.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/ftplugin.vim"
Searching for "/home/max/.vim/bundle/syntastic/ftplugin.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-golang/ftplugin.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/ftplugin.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/ftplugin.vim"
Searching for "/home/max/.vim/bundle/google.vim/ftplugin.vim"
Searching for "/var/lib/vim/addons/ftplugin.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"
Searching for "/usr/share/vim/vim74/ftplugin.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 64: sourcing "/usr/share/vim/vim74/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
finished sourcing /usr/share/vim/vim74/ftplugin.vim
continuing in /home/max/.vim/plugin/settings/vundle.vim
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"
Searching for "/var/lib/vim/addons/after/ftplugin.vim"
Searching for "/home/max/.vim/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vundle/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/L9/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/command-t/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/ftplugin.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/ftplugin.vim"
Searching for "indent.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/after
Searching for "/home/max/.vim/indent.vim"
Searching for "/home/max/.vim/bundle/vundle/indent.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/indent.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/indent.vim"
Searching for "/home/max/.vim/bundle/vim-rails/indent.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/indent.vim"
Searching for "/home/max/.vim/bundle/L9/indent.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/indent.vim"
Searching for "/home/max/.vim/bundle/command-t/indent.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/indent.vim"
Searching for "/home/max/.vim/bundle/syntastic/indent.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/indent.vim"
Searching for "/home/max/.vim/bundle/vim-golang/indent.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/indent.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/indent.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/indent.vim"
Searching for "/home/max/.vim/bundle/google.vim/indent.vim"
Searching for "/var/lib/vim/addons/indent.vim"
Searching for "/usr/share/vim/vimfiles/indent.vim"
Searching for "/usr/share/vim/vim74/indent.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 64: sourcing "/usr/share/vim/vim74/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
line 5: 
line 6: if exists("did_indent_on")
line 7:   finish
finished sourcing /usr/share/vim/vim74/indent.vim
continuing in /home/max/.vim/plugin/settings/vundle.vim
Searching for "/usr/share/vim/vimfiles/after/indent.vim"
Searching for "/var/lib/vim/addons/after/indent.vim"
Searching for "/home/max/.vim/after/indent.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/indent.vim"
Searching for "/home/max/.vim/bundle/vundle/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/indent.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/indent.vim"
Searching for "/home/max/.vim/bundle/L9/after/indent.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/indent.vim"
Searching for "/home/max/.vim/bundle/command-t/after/indent.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/indent.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/indent.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/indent.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/indent.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/indent.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/indent.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/indent.vim"
line 65: " To ignore plugin indent changes, instead use:
line 66: "filetype plugin on
line 67: "
line 68: " Brief help
line 69: " :PluginList          - list configured plugins
line 70: " :PluginInstall(!)    - install (update) plugins
line 71: " :PluginSearch(!) foo - search (or refresh cache first) for foo
line 72: " :PluginClean(!)      - confirm (or auto-approve) removal of unused plugins
line 73: "
line 74: " see :h vundle for more details or wiki for FAQ
line 75: " NOTE: comments after Plugin commands are not allowed.
line 76: " Put your stuff after this line
finished sourcing /home/max/.vim/plugin/settings/vundle.vim
chdir(/home/max/.vim/plugin/settings)
fchdir() to previous dir
sourcing "/home/max/.vim/plugin/settings/youcompleteme.vim"
line 1: " youcompleteme.vim
line 2: " /home/max/.vim/plugins/settings/youcompleteme.vim
line 3: " 
line 4: " used to setup youcompleteme settings
line 5: 
line 6: " blacklist some files
line 9: let g:ycm_filetype_blacklist = { 'go' :1}
finished sourcing /home/max/.vim/plugin/settings/youcompleteme.vim
Searching for "/home/max/.vim/bundle/vundle/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/plugin/**/*.vim"
chdir(/home/max/.vim/bundle/vim-fugitive/plugin)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim"
line 1: " fugitive.vim - A Git wrapper so awesome, it should be illegal
line 2: " Maintainer:   Tim Pope <http://tpo.pe/>
line 3: " Version:      2.1
line 4: " GetLatestVimScripts: 2975 1 :AutoInstall: fugitive.vim
line 5: 
line 6: if exists('g:loaded_fugitive') || &cp
line 7:   finish
line 8: endif
line 9: let g:loaded_fugitive = 1
line 10: 
line 11: if !exists('g:fugitive_git_executable')
line 12:   let g:fugitive_git_executable = 'git'
line 13: endif
line 14: 
line 15: " Section: Utility
line 16: 
line 17: function! s:function(name) abort
line 20: 
line 21: function! s:sub(str,pat,rep) abort
line 24: 
line 25: function! s:gsub(str,pat,rep) abort
line 28: 
line 29: function! s:winshell() abort
line 32: 
line 33: function! s:shellesc(arg) abort
line 42: 
line 43: function! s:fnameescape(file) abort
line 50: 
line 51: function! s:throw(string) abort
line 55: 
line 56: function! s:warn(str) abort
line 62: 
line 63: function! s:shellslash(path) abort
line 70: 
line 71: let s:git_versions = {}
line 72: 
line 73: function! fugitive#git_version(...) abort
Searching for "autoload/fugitive.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyF
Searching for "/home/max/.vim/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/command-t/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/syntastic/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/vim-golang/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/google.vim/autoload/fugitive.vim"
Searching for "/var/lib/vim/addons/autoload/fugitive.vim"
Searching for "/usr/share/vim/vimfiles/autoload/fugitive.vim"
Searching for "/usr/share/vim/vim74/autoload/fugitive.vim"
Searching for "/usr/share/vim/vimfiles/after/autoload/fugitive.vim"
Searching for "/var/lib/vim/addons/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/vundle/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/L9/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/command-t/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/autoload/fugitive.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/autoload/fugitive.vim"
not found in 'runtimepath': "autoload/fugitive.vim"
line 79: 
line 80: function! s:recall() abort
line 97: 
line 98: function! s:add_methods(namespace, method_names) abort
line 103: 
line 104: let s:commands = []
line 105: function! s:command(definition) abort
line 108: 
line 109: function! s:define_commands() abort
line 114: 
line 115: augroup fugitive_utility
line 116:   autocmd!
line 117:   autocmd User Fugitive call s:define_commands()
line 118: augroup END
line 119: 
line 120: let s:abstract_prototype = {}
line 121: 
line 122: " Section: Initialization
line 123: 
line 124: function! fugitive#is_git_dir(path) abort
line 128: 
line 129: function! fugitive#extract_git_dir(path) abort
line 169: 
line 170: function! fugitive#detect(path) abort
line 199: 
line 200: augroup fugitive
line 201:   autocmd!
line 202:   autocmd BufNewFile,BufReadPost * call fugitive#detect(expand('<amatch>:p'))
line 203:   autocmd FileType           netrw call fugitive#detect(expand('%:p'))
line 204:   autocmd User NERDTreeInit,NERDTreeNewRoot call fugitive#detect(b:NERDTreeRoot.path.str())
line 205:   autocmd VimEnter * if expand('<amatch>')==''|call fugitive#detect(getcwd())|endif
line 206:   autocmd CmdWinEnter * call fugitive#detect(expand('#:p'))
line 207:   autocmd BufWinLeave * execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
line 208: augroup END
line 209: 
line 210: " Section: Repository
line 211: 
line 212: let s:repo_prototype = {}
line 213: let s:repos = {}
line 214: 
line 215: function! s:repo(...) abort
line 228: 
line 229: function! fugitive#repo(...) abort
line 232: 
line 233: function! s:repo_dir(...) dict abort
line 236: 
line 237: function! s:repo_configured_tree() dict abort
line 254: 
line 255: function! s:repo_tree(...) dict abort
line 267: 
line 268: function! s:repo_bare() dict abort
line 275: 
line 276: function! s:repo_translate(spec) dict abort
line 320: 
line 321: function! s:repo_head(...) dict abort
line 336: 
line 337: call s:add_methods('repo',['dir','configured_tree','tree','bare','translate','head'])
calling function <SNR>33_add_methods('repo', ['dir', 'configured_tree', 'tree', 'bare', 'translate', 'head'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_dir')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_dir')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_configured_tree')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_configured_tree')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_tree')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_tree')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_bare')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_bare')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_translate')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_translate')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_head')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_head')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>33_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 338: 
line 339: function! s:repo_git_command(...) dict abort
line 343: 
line 344: function! s:repo_git_chomp(...) dict abort
line 347: 
line 348: function! s:repo_git_chomp_in_tree(...) dict abort
line 358: 
line 359: function! s:repo_rev_parse(rev) dict abort
line 366: 
line 367: call s:add_methods('repo',['git_command','git_chomp','git_chomp_in_tree','rev_parse'])
calling function <SNR>33_add_methods('repo', ['git_command', 'git_chomp', 'git_chomp_in_tree', 'rev_parse'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_git_command')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_git_command')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_git_chomp')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_git_chomp')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_git_chomp_in_tree')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_git_chomp_in_tree')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_rev_parse')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_rev_parse')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>33_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 368: 
line 369: function! s:repo_dirglob(base) dict abort
line 375: 
line 376: function! s:repo_superglob(base) dict abort
line 413: 
line 414: call s:add_methods('repo',['dirglob','superglob'])
calling function <SNR>33_add_methods('repo', ['dirglob', 'superglob'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_dirglob')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_dirglob')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_superglob')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_superglob')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>33_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 415: 
line 416: function! s:repo_config(conf) dict abort
line 419: 
line 420: function! s:repo_user() dict abort
line 425: 
line 426: function! s:repo_aliases() dict abort
line 435: 
line 436: call s:add_methods('repo',['config', 'user', 'aliases'])
calling function <SNR>33_add_methods('repo', ['config', 'user', 'aliases'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_config')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_config')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_user')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_user')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_aliases')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_aliases')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>33_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 437: 
line 438: function! s:repo_keywordprg() dict abort
line 446: 
line 447: call s:add_methods('repo',['keywordprg'])
calling function <SNR>33_add_methods('repo', ['keywordprg'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_keywordprg')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_keywordprg')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>33_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 448: 
line 449: " Section: Buffer
line 450: 
line 451: let s:buffer_prototype = {}
line 452: 
line 453: function! s:buffer(...) abort
line 461: 
line 462: function! fugitive#buffer(...) abort
line 465: 
line 466: function! s:buffer_getvar(var) dict abort
line 469: 
line 470: function! s:buffer_setvar(var,value) dict abort
line 473: 
line 474: function! s:buffer_getline(lnum) dict abort
line 477: 
line 478: function! s:buffer_repo() dict abort
line 481: 
line 482: function! s:buffer_type(...) dict abort
line 506: 
line 507: if has('win32')
line 508: 
line 509:   function! s:buffer_spec() dict abort
line 517: 
line 518: else
line 519: 
line 520:   function! s:buffer_spec() dict abort
line 524: 
line 525: endif
line 526: 
line 527: function! s:buffer_name() dict abort
line 530: 
line 531: function! s:buffer_commit() dict abort
line 534: 
line 535: function! s:buffer_path(...) dict abort
line 546: 
line 547: function! s:buffer_rev() dict abort
line 561: 
line 562: function! s:buffer_sha1() dict abort
line 569: 
line 570: function! s:buffer_expand(rev) dict abort
line 587: 
line 588: function! s:buffer_containing_commit() dict abort
line 597: 
line 598: function! s:buffer_up(...) dict abort
line 621: 
line 622: call s:add_methods('buffer',['getvar','setvar','getline','repo','type','spec','name','commit','path','rev','sha1','expand','containing_commit','up'])
calling function <SNR>33_add_methods('buffer', ['getvar', 'setvar', 'getline', 'repo...1', 'expand', 'containing_commit', 'up'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_getvar')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_getvar')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_setvar')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_setvar')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_getline')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_getline')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_repo')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_repo')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_type')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_type')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_spec')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_spec')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_name')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_name')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_commit')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_commit')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_path')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_path')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_rev')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_rev')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_sha1')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_sha1')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_expand')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_expand')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_containing_commit')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_containing_commit')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_up')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_up')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>33_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 623: 
line 624: " Section: Git
line 625: 
line 626: call s:command("-bang -nargs=? -complete=customlist,s:GitComplete Git :execute s:Git(<bang>0,<q-args>)")
calling function <SNR>33_command('-bang -nargs=? -complete=customlist,...te Git :execute s:Git(<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 627: 
line 628: function! s:ExecuteInTree(cmd) abort
line 638: 
line 639: function! s:Git(bang, args) abort
line 652: 
line 653: function! fugitive#git_commands() abort
line 659: 
line 660: function! s:GitComplete(A, L, P) abort
line 668: 
line 669: " Section: Gcd, Glcd
line 670: 
line 671: function! s:DirComplete(A,L,P) abort
line 675: 
line 676: call s:command("-bar -bang -nargs=? -complete=customlist,s:DirComplete Gcd  :cd<bang>  `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`")
calling function <SNR>33_command('-bar -bang -nargs=? -complete=custom...ir(<q-args>) : s:repo().tree(<q-args>)`')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 677: call s:command("-bar -bang -nargs=? -complete=customlist,s:DirComplete Glcd :lcd<bang> `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`")
calling function <SNR>33_command('-bar -bang -nargs=? -complete=custom...ir(<q-args>) : s:repo().tree(<q-args>)`')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 678: 
line 679: " Section: Gstatus
line 680: 
line 681: call s:command("-bar Gstatus :execute s:Status()")
calling function <SNR>33_command('-bar Gstatus :execute s:Status()')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 682: augroup fugitive_status
line 683:   autocmd!
line 684:   if !has('win32')
line 685:     autocmd FocusGained,ShellCmdPost * call fugitive#reload_status()
line 686:   endif
line 687: augroup END
line 688: 
line 689: function! s:Status() abort
line 700: 
line 701: function! fugitive#reload_status() abort
line 733: 
line 734: function! s:stage_info(lnum) abort
line 759: 
line 760: function! s:StageNext(count) abort
line 766: 
line 767: function! s:StagePrevious(count) abort
line 777: 
line 778: function! s:StageReloadSeek(target,lnum1,lnum2) abort
line 789: 
line 790: function! s:StageUndo() abort
line 811: 
line 812: function! s:StageDiff(diff) abort
line 830: 
line 831: function! s:StageDiffEdit() abort
line 853: 
line 854: function! s:StageToggle(lnum1,lnum2) abort
line 918: 
line 919: function! s:StagePatch(lnum1,lnum2) abort
line 964: 
line 965: " Section: Gcommit
line 966: 
line 967: call s:command("-nargs=? -complete=customlist,s:CommitComplete Gcommit :execute s:Commit(<q-args>)")
calling function <SNR>33_command('-nargs=? -complete=customlist,s:Comm...ete Gcommit :execute s:Commit(<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 968: 
line 969: function! s:Commit(args, ...) abort
line 1051: 
line 1052: function! s:CommitComplete(A,L,P) abort
line 1060: 
line 1061: function! s:FinishCommit() abort
line 1069: 
line 1070: " Section: Gmerge, Gpull
line 1071: 
line 1073: call s:command("-nargs=? -bang -complete=custom,s:RevisionComplete Gmerge " . "execute s:Merge('merge', <bang>0, <q-args>)")
calling function <SNR>33_command('-nargs=? -bang -complete=custom,s:Re...e s:Merge(''merge'', <bang>0, <q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1075: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gpull " . "execute s:Merge('pull --progress', <bang>0, <q-args>)")
calling function <SNR>33_command('-nargs=? -bang -complete=custom,s:Re...''pull --progress'', <bang>0, <q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1076: 
line 1077: function! s:RevisionComplete(A, L, P) abort
line 1081: 
line 1082: function! s:RemoteComplete(A, L, P) abort
line 1093: 
line 1094: function! fugitive#cwindow() abort
line 1104: 
line 1111: let s:common_efm = '' . '%+Egit:%.%#,' . '%+Eusage:%.%#,' . '%+Eerror:%.%#,' . '%+Efatal:%.%#,' . '%-G%.%#%\e[K%.%#,' . '%-G%.%#%\r%.%\+'
line 1112: 
line 1113: function! s:Merge(cmd, bang, args) abort
line 1188: 
line 1189: " Section: Ggrep, Glog
line 1190: 
line 1191: if !exists('g:fugitive_summary_format')
line 1192:   let g:fugitive_summary_format = '%s'
line 1193: endif
line 1194: 
line 1195: call s:command("-bang -nargs=? -complete=customlist,s:EditComplete Ggrep :execute s:Grep('grep',<bang>0,<q-args>)")
calling function <SNR>33_command('-bang -nargs=? -complete=customlist,...ecute s:Grep(''grep'',<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1196: call s:command("-bang -nargs=? -complete=customlist,s:EditComplete Glgrep :execute s:Grep('lgrep',<bang>0,<q-args>)")
calling function <SNR>33_command('-bang -nargs=? -complete=customlist,...cute s:Grep(''lgrep'',<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1197: call s:command("-bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Glog :call s:Log('grep<bang>',<line1>,<count>,<f-args>)")
calling function <SNR>33_command('-bar -bang -nargs=* -range=0 -comple...'grep<bang>'',<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1198: call s:command("-bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Gllog :call s:Log('lgrep<bang>',<line1>,<count>,<f-args>)")
calling function <SNR>33_command('-bar -bang -nargs=* -range=0 -comple...lgrep<bang>'',<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1199: 
line 1200: function! s:Grep(cmd,bang,arg) abort
line 1238: 
line 1239: function! s:Log(cmd, line1, line2, ...) abort
line 1276: 
line 1277: " Section: Gedit, Gpedit, Gsplit, Gvsplit, Gtabedit, Gread
line 1278: 
line 1279: function! s:Edit(cmd,bang,...) abort
line 1355: 
line 1356: function! s:EditComplete(A,L,P) abort
line 1359: 
line 1360: function! s:EditRunComplete(A,L,P) abort
line 1367: 
line 1368: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Ge       :execute s:Edit('edit<bang>',0,<f-args>)")
calling function <SNR>33_command('-bar -bang -nargs=* -complete=custom...ecute s:Edit(''edit<bang>'',0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1369: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gedit    :execute s:Edit('edit<bang>',0,<f-args>)")
calling function <SNR>33_command('-bar -bang -nargs=* -complete=custom...ecute s:Edit(''edit<bang>'',0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1370: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gpedit   :execute s:Edit('pedit',<bang>0,<f-args>)")
calling function <SNR>33_command('-bar -bang -nargs=* -complete=custom...cute s:Edit(''pedit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1371: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gsplit   :execute s:Edit('split',<bang>0,<f-args>)")
calling function <SNR>33_command('-bar -bang -nargs=* -complete=custom...cute s:Edit(''split'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1372: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gvsplit  :execute s:Edit('vsplit',<bang>0,<f-args>)")
calling function <SNR>33_command('-bar -bang -nargs=* -complete=custom...ute s:Edit(''vsplit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1373: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gtabedit :execute s:Edit('tabedit',<bang>0,<f-args>)")
calling function <SNR>33_command('-bar -bang -nargs=* -complete=custom...te s:Edit(''tabedit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1374: call s:command("-bar -bang -nargs=* -count -complete=customlist,s:EditRunComplete Gread :execute s:Edit((!<count> && <line1> ? '' : <count>).'read',<bang>0,<f-args>)")
calling function <SNR>33_command('-bar -bang -nargs=* -count -complete...' : <count>).''read'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1375: 
line 1376: " Section: Gwrite, Gwq
line 1377: 
line 1378: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gwrite :execute s:Write(<bang>0,<f-args>)")
calling function <SNR>33_command('-bar -bang -nargs=* -complete=custom...rite :execute s:Write(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1379: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gw :execute s:Write(<bang>0,<f-args>)")
calling function <SNR>33_command('-bar -bang -nargs=* -complete=custom...e Gw :execute s:Write(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1380: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gwq :execute s:Wq(<bang>0,<f-args>)")
calling function <SNR>33_command('-bar -bang -nargs=* -complete=custom...ete Gwq :execute s:Wq(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1381: 
line 1382: function! s:Write(force,...) abort
line 1518: 
line 1519: function! s:Wq(force,...) abort
line 1531: 
line 1532: augroup fugitive_commit
line 1533:   autocmd!
line 1534:   autocmd VimLeavePre,BufDelete COMMIT_EDITMSG execute s:sub(s:FinishCommit(), '^echoerr (.*)', 'echohl ErrorMsg|echo \1|echohl NONE')
line 1535: augroup END
line 1536: 
line 1537: " Section: Gpush, Gfetch
line 1538: 
line 1539: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gpush  execute s:Dispatch('<bang>', 'push '.<q-args>)")
calling function <SNR>33_command('-nargs=? -bang -complete=custom,s:Re...ispatch(''<bang>'', ''push ''.<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1540: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gfetch execute s:Dispatch('<bang>', 'fetch '.<q-args>)")
calling function <SNR>33_command('-nargs=? -bang -complete=custom,s:Re...spatch(''<bang>'', ''fetch ''.<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1541: 
line 1542: function! s:Dispatch(bang, args)
line 1565: 
line 1566: " Section: Gdiff
line 1567: 
line 1568: call s:command("-bang -bar -nargs=* -complete=customlist,s:EditComplete Gdiff :execute s:Diff('',<f-args>)")
calling function <SNR>33_command('-bang -bar -nargs=* -complete=custom...te Gdiff :execute s:Diff('''',<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1569: call s:command("-bar -nargs=* -complete=customlist,s:EditComplete Gvdiff :execute s:Diff('keepalt vert ',<f-args>)")
calling function <SNR>33_command('-bar -nargs=* -complete=customlist,s...cute s:Diff(''keepalt vert '',<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1570: call s:command("-bar -nargs=* -complete=customlist,s:EditComplete Gsdiff :execute s:Diff('keepalt ',<f-args>)")
calling function <SNR>33_command('-bar -nargs=* -complete=customlist,s... :execute s:Diff(''keepalt '',<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1571: 
line 1572: augroup fugitive_diff
line 1573:   autocmd!
line 1577:   autocmd BufWinLeave * if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif
line 1581:   autocmd BufWinEnter * if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif
line 1582: augroup END
line 1583: 
line 1584: function! s:can_diffoff(buf) abort
line 1589: 
line 1590: function! fugitive#can_diffoff(buf) abort
line 1593: 
line 1594: function! s:diff_modifier(count) abort
line 1606: 
line 1607: function! s:diff_window_count() abort
line 1614: 
line 1615: function! s:diff_restore() abort
line 1629: 
line 1630: function! s:diffthis() abort
line 1636: 
line 1637: function! s:diffoff() abort
line 1645: 
line 1646: function! s:diffoff_all(dir) abort
line 1659: 
line 1660: function! s:buffer_compare_age(commit) dict abort
line 1679: 
line 1680: call s:add_methods('buffer',['compare_age'])
calling function <SNR>33_add_methods('buffer', ['compare_age'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:buffer_compare_age')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_buffer_compare_age')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>33_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 1681: 
line 1682: function! s:Diff(vert,...) abort
line 1746: 
line 1747: " Section: Gmove, Gremove
line 1748: 
line 1749: function! s:Move(force,destination) abort
line 1782: 
line 1783: function! s:MoveComplete(A,L,P) abort
line 1792: 
line 1793: function! s:Remove(force) abort
line 1814: 
line 1815: augroup fugitive_remove
line 1816:   autocmd!
line 1820:   autocmd User Fugitive if s:buffer().commit() =~# '^0\=$' | exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif
line 1821: augroup END
line 1822: 
line 1823: " Section: Gblame
line 1824: 
line 1825: augroup fugitive_blame
line 1826:   autocmd!
line 1827:   autocmd BufReadPost *.fugitiveblame setfiletype fugitiveblame
line 1828:   autocmd FileType fugitiveblame setlocal nomodeline | if exists('b:git_dir') | let &l:keywordprg = s:repo().keywordprg() | endif
line 1829:   autocmd Syntax fugitiveblame call s:BlameSyntax()
line 1830:   autocmd User Fugitive if s:buffer().type('file', 'blob') | exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif
line 1831:   autocmd ColorScheme,GUIEnter * call s:RehighlightBlame()
line 1832: augroup END
line 1833: 
line 1834: function! s:linechars(pattern) abort
line 1843: 
line 1844: function! s:Blame(bang,line1,line2,count,args) abort
line 1959: 
line 1960: function! s:BlameCommit(cmd) abort
line 2000: 
line 2001: function! s:BlameJump(suffix) abort
line 2034: 
line 2035: let s:hash_colors = {}
line 2036: 
line 2037: function! s:BlameSyntax() abort
line 2085: 
line 2086: function! s:RehighlightBlame() abort
line 2095: 
line 2096: " Section: Gbrowse
line 2097: 
line 2098: call s:command("-bar -bang -range -nargs=* -complete=customlist,s:EditComplete Gbrowse :execute s:Browse(<bang>0,<line1>,<count>,<f-args>)")
calling function <SNR>33_command('-bar -bang -range -nargs=* -complete...rowse(<bang>0,<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>33_command returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 2099: 
line 2100: function! s:Browse(bang,line1,count,...) abort
line 2211: 
line 2212: function! s:github_url(opts, ...) abort
line 2273: 
line 2274: function! s:instaweb_url(opts) abort
line 2314: 
line 2315: if !exists('g:fugitive_browse_handlers')
line 2316:   let g:fugitive_browse_handlers = []
line 2317: endif
line 2318: 
line 2320: call extend(g:fugitive_browse_handlers, [s:function('s:github_url'), s:function('s:instaweb_url')])
calling function <SNR>33_function('s:github_url')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_function returning function('<SNR>33_github_url')

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

calling function <SNR>33_function('s:instaweb_url')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_function returning function('<SNR>33_instaweb_url')

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 2321: 
line 2322: " Section: File access
line 2323: 
line 2324: function! s:ReplaceCmd(cmd,...) abort
line 2363: 
line 2364: function! s:BufReadIndex() abort
line 2439: 
line 2440: function! s:FileRead() abort
line 2456: 
line 2457: function! s:BufReadIndexFile() abort
line 2477: 
line 2478: function! s:BufWriteIndexFile() abort
line 2508: 
line 2509: function! s:BufReadObject() abort
line 2590: 
line 2591: augroup fugitive_files
line 2592:   autocmd!
line 2599:   autocmd BufReadCmd  index{,.lock} if fugitive#is_git_dir(expand('<amatch>:p:h')) |   exe s:BufReadIndex() | elseif filereadable(expand('<amatch>')) |   read <amatch> |   1delete | endif
line 2600:   autocmd FileReadCmd fugitive://**//[0-3]/**          exe s:FileRead()
line 2601:   autocmd BufReadCmd  fugitive://**//[0-3]/**          exe s:BufReadIndexFile()
line 2602:   autocmd BufWriteCmd fugitive://**//[0-3]/**          exe s:BufWriteIndexFile()
line 2603:   autocmd BufReadCmd  fugitive://**//[0-9a-f][0-9a-f]* exe s:BufReadObject()
line 2604:   autocmd FileReadCmd fugitive://**//[0-9a-f][0-9a-f]* exe s:FileRead()
line 2608:   autocmd FileType git if exists('b:git_dir') |  call s:JumpInit() | endif
line 2609: augroup END
line 2610: 
line 2611: " Section: Temp files
line 2612: 
line 2613: if !exists('s:temp_files')
line 2614:   let s:temp_files = {}
line 2615: endif
line 2616: 
line 2617: augroup fugitive_temp
line 2618:   autocmd!
line 2627:   autocmd BufNewFile,BufReadPost * if has_key(s:temp_files,tolower(expand('<afile>:p'))) |   let b:git_dir = s:temp_files[tolower(expand('<afile>:p'))].dir |   let b:git_type = 'temp' |   let b:git_args = s:temp_files[tolower(expand('<afile>:p'))].args |   call fugitive#detect(expand('<afile>:p')) |   setlocal bufhidden=delete nobuflisted |   nnoremap <buffer> <silent> q    :<C-U>bdelete<CR>| endif
line 2628: augroup END
line 2629: 
line 2630: " Section: Go to file
line 2631: 
line 2632: function! s:JumpInit() abort
line 2650: 
line 2651: function! s:GF(mode) abort
line 2822: 
line 2823: " Section: Statusline
line 2824: 
line 2825: function! s:repo_head_ref() dict abort
line 2831: 
line 2832: call s:add_methods('repo',['head_ref'])
calling function <SNR>33_add_methods('repo', ['head_ref'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>33_add_methods..<SNR>33_function('s:repo_head_ref')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>33_add_methods..<SNR>33_function returning function('<SNR>33_repo_head_ref')

continuing in function <SNR>33_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>33_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim

line 2833: 
line 2834: function! fugitive#statusline(...) abort
line 2849: 
line 2850: function! fugitive#head(...) abort
line 2857: 
line 2858: " Section: Folding
line 2859: 
line 2860: function! fugitive#foldtext() abort
line 2898: 
line 2899: augroup fugitive_foldtext
line 2900:   autocmd!
line 2904:   autocmd User Fugitive if &filetype =~# '^git\%(commit\)\=$' && &foldtext ==# 'foldtext()' |    set foldtext=fugitive#foldtext() | endif
line 2905: augroup END
finished sourcing /home/max/.vim/bundle/vim-fugitive/plugin/fugitive.vim
Searching for "/home/max/.vim/bundle/vim-easymotion/plugin/**/*.vim"
chdir(/home/max/.vim/bundle/vim-easymotion/plugin)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/vim-easymotion/plugin/EasyMotion.vim"
line 1: scriptencoding utf-8
line 2: " EasyMotion - Vim motions on speed!
line 3: "
line 4: " Author: Kim Silkebkken <kim.silkebaekken+vim@gmail.com>
line 5: "         haya14busa <hayabusa1419@gmail.com>
line 6: " Source: https://github.com/Lokaltog/vim-easymotion
line 7: " == Script initialization {{{
line 8: if expand("%:p") ==# expand("<sfile>:p")
line 9:   unlet! g:EasyMotion_loaded
line 10: endif
line 11: if exists('g:EasyMotion_loaded') || &compatible || version < 703
line 12:     finish
line 13: endif
line 14: 
line 15: let g:EasyMotion_loaded = 1
line 16: " }}}
line 17: 
line 18: " == Saving 'cpoptions' {{{
line 19: let s:save_cpo = &cpo
line 20: set cpo&vim
line 21: " }}}
line 22: 
line 23: " == Default configuration {{{
line 24: " -- Option ------------------------------ {{{
line 26: let g:EasyMotion_keys               = get(g:, 'EasyMotion_keys', 'asdghklqwertyuiopzxcvbnmfj;')
line 27:     " \ 'EasyMotion_keys', 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
line 28: let g:EasyMotion_do_mapping         = get(g: , 'EasyMotion_do_mapping'         , 1)
line 29: let g:EasyMotion_do_shade           = get(g: , 'EasyMotion_do_shade'           , 1)
line 30: let g:EasyMotion_grouping           = get(g: , 'EasyMotion_grouping'           , 1)
line 31: let g:EasyMotion_startofline        = get(g: , 'EasyMotion_startofline'        , 1)
line 32: let g:EasyMotion_smartcase          = get(g: , 'EasyMotion_smartcase'          , 0)
line 33: let g:EasyMotion_skipfoldedline     = get(g: , 'EasyMotion_skipfoldedline'     , 1)
line 34: let g:EasyMotion_use_migemo         = get(g: , 'EasyMotion_use_migemo'         , 0)
line 35: let g:EasyMotion_use_upper          = get(g: , 'EasyMotion_use_upper'          , 0)
line 36: let g:EasyMotion_enter_jump_first   = get(g: , 'EasyMotion_enter_jump_first'   , 0)
line 37: let g:EasyMotion_space_jump_first   = get(g: , 'EasyMotion_space_jump_first'   , 0)
line 38: let g:EasyMotion_inc_highlight      = get(g: , 'EasyMotion_inc_highlight'      , 1)
line 39: let g:EasyMotion_move_highlight     = get(g: , 'EasyMotion_move_highlight'     , 1)
line 40: let g:EasyMotion_landing_highlight  = get(g: , 'EasyMotion_landing_highlight'  , 0)
line 41: let g:EasyMotion_cursor_highlight   = get(g: , 'EasyMotion_cursor_highlight'   , 1)
line 42: let g:EasyMotion_use_regexp         = get(g: , 'EasyMotion_use_regexp'         , 1)
line 43: let g:EasyMotion_add_search_history = get(g: , 'EasyMotion_add_search_history' , 1)
line 44: let g:EasyMotion_off_screen_search  = get(g: , 'EasyMotion_off_screen_search'  , 1)
line 45: let g:EasyMotion_force_csapprox     = get(g: , 'EasyMotion_force_csapprox'     , 0)
line 46: let g:EasyMotion_show_prompt        = get(g: , 'EasyMotion_show_prompt'        , 1)
line 48: let g:EasyMotion_prompt             = get(g: , 'EasyMotion_prompt' , 'Search for {n} character(s): ')
line 50: let g:EasyMotion_command_line_key_mappings = get(g: , 'EasyMotion_command_line_key_mappings' , {})
line 52: let g:EasyMotion_disable_two_key_combo     = get(g: , 'EasyMotion_disable_two_key_combo' , 0)
line 53: 
line 54: "}}}
line 55: 
line 56: " }}}
line 57: 
line 58: " == <Plug> Mapping {{{
line 59: " Note: bd is short for bidirectional
line 60: "       l is short for (within) line
line 61: 
line 62: function! s:find_motion_map_helper(motions) "{{{
line 73: " Find Motion: {{{
line 119: call s:find_motion_map_helper({ 'f'      : {'fnc' : 'S' , 'cnt' : 1, 'direction'  : 0}, 'F'      : {'fnc' : 'S' , 'cnt' : 1, 'direction'  : 1}, 's'      : {'fnc' : 'S' , 'cnt' : 1, 'direction'  : 2}, 'bd-f'   : {'fnc' : 'S' , 'cnt' : 1, 'direction'  : 2}, 't'      : {'fnc' : 'T' , 'cnt' : 1, 'direction'  : 0}, 'T'      : {'fnc' : 'T' , 'cnt' : 1, 'direction'  : 1}, 'bd-t'   : {'fnc' : 'T' , 'cnt' : 1, 'direction'  : 2}, 'fl'     : {'fnc' : 'SL', 'cnt' : 1, 'direction'  : 0}, 'Fl'     : {'fnc' : 'SL', 'cnt' : 1, 'direction'  : 1}, 'sl'     : {'fnc' : 'SL', 'cnt' : 1, 'direction'  : 2}, 'bd-fl'  : {'fnc' : 'SL', 'cnt' : 1, 'direction'  : 2}, 'tl'     : {'fnc' : 'TL', 'cnt' : 1, 'direction'  : 0}, 'Tl'     : {'fnc' : 'TL', 'cnt' : 1, 'direction'  : 1}, 'bd-tl'  : {'fnc' : 'TL', 'cnt' : 1, 'direction'  : 2}, 'f2'     : {'fnc' : 'S' , 'cnt' : 2, 'direction'  : 0}, 'F2'     : {'fnc' : 'S' , 'cnt' : 2, 'direction'  : 1}, 's2'     : {'fnc' : 'S' , 'cnt' : 2, 'direction'  : 2}, 'bd-f2'  : {'fnc' : 'S' , 'cnt
calling function <SNR>34_find_motion_map_helper({'fln': {'cnt': -1, 'direction': 0, '...'cnt': -1, 'direction': 1, 'fnc': 'TL'}})

line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-fln)      :<C-u>call EasyMotion#SL(-1,0,0)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-fln) <Esc>:<C-u>call EasyMotion#SL(-1,1,0)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-Tl2)      :<C-u>call EasyMotion#TL(2,0,1)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-Tl2) <Esc>:<C-u>call EasyMotion#TL(2,1,1)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-bd-f2)      :<C-u>call EasyMotion#S(2,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-bd-f2) <Esc>:<C-u>call EasyMotion#S(2,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-F2)      :<C-u>call EasyMotion#S(2,0,1)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-F2) <Esc>:<C-u>call EasyMotion#S(2,1,1)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-bd-f)      :<C-u>call EasyMotion#S(1,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-bd-f) <Esc>:<C-u>call EasyMotion#S(1,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-F)      :<C-u>call EasyMotion#S(1,0,1)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-F) <Esc>:<C-u>call EasyMotion#S(1,1,1)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-bd-fln)      :<C-u>call EasyMotion#SL(-1,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-bd-fln) <Esc>:<C-u>call EasyMotion#SL(-1,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-sl2)      :<C-u>call EasyMotion#SL(2,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-sl2) <Esc>:<C-u>call EasyMotion#SL(2,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-Fl)      :<C-u>call EasyMotion#SL(1,0,1)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-Fl) <Esc>:<C-u>call EasyMotion#SL(1,1,1)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-sl)      :<C-u>call EasyMotion#SL(1,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-sl) <Esc>:<C-u>call EasyMotion#SL(1,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-Fn)      :<C-u>call EasyMotion#S(-1,0,1)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-Fn) <Esc>:<C-u>call EasyMotion#S(-1,1,1)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-sn)      :<C-u>call EasyMotion#S(-1,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-sn) <Esc>:<C-u>call EasyMotion#S(-1,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-Tl)      :<C-u>call EasyMotion#TL(1,0,1)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-Tl) <Esc>:<C-u>call EasyMotion#TL(1,1,1)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-s2)      :<C-u>call EasyMotion#S(2,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-s2) <Esc>:<C-u>call EasyMotion#S(2,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-Tn)      :<C-u>call EasyMotion#T(-1,0,1)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-Tn) <Esc>:<C-u>call EasyMotion#T(-1,1,1)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-bd-t)      :<C-u>call EasyMotion#T(1,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-bd-t) <Esc>:<C-u>call EasyMotion#T(1,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-T)      :<C-u>call EasyMotion#T(1,0,1)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-T) <Esc>:<C-u>call EasyMotion#T(1,1,1)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-bd-tln)      :<C-u>call EasyMotion#TL(-1,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-bd-tln) <Esc>:<C-u>call EasyMotion#TL(-1,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-T2)      :<C-u>call EasyMotion#T(2,0,1)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-T2) <Esc>:<C-u>call EasyMotion#T(2,1,1)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-bd-fl2)      :<C-u>call EasyMotion#SL(2,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-bd-fl2) <Esc>:<C-u>call EasyMotion#SL(2,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-fl2)      :<C-u>call EasyMotion#SL(2,0,0)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-fl2) <Esc>:<C-u>call EasyMotion#SL(2,1,0)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-tln)      :<C-u>call EasyMotion#TL(-1,0,0)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-tln) <Esc>:<C-u>call EasyMotion#TL(-1,1,0)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-sln)      :<C-u>call EasyMotion#SL(-1,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-sln) <Esc>:<C-u>call EasyMotion#SL(-1,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-Fln)      :<C-u>call EasyMotion#SL(-1,0,1)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-Fln) <Esc>:<C-u>call EasyMotion#SL(-1,1,1)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-f2)      :<C-u>call EasyMotion#S(2,0,0)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-tl2)      :<C-u>call EasyMotion#TL(2,0,0)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-tl2) <Esc>:<C-u>call EasyMotion#TL(2,1,0)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-Fl2)      :<C-u>call EasyMotion#SL(2,0,1)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-Fl2) <Esc>:<C-u>call EasyMotion#SL(2,1,1)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-bd-fl)      :<C-u>call EasyMotion#SL(1,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-bd-fl) <Esc>:<C-u>call EasyMotion#SL(1,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-f)      :<C-u>call EasyMotion#S(1,0,0)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-f) <Esc>:<C-u>call EasyMotion#S(1,1,0)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-bd-fn)      :<C-u>call EasyMotion#S(-1,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-bd-fn) <Esc>:<C-u>call EasyMotion#S(-1,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-bd-tl2)      :<C-u>call EasyMotion#TL(2,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-bd-tl2) <Esc>:<C-u>call EasyMotion#TL(2,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-fl)      :<C-u>call EasyMotion#SL(1,0,0)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-fl) <Esc>:<C-u>call EasyMotion#SL(1,1,0)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-bd-tl)      :<C-u>call EasyMotion#TL(1,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-bd-tl) <Esc>:<C-u>call EasyMotion#TL(1,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-fn)      :<C-u>call EasyMotion#S(-1,0,0)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-fn) <Esc>:<C-u>call EasyMotion#S(-1,1,0)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-bd-tn)      :<C-u>call EasyMotion#T(-1,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-bd-tn) <Esc>:<C-u>call EasyMotion#T(-1,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-tl)      :<C-u>call EasyMotion#TL(1,0,0)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-tl) <Esc>:<C-u>call EasyMotion#TL(1,1,0)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-bd-t2)      :<C-u>call EasyMotion#T(2,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-bd-t2) <Esc>:<C-u>call EasyMotion#T(2,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-tn)      :<C-u>call EasyMotion#T(-1,0,0)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-tn) <Esc>:<C-u>call EasyMotion#T(-1,1,0)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-s)      :<C-u>call EasyMotion#S(1,0,2)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-s) <Esc>:<C-u>call EasyMotion#S(1,1,2)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-t)      :<C-u>call EasyMotion#T(1,0,0)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-t) <Esc>:<C-u>call EasyMotion#T(1,1,0)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-t2)      :<C-u>call EasyMotion#T(2,0,0)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-t2) <Esc>:<C-u>call EasyMotion#T(2,1,0)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 2: noremap  <silent><Plug>(easymotion-Tln)      :<C-u>call EasyMotion#TL(-1,0,1)<CR>
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 4: xnoremap <silent><Plug>(easymotion-Tln) <Esc>:<C-u>call EasyMotion#TL(-1,1,1)<CR>
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
line 1:     for [name, dict] in items(a:motions)
line 2:         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',0,'. dict.direction .')<CR>'
line 4:         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#'. dict.fnc .'('. dict.cnt .',1,'. dict.direction .')<CR>'
line 6:     " Example:
line 7:     " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
line 8:     " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
line 9:     endfor
function <SNR>34_find_motion_map_helper returning #0

continuing in /home/max/.vim/bundle/vim-easymotion/plugin/EasyMotion.vim

line 120: "}}}
line 121: 
line 122: " -- Word Motion {{{
line 123: " Word: {{{
line 124: noremap  <silent><Plug>(easymotion-w)          :<C-u>call EasyMotion#WB(0,0)<CR>
line 125: xnoremap <silent><Plug>(easymotion-w)     <Esc>:<C-u>call EasyMotion#WB(1,0)<CR>
line 126: noremap  <silent><Plug>(easymotion-b)          :<C-u>call EasyMotion#WB(0,1)<CR>
line 127: xnoremap <silent><Plug>(easymotion-b)     <Esc>:<C-u>call EasyMotion#WB(1,1)<CR>
line 128: noremap  <silent><Plug>(easymotion-bd-w)       :<C-u>call EasyMotion#WB(0,2)<CR>
line 129: xnoremap <silent><Plug>(easymotion-bd-w)  <Esc>:<C-u>call EasyMotion#WB(1,2)<CR>
line 130: "}}}
line 131: 
line 132: " WORD: {{{
line 133: noremap  <silent><Plug>(easymotion-W)         :<C-u>call EasyMotion#WBW(0,0)<CR>
line 134: xnoremap <silent><Plug>(easymotion-W)    <Esc>:<C-u>call EasyMotion#WBW(1,0)<CR>
line 135: noremap  <silent><Plug>(easymotion-B)         :<C-u>call EasyMotion#WBW(0,1)<CR>
line 136: xnoremap <silent><Plug>(easymotion-B)    <Esc>:<C-u>call EasyMotion#WBW(1,1)<CR>
line 137: noremap  <silent><Plug>(easymotion-bd-W)      :<C-u>call EasyMotion#WBW(0,2)<CR>
line 138: xnoremap <silent><Plug>(easymotion-bd-W) <Esc>:<C-u>call EasyMotion#WBW(1,2)<CR>
line 139: "}}}
line 140: 
line 141: " iskeyword {{{
line 142: noremap  <silent><Plug>(easymotion-iskeyword-w)         :<C-u>call EasyMotion#WBK(0,0)<CR>
line 143: xnoremap <silent><Plug>(easymotion-iskeyword-w)    <Esc>:<C-u>call EasyMotion#WBK(1,0)<CR>
line 144: noremap  <silent><Plug>(easymotion-iskeyword-b)         :<C-u>call EasyMotion#WBK(0,1)<CR>
line 145: xnoremap <silent><Plug>(easymotion-iskeyword-b)    <Esc>:<C-u>call EasyMotion#WBK(1,1)<CR>
line 146: noremap  <silent><Plug>(easymotion-iskeyword-bd-w)      :<C-u>call EasyMotion#WBK(0,2)<CR>
line 147: xnoremap <silent><Plug>(easymotion-iskeyword-bd-w) <Esc>:<C-u>call EasyMotion#WBK(1,2)<CR>
line 148: " }}}
line 149: 
line 150: " End Word: {{{
line 151: noremap  <silent><Plug>(easymotion-e)         :<C-u>call EasyMotion#E(0,0)<CR>
line 152: xnoremap <silent><Plug>(easymotion-e)    <Esc>:<C-u>call EasyMotion#E(1,0)<CR>
line 153: noremap  <silent><Plug>(easymotion-ge)        :<C-u>call EasyMotion#E(0,1)<CR>
line 154: xnoremap <silent><Plug>(easymotion-ge)   <Esc>:<C-u>call EasyMotion#E(1,1)<CR>
line 155: noremap  <silent><Plug>(easymotion-bd-e)      :<C-u>call EasyMotion#E(0,2)<CR>
line 156: xnoremap <silent><Plug>(easymotion-bd-e) <Esc>:<C-u>call EasyMotion#E(1,2)<CR>
line 157: "}}}
line 158: 
line 159: " END WORD: {{{
line 160: noremap  <silent><Plug>(easymotion-E)         :<C-u>call EasyMotion#EW(0,0)<CR>
line 161: xnoremap <silent><Plug>(easymotion-E)    <Esc>:<C-u>call EasyMotion#EW(1,0)<CR>
line 162: noremap  <silent><Plug>(easymotion-gE)        :<C-u>call EasyMotion#EW(0,1)<CR>
line 163: xnoremap <silent><Plug>(easymotion-gE)   <Esc>:<C-u>call EasyMotion#EW(1,1)<CR>
line 164: noremap  <silent><Plug>(easymotion-bd-E)      :<C-u>call EasyMotion#EW(0,2)<CR>
line 165: xnoremap <silent><Plug>(easymotion-bd-E) <Esc>:<C-u>call EasyMotion#EW(1,2)<CR>
line 166: "}}}
line 167: 
line 168: " iskeyword End: {{{
line 169: noremap  <silent><Plug>(easymotion-iskeyword-e)         :<C-u>call EasyMotion#EK(0,0)<CR>
line 170: xnoremap <silent><Plug>(easymotion-iskeyword-e)    <Esc>:<C-u>call EasyMotion#EK(1,0)<CR>
line 171: noremap  <silent><Plug>(easymotion-iskeyword-ge)        :<C-u>call EasyMotion#EK(0,1)<CR>
line 172: xnoremap <silent><Plug>(easymotion-iskeyword-ge)   <Esc>:<C-u>call EasyMotion#EK(1,1)<CR>
line 173: noremap  <silent><Plug>(easymotion-iskeyword-bd-e)      :<C-u>call EasyMotion#EK(0,2)<CR>
line 174: xnoremap <silent><Plug>(easymotion-iskeyword-bd-e) <Esc>:<C-u>call EasyMotion#EK(1,2)<CR>
line 175: "}}}
line 176: "}}}
line 177: 
line 178: " -- JK Motion {{{
line 179: noremap  <silent><Plug>(easymotion-j)          :<C-u>call EasyMotion#JK(0,0)<CR>
line 180: xnoremap <silent><Plug>(easymotion-j)     <Esc>:<C-u>call EasyMotion#JK(1,0)<CR>
line 181: noremap  <silent><Plug>(easymotion-k)          :<C-u>call EasyMotion#JK(0,1)<CR>
line 182: xnoremap <silent><Plug>(easymotion-k)     <Esc>:<C-u>call EasyMotion#JK(1,1)<CR>
line 183: noremap  <silent><Plug>(easymotion-bd-jk)      :<C-u>call EasyMotion#JK(0,2)<CR>
line 184: xnoremap <silent><Plug>(easymotion-bd-jk) <Esc>:<C-u>call EasyMotion#JK(1,2)<CR>
line 185: 
line 186: " Start of Line JK {{{
line 187: noremap  <silent><Plug>(easymotion-sol-j)          :<C-u>call EasyMotion#Sol(0,0)<CR>
line 188: xnoremap <silent><Plug>(easymotion-sol-j)     <Esc>:<C-u>call EasyMotion#Sol(1,0)<CR>
line 189: noremap  <silent><Plug>(easymotion-sol-k)          :<C-u>call EasyMotion#Sol(0,1)<CR>
line 190: xnoremap <silent><Plug>(easymotion-sol-k)     <Esc>:<C-u>call EasyMotion#Sol(1,1)<CR>
line 191: noremap  <silent><Plug>(easymotion-sol-bd-jk)      :<C-u>call EasyMotion#Sol(0,2)<CR>
line 192: xnoremap <silent><Plug>(easymotion-sol-bd-jk) <Esc>:<C-u>call EasyMotion#Sol(1,2)<CR>
line 193: "}}}
line 194: 
line 195: " End of Line JK {{{
line 196: noremap  <silent><Plug>(easymotion-eol-j)          :<C-u>call EasyMotion#Eol(0,0)<CR>
line 197: xnoremap <silent><Plug>(easymotion-eol-j)     <Esc>:<C-u>call EasyMotion#Eol(1,0)<CR>
line 198: noremap  <silent><Plug>(easymotion-eol-k)          :<C-u>call EasyMotion#Eol(0,1)<CR>
line 199: xnoremap <silent><Plug>(easymotion-eol-k)     <Esc>:<C-u>call EasyMotion#Eol(1,1)<CR>
line 200: noremap  <silent><Plug>(easymotion-eol-bd-jk)      :<C-u>call EasyMotion#Eol(0,2)<CR>
line 201: xnoremap <silent><Plug>(easymotion-eol-bd-jk) <Esc>:<C-u>call EasyMotion#Eol(1,2)<CR>
line 202: "}}}
line 203: 
line 204: "}}}
line 205: 
line 206: " -- Search Motion {{{
line 207: noremap  <silent><Plug>(easymotion-n)         :<C-u>call EasyMotion#Search(0,0,0)<CR>
line 208: xnoremap <silent><Plug>(easymotion-n)    <Esc>:<C-u>call EasyMotion#Search(1,0,0)<CR>
line 209: noremap  <silent><Plug>(easymotion-N)         :<C-u>call EasyMotion#Search(0,1,0)<CR>
line 210: xnoremap <silent><Plug>(easymotion-N)    <Esc>:<C-u>call EasyMotion#Search(1,1,0)<CR>
line 211: 
line 212: noremap  <silent><Plug>(easymotion-vim-n)      :<C-u>call EasyMotion#Search(0,0,1)<CR>
line 213: xnoremap <silent><Plug>(easymotion-vim-n) <Esc>:<C-u>call EasyMotion#Search(1,0,1)<CR>
line 214: noremap  <silent><Plug>(easymotion-vim-N)      :<C-u>call EasyMotion#Search(0,1,1)<CR>
line 215: xnoremap <silent><Plug>(easymotion-vim-N) <Esc>:<C-u>call EasyMotion#Search(1,1,1)<CR>
line 216: 
line 217: noremap  <silent><Plug>(easymotion-bd-n)      :<C-u>call EasyMotion#Search(0,2,0)<CR>
line 218: xnoremap <silent><Plug>(easymotion-bd-n) <Esc>:<C-u>call EasyMotion#Search(1,2,0)<CR>
line 219: "}}}
line 220: 
line 221: " -- Jump To Anywhere Motion {{{
line 223: noremap  <silent><Plug>(easymotion-jumptoanywhere)      :<C-u>call EasyMotion#JumpToAnywhere(0,2)<CR>
line 225: xnoremap <silent><Plug>(easymotion-jumptoanywhere) <Esc>:<C-u>call EasyMotion#JumpToAnywhere(1,2)<CR>
line 226: "}}}
line 227: 
line 228: " -- Repeat Motion {{{
line 230: noremap  <silent><Plug>(easymotion-repeat)      :<C-u>call EasyMotion#Repeat(0)<CR>
line 232: xnoremap <silent><Plug>(easymotion-repeat) <Esc>:<C-u>call EasyMotion#Repeat(1)<CR>
line 233: 
line 235: noremap  <silent><Plug>(easymotion-dotrepeat)      :<C-u>call EasyMotion#DotRepeat()<CR>
line 236: "}}}
line 237: 
line 238: " -- Next,Previous Motion {{{
line 240: noremap  <silent><Plug>(easymotion-next)      :<C-u>call EasyMotion#NextPrevious(0,0)<CR>
line 242: xnoremap <silent><Plug>(easymotion-next)      :<C-u>call EasyMotion#NextPrevious(1,0)<CR>
line 243: 
line 245: noremap  <silent><Plug>(easymotion-prev)      :<C-u>call EasyMotion#NextPrevious(0,1)<CR>
line 247: xnoremap <silent><Plug>(easymotion-prev)      :<C-u>call EasyMotion#NextPrevious(1,1)<CR>
line 248: "}}}
line 249: 
line 250: " -- Line Motion {{{
line 251: " Word Line: {{{
line 252: noremap  <silent><Plug>(easymotion-wl)         :<C-u>call EasyMotion#WBL(0,0)<CR>
line 253: xnoremap <silent><Plug>(easymotion-wl)    <Esc>:<C-u>call EasyMotion#WBL(1,0)<CR>
line 254: noremap  <silent><Plug>(easymotion-bl)         :<C-u>call EasyMotion#WBL(0,1)<CR>
line 255: xnoremap <silent><Plug>(easymotion-bl)    <Esc>:<C-u>call EasyMotion#WBL(1,1)<CR>
line 256: noremap  <silent><Plug>(easymotion-bd-wl)      :<C-u>call EasyMotion#WBL(0,2)<CR>
line 257: xnoremap <silent><Plug>(easymotion-bd-wl) <Esc>:<C-u>call EasyMotion#WBL(1,2)<CR>
line 258: "}}}
line 259: 
line 260: " End Word Line: {{{
line 261: noremap  <silent><Plug>(easymotion-el)         :<C-u>call EasyMotion#EL(0,0)<CR>
line 262: xnoremap <silent><Plug>(easymotion-el)    <Esc>:<C-u>call EasyMotion#EL(1,0)<CR>
line 263: noremap  <silent><Plug>(easymotion-gel)        :<C-u>call EasyMotion#EL(0,1)<CR>
line 264: xnoremap <silent><Plug>(easymotion-gel)   <Esc>:<C-u>call EasyMotion#EL(1,1)<CR>
line 265: noremap  <silent><Plug>(easymotion-bd-el)      :<C-u>call EasyMotion#EL(0,2)<CR>
line 266: xnoremap <silent><Plug>(easymotion-bd-el) <Esc>:<C-u>call EasyMotion#EL(1,2)<CR>
line 267: "}}}
line 268: 
line 269: " LineAnywhere Line: {{{
line 271: noremap  <silent><Plug>(easymotion-lineforward)      :<C-u>call EasyMotion#LineAnywhere(0,0)<CR>
line 273: xnoremap <silent><Plug>(easymotion-lineforward) <Esc>:<C-u>call EasyMotion#LineAnywhere(1,0)<CR>
line 274: 
line 276: noremap  <silent><Plug>(easymotion-linebackward)      :<C-u>call EasyMotion#LineAnywhere(0,1)<CR>
line 278: xnoremap <silent><Plug>(easymotion-linebackward) <Esc>:<C-u>call EasyMotion#LineAnywhere(1,1)<CR>
line 279: 
line 281: noremap  <silent><Plug>(easymotion-lineanywhere)      :<C-u>call EasyMotion#LineAnywhere(0,2)<CR>
line 283: xnoremap <silent><Plug>(easymotion-lineanywhere) <Esc>:<C-u>call EasyMotion#LineAnywhere(1,2)<CR>
line 284: 
line 285: "}}}
line 286: "}}}
line 287: 
line 288: noremap  <silent><Plug>(easymotion-activate) :<C-u>call EasyMotion#activate(0)<CR>
line 289: xnoremap <silent><Plug>(easymotion-activate) :<C-u>call EasyMotion#activate(1)<CR>
line 290: 
line 291: " }}}
line 292: 
line 293: " == Default key mapping {{{
line 294: if g:EasyMotion_do_mapping == 1
line 295:     " Prepare Prefix: {{{
line 296:     if exists('g:EasyMotion_leader_key')
line 297:         exec 'map ' . g:EasyMotion_leader_key . ' <Plug>(easymotion-prefix)'
line 298:     else
line 299:         if !hasmapto('<Plug>(easymotion-prefix)')
line 300:             map <Leader><Leader> <Plug>(easymotion-prefix)
line 301:         endif
line 302:     endif
line 303:     "}}}
line 304: 
line 305:     function! s:default_mapping(motions, do_mapping) "{{{
line 322: 
line 323:     " Default Mapping:
line 327:     call s:default_mapping( ['f', 'F', 's', 't', 'T',  'w', 'W', 'b', 'B', 'e', 'E', 'ge', 'gE',  'j', 'k', 'n', 'N'], g:EasyMotion_do_mapping)
line 328: endif "}}}
line 329: 
line 330: " == CommandLine Mapping {{{
line 333: command! -nargs=*   EMCommandLineNoreMap   call EasyMotion#command_line#cnoremap([<f-args>])
line 336: command! -nargs=*   EMCommandLineMap   call EasyMotion#command_line#cmap([<f-args>])
line 339: command! -nargs=1   EMCommandLineUnMap   call EasyMotion#command_line#cunmap(<f-args>)
line 340: "}}}
line 341: 
line 342: " == Restore 'cpoptions' {{{
line 343: let &cpo = s:save_cpo
line 344: unlet s:save_cpo
line 345: " }}}
line 346: " vim: fdm=marker:et:ts=4:sw=4:sts=4
finished sourcing /home/max/.vim/bundle/vim-easymotion/plugin/EasyMotion.vim
Searching for "/home/max/.vim/bundle/vim-rails/plugin/**/*.vim"
chdir(/home/max/.vim/bundle/vim-rails/plugin)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/vim-rails/plugin/rails.vim"
line 1: " rails.vim - Detect a rails application
line 2: " Author:       Tim Pope <http://tpo.pe/>
line 3: " GetLatestVimScripts: 1567 1 :AutoInstall: rails.vim
line 4: 
line 5: " Install this file as plugin/rails.vim.
line 6: 
line 7: if exists('g:loaded_rails') || &cp || v:version < 700
line 8:   finish
line 9: endif
line 10: let g:loaded_rails = 1
line 11: 
line 12: " Utility Functions {{{1
line 13: 
line 14: function! s:error(str)
line 20: 
line 21: " }}}1
line 22: " Detection {{{1
line 23: 
line 24: function! RailsDetect(...) abort
line 38: 
line 39: " }}}1
line 40: " Initialization {{{1
line 41: 
line 42: if !exists('g:did_load_ftplugin')
line 43:   filetype plugin on
line 44: endif
line 45: if !exists('g:loaded_projectionist')
line 46:   runtime! plugin/projectionist.vim
Searching for "plugin/projectionist.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/Fuz
Searching for "/home/max/.vim/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/vundle/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/vim-rails/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/L9/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/command-t/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/syntastic/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/vim-golang/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/google.vim/plugin/projectionist.vim"
Searching for "/var/lib/vim/addons/plugin/projectionist.vim"
Searching for "/usr/share/vim/vimfiles/plugin/projectionist.vim"
Searching for "/usr/share/vim/vim74/plugin/projectionist.vim"
Searching for "/usr/share/vim/vimfiles/after/plugin/projectionist.vim"
Searching for "/var/lib/vim/addons/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/vundle/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/L9/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/command-t/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/plugin/projectionist.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/plugin/projectionist.vim"
not found in 'runtimepath': "plugin/projectionist.vim"
line 47: endif
line 48: 
line 49: augroup railsPluginDetect
line 50:   autocmd!
line 51:   autocmd BufEnter * if exists("b:rails_root")|silent doau User BufEnterRails|endif
line 52:   autocmd BufLeave * if exists("b:rails_root")|silent doau User BufLeaveRails|endif
line 53: 
line 57:   autocmd BufNewFile,BufReadPost * if RailsDetect(expand("<afile>:p")) && empty(&filetype) |   call rails#buffer_setup() | endif
line 62:   autocmd VimEnter * if empty(expand("<amatch>")) && RailsDetect(getcwd()) |   call rails#buffer_setup() |   silent doau User BufEnterRails | endif
line 66:   autocmd FileType netrw if RailsDetect() |   silent doau User BufEnterRails | endif
line 67:   autocmd FileType * if RailsDetect() | call rails#buffer_setup() | endif
line 68: 
line 69:   autocmd BufNewFile,BufReadPost *.yml.example set filetype=yaml
line 71:   autocmd BufNewFile,BufReadPost *.rjs,*.rxml,*.builder,*.jbuilder,*.ruby if &filetype !=# 'ruby' | set filetype=ruby | endif
line 72:   autocmd BufReadPost *.log if RailsDetect() | set filetype=railslog | endif
line 73: 
line 74:   autocmd FileType railslog call rails#log_setup()
line 75:   autocmd Syntax railslog call rails#log_syntax()
line 77:   autocmd Syntax ruby,eruby,yaml,haml,javascript,coffee,sass,scss if RailsDetect() | call rails#buffer_syntax() | endif
line 78: 
line 83:   autocmd User ProjectionistDetect if RailsDetect(get(g:, 'projectionist_file', '')) |   call projectionist#append(b:rails_root,     {'*': {'make': split(rails#app().rake_command('static'))}}) | endif
line 84: augroup END
line 85: 
line 86: command! -bar -bang -nargs=* -complete=dir Rails execute rails#new_app_command(<bang>0,<f-args>)
line 87: 
line 88: " }}}1
line 89: " abolish.vim support {{{1
line 90: 
line 91: function! s:function(name)
line 94: 
line 95: augroup railsPluginAbolish
line 96:   autocmd!
line 97:   autocmd VimEnter * call s:abolish_setup()
line 98: augroup END
line 99: 
line 100: function! s:abolish_setup()
line 110: 
line 111: function! s:abolish_l(word)
line 115: 
line 116: function! s:abolish_t(word)
line 123: 
line 124: " }}}1
line 125: " vim:set sw=2 sts=2:
finished sourcing /home/max/.vim/bundle/vim-rails/plugin/rails.vim
Searching for "/home/max/.vim/bundle/sparkup/vim/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/L9/plugin/**/*.vim"
chdir(/home/max/.vim/bundle/L9/plugin)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/L9/plugin/l9.vim"
line 1: "=============================================================================
line 2: " Copyright (C) 2009-2010 Takeshi NISHIDA
line 3: "
line 4: " GetLatestVimScripts: 3252 1 :AutoInstall: L9
line 5: "=============================================================================
line 6: " LOAD GUARD {{{1
line 7: 
line 8: if !l9#guardScriptLoading(expand('<sfile>:p'), 702, 0, [])
Searching for "autoload/l9.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder/
Searching for "/home/max/.vim/autoload/l9.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/l9.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/l9.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/l9.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/l9.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/l9.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/l9.vim"
chdir(/home/max/.vim/bundle/L9/autoload)
fchdir() to previous dir
line 8: sourcing "/home/max/.vim/bundle/L9/autoload/l9.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2009-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if exists('g:loaded_autoload_l9')
line 8:   finish
line 9: endif
line 10: let g:loaded_autoload_l9 = 1
line 11: 
line 12: " }}}1
line 13: "=============================================================================
line 14: " COMPATIBILITY TEST {{{1
line 15: 
line 16: "
line 17: let s:L9_VERSION_CURRENT  = 101
line 18: let s:L9_VERSION_PASSABLE = 101
line 19: 
line 20: " returns true if given version is compatible.
line 21: function l9#isCompatible(ver)
line 24: 
line 25: let s:VERSION_FACTOR = str2float('0.01')
line 26: 
line 27: " returns false if the caller script should finish.
line 28: " a:vimVersion: if 0, don't check vim version
line 29: " a:l9Version: same rule as v:version
line 30: function l9#guardScriptLoading(path, vimVersion, l9Version, exprs)
line 51: 
line 52: " 
line 53: function l9#getVersion()
line 56: 
line 57: " }}}1
line 58: "=============================================================================
line 59: " LIST {{{1
line 60: 
line 61: " Removes duplicates (unstable)
line 62: " This function doesn't change the list of argument.
line 63: function l9#unique(items)
line 78: 
line 79: " Removes duplicates (stable)
line 80: " This function doesn't change the list of argument.
line 81: function l9#uniqueStably(items)
line 90: 
line 91: " [ [0], [1,2], [3] ] -> [ 0, 1, 2, 3 ]
line 92: " This function doesn't change the list of argument.
line 93: function l9#concat(items)
line 100: 
line 101: " [ [0,1,2], [3,4], [5,6,7,8] ] -> [ [0,3,5],[1,4,6] ]
line 102: " This function doesn't change the list of argument.
line 103: function l9#zip(items)
line 110: 
line 111: " filter() with the maximum number of items
line 112: " This function doesn't change the list of argument.
line 113: function l9#filterWithLimit(items, expr, limit)
line 127: 
line 128: " Removes if a:expr is evaluated as non-zero and returns removed items.
line 129: " This function change the list of argument.
line 130: function l9#removeIf(items, expr)
line 135: 
line 136: " }}}1
line 137: "=============================================================================
line 138: " NUMERIC {{{1
line 139: 
line 140: " }}}1
line 141: "=============================================================================
line 142: " STRING {{{1
line 143: 
line 144: " Snips a:str and add a:mask if the length of a:str is more than a:len
line 145: function l9#snipHead(str, len, mask)
line 153: 
line 154: " Snips a:str and add a:mask if the length of a:str is more than a:len
line 155: function l9#snipTail(str, len, mask)
line 163: 
line 164: " Snips a:str and add a:mask if the length of a:str is more than a:len
line 165: function l9#snipMid(str, len, mask)
line 176: 
line 177: "
line 178: function l9#hash224(str)
line 190: 
line 191: " wildcard -> regexp
line 192: function l9#convertWildcardToRegexp(expr)
line 199: 
line 200: " }}}1
line 201: "=============================================================================
line 202: " LINES {{{1
line 203: 
line 204: " Removes from the line matching with a:begin first to the line matching with
line 205: " a:end next and returns removed lines.
line 206: " If matching range is not found, returns []
line 207: function l9#removeLinesBetween(lines, begin, end)
line 221: 
line 222: " }}}1
line 223: "=============================================================================
line 224: " PATH {{{1
line 225: 
line 226: " returns the path separator charactor.
line 227: function l9#getPathSeparator()
line 230: 
line 231: " [ 'a', 'b/', '/c' ] -> 'a/b/c'
line 232: function l9#concatPaths(paths)
line 246: 
line 247: " path: '/a/b/c/d', dir: '/a/b' => 'c/d'
line 248: function l9#modifyPathRelativeToDir(path, dir)
line 256: 
line 257: " }}}1
line 258: "=============================================================================
line 259: " FILE {{{1
line 260: 
line 261: " Almost same as readfile().
line 262: function l9#readFile(...)
line 271: 
line 272: " Almost same as writefile().
line 273: function l9#writeFile(...)
line 286: 
line 287: " }}}1
line 288: "=============================================================================
line 289: " BUFFER {{{1
line 290: 
line 291: " :wall/:wall! wrapper. Useful for writing readonly buffers.
line 292: function l9#writeAll()
line 303: 
line 304: " Loads given files with :edit command
line 305: function l9#loadFilesToBuffers(files)
line 316: 
line 317: " Deletes all buffers except given files with :bdelete command
line 318: function l9#deleteAllBuffersExcept(files)
line 326: 
line 327: " }}}1
line 328: "=============================================================================
line 329: " WINDOW {{{1
line 330: 
line 331: " move current window to next tabpage.
line 332: function l9#shiftWinNextTabpage()
line 347: 
line 348: " move current window to previous tabpage.
line 349: function l9#shiftWinPrevTabpage()
line 360: 
line 361: " move to a window containing specified buffer.
line 362: " returns 0 if the buffer is not found.
line 363: function l9#moveToBufferWindowInCurrentTabpage(bufNr)
line 372: 
line 373: " returns 0 if the buffer is not found.
line 374: function s:moveToOtherTabpageOpeningBuffer(bufNr)
line 383: 
line 384: " move to a window containing specified buffer.
line 385: " returns 0 if the buffer is not found.
line 386: function l9#moveToBufferWindowInOtherTabpage(bufNr)
line 392: 
line 393: " }}}1
line 394: "=============================================================================
line 395: " COMMAND LINE {{{1
line 396: 
line 397: " echo/echomsg with highlighting.
line 398: function l9#echoHl(hl, msg, prefix, addingHistory)
line 409: 
line 410: " input() with highlighting.
line 411: " This function can take list as {completion} argument.
line 412: function l9#inputHl(hl, ...)
line 428: 
line 429: " only called by l9#inputHl() for completion.
line 430: function l9#completeForInputHl(lead, line, pos)
line 433: 
line 434: " }}}1
line 435: "=============================================================================
line 436: " VISUAL MODE {{{1
line 437: 
line 438: " returns last selected text in Visual mode.
line 439: function l9#getSelectedText()
line 454: 
line 455: 
line 456: " }}}1
line 457: "=============================================================================
line 458: " EVAL {{{1
line 459: 
line 460: " loads given text as Vim script with :source command
line 461: function l9#loadScript(text)
line 468: 
line 469: 
line 470: " }}}1
line 471: "=============================================================================
line 472: " VARIABLES {{{1
line 473: 
line 474: " 
line 475: function l9#defineVariableDefault(name, default)
line 480: 
line 481: " }}}1
line 482: "=============================================================================
line 483: " GREP {{{1
line 484: 
line 485: " Execute :vimgrep and opens the quickfix window if matches are found.
line 486: "
line 487: " a:pattern: search pattern. If ommitted, last search pattern (@/) is used.
line 488: " a:files: List of files
line 489: function l9#grepFiles(pattern, files)
line 501: 
line 502: " Execute :vimgrep for buffers using l9#grepFiles()
line 503: " See also: :L9GrepBuffer :L9GrepBufferAll
line 504: function l9#grepBuffers(pattern, bufNrs)
line 508: 
line 509: " }}}1
line 510: "=============================================================================
line 511: " SIGN {{{1
line 512: 
line 513: " Highlights lines using :sign define and :sign place.
line 514: " 
line 515: " a:linehl, a:text, a:texthl: See |signs|. Ignored if empty string.
line 516: " a:locations: List of [{buffer number}, {line number}] for highlighting
line 517: function l9#placeSign(linehl, text, texthl, locations)
line 528: 
line 529: " }}}1
line 530: "=============================================================================
line 531: " NOTIFY EXTERNALLY {{{1
line 532: 
line 533: " Notify a message using an external program.
line 534: " Currently supports Balloonly, Screen, and Tmux.
line 535: function l9#notifyExternally(msg)
line 540: 
line 541: "
line 542: function l9#notifyBalloonly(msg)
line 549: 
line 550: "
line 551: function l9#notifyScreen(msg)
line 558: 
line 559: "
line 560: function l9#notifyTmux(msg)
line 567: 
line 568: " }}}1
line 569: "=============================================================================
line 570: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/L9/autoload/l9.vim
continuing in /home/max/.vim/bundle/L9/plugin/l9.vim
calling function l9#guardScriptLoading('/home/max/.vim/bundle/L9/plugin/l9.vim', 702, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/L9/plugin/l9.vim

line 9:   finish
line 10: endif
line 11: 
line 12: " }}}1
line 13: "=============================================================================
line 14: " OPTIONS: {{{1
line 15: 
line 16: call l9#defineVariableDefault('g:l9_balloonly', 'balloonly.exe')
calling function l9#defineVariableDefault('g:l9_balloonly', 'balloonly.exe')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function l9#defineVariableDefault returning #0

continuing in /home/max/.vim/bundle/L9/plugin/l9.vim

line 17: 
line 18: " }}}1
line 19: "=============================================================================
line 20: " ASSERTION: {{{1
line 21: 
line 22: " This command has effect only if $L9_DEBUG is non-zero.
line 23: " Used as follows:
line 24: "   L9Assert a:i > 0
line 25: " This command can't interpret script-local variables directly.
line 26: "   NG: L9Assert s:a == 1
line 27: "   OK: execute 'L9Assert ' . s:a . ' == 1'
line 28: "
line 29: if $L9_DEBUG
line 30:   command -nargs=* L9Assert call eval((<args>) ? 0 : s:handleFailedAssersion(<q-args>))
line 31: 
line 32:   function s:handleFailedAssersion(expr)
line 38: 
line 39: else
line 40:   command -nargs=* L9Assert :
line 41: endif
line 42: 
line 43: " }}}1
line 44: "=============================================================================
line 45: " TIMER: {{{1
line 46: 
line 47: " These commands have effect only if $L9_TIMER is non-zero.
line 48: " Used as follows:
line 49: "   L9Timer foo
line 50: "     ... (1)
line 51: "   L9Timer bar
line 52: "     ... (2)
line 53: "   L9TimerStop
line 54: "     ...
line 55: "   L9TimerDump  <- shows each elapsed time of (1) and (2)
line 56: "
line 57: if $L9_TIMER
line 58:   command -nargs=1 L9Timer call s:timerBegin(<q-args>)
line 59:   command -nargs=0 L9TimerStop call s:timerStop()
line 60:   command -nargs=0 L9TimerDump call s:timerDump()
line 61: 
line 62:   let s:timerData = []
line 63:   let s:timerTagMaxLen = 0
line 64: 
line 65:   function s:timerBegin(tag)
line 70: 
line 71:   function s:timerStop()
line 79: 
line 80:   function s:timerDump()
line 87: 
line 88: else
line 89:   command -nargs=1 L9Timer :
line 90:   command -nargs=0 L9TimerStop :
line 91:   command -nargs=0 L9TimerDump :
line 92: endif
line 93: 
line 94: " }}}1
line 95: "=============================================================================
line 96: " GREP BUFFER: {{{1
line 97: 
line 98: " Grep for current buffer by l9#grepBuffers()
line 99: " Used as :L9GrepBuffer/pattern
line 100: command -nargs=? L9GrepBuffer    call l9#grepBuffers(<q-args>, [bufnr('%')])
line 101: 
line 102: " Grep for all buffers by l9#grepBuffers()
line 103: " Used as :L9GrepBufferAll/pattern
line 104: command -nargs=? L9GrepBufferAll call l9#grepBuffers(<q-args>, range(1, bufnr('$')))
line 105: 
line 106: " }}}1
line 107: "=============================================================================
line 108: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/L9/plugin/l9.vim
Searching for "/home/max/.vim/bundle/FuzzyFinder/plugin/**/*.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/plugin)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/FuzzyFinder/plugin/fuf.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: " GetLatestVimScripts: 1984 1 :AutoInstall: FuzzyFinder
line 5: "=============================================================================
line 6: " LOAD GUARD {{{1
line 7: 
line 8: try
line 9:   if !l9#guardScriptLoading(expand('<sfile>:p'), 702, 101, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/plugin/fuf.vim', 702, 101, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/plugin/fuf.vim

line 10:     finish
line 11:   endif
line 12: catch /E117/
line 13:   echoerr '***** L9 library must be installed! *****'
line 14:   finish
line 15: endtry
line 16: 
line 17: " }}}1
line 18: "=============================================================================
line 19: " LOCAL FUNCTIONS {{{1
line 20: 
line 21: "
line 22: function s:initialize()
line 142: 
line 143: "
line 144: function s:renewCachesOfAllModes()
line 149: 
line 150: " }}}1
line 151: "=============================================================================
line 152: " INITIALIZATION {{{1
line 153: 
line 154: call s:initialize()
calling function <SNR>38_initialize()

line 1:   "---------------------------------------------------------------------------
line 2:   call l9#defineVariableDefault('g:fuf_modesDisable'     , [ 'mrufile', 'mrucmd', ])
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_modesDisable', ['mrufile', 'mrucmd'])

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 3:   call l9#defineVariableDefault('g:fuf_keyOpen'          , '<CR>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_keyOpen', '<CR>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 4:   call l9#defineVariableDefault('g:fuf_keyOpenSplit'     , '<C-j>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_keyOpenSplit', '<C-j>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 5:   call l9#defineVariableDefault('g:fuf_keyOpenVsplit'    , '<C-k>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_keyOpenVsplit', '<C-k>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 6:   call l9#defineVariableDefault('g:fuf_keyOpenTabpage'   , '<C-l>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_keyOpenTabpage', '<C-l>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 7:   call l9#defineVariableDefault('g:fuf_keyPreview'       , '<C-@>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_keyPreview', '<C-@>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 8:   call l9#defineVariableDefault('g:fuf_keyNextMode'      , '<C-t>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_keyNextMode', '<C-t>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 9:   call l9#defineVariableDefault('g:fuf_keyPrevMode'      , '<C-y>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_keyPrevMode', '<C-y>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 10:   call l9#defineVariableDefault('g:fuf_keyPrevPattern'   , '<C-s>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_keyPrevPattern', '<C-s>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 11:   call l9#defineVariableDefault('g:fuf_keyNextPattern'   , '<C-_>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_keyNextPattern', '<C-_>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 12:   call l9#defineVariableDefault('g:fuf_keySwitchMatching', '<C-\><C-\>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_keySwitchMatching', '<C-\><C-\>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 13:   call l9#defineVariableDefault('g:fuf_dataDir'          , '~/.vim-fuf-data')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_dataDir', '~/.vim-fuf-data')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 14:   call l9#defineVariableDefault('g:fuf_abbrevMap'        , {})
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_abbrevMap', {})

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 15:   call l9#defineVariableDefault('g:fuf_patternSeparator' , ';')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_patternSeparator', ';')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 16:   call l9#defineVariableDefault('g:fuf_promptHighlight'  , 'Question')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_promptHighlight', 'Question')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 17:   call l9#defineVariableDefault('g:fuf_ignoreCase'       , 1)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_ignoreCase', 1)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 18:   call l9#defineVariableDefault('g:fuf_splitPathMatching', 1)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_splitPathMatching', 1)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 19:   call l9#defineVariableDefault('g:fuf_fuzzyRefining'    , 0)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_fuzzyRefining', 0)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 20:   call l9#defineVariableDefault('g:fuf_smartBs'          , 1)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_smartBs', 1)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 21:   call l9#defineVariableDefault('g:fuf_reuseWindow'      , 1)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_reuseWindow', 1)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 22:   call l9#defineVariableDefault('g:fuf_timeFormat'       , '(%Y-%m-%d %H:%M:%S)')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_timeFormat', '(%Y-%m-%d %H:%M:%S)')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 23:   call l9#defineVariableDefault('g:fuf_learningLimit'    , 100)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_learningLimit', 100)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 24:   call l9#defineVariableDefault('g:fuf_enumeratingLimit' , 50)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_enumeratingLimit', 50)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 25:   call l9#defineVariableDefault('g:fuf_maxMenuWidth'     , 78)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_maxMenuWidth', 78)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 26:   call l9#defineVariableDefault('g:fuf_previewHeight'    , 0)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_previewHeight', 0)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 27:   call l9#defineVariableDefault('g:fuf_autoPreview'      , 0)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_autoPreview', 0)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 28:   call l9#defineVariableDefault('g:fuf_useMigemo'        , 0)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_useMigemo', 0)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 29:   "---------------------------------------------------------------------------
line 30:   call l9#defineVariableDefault('g:fuf_buffer_prompt'     , '>Buffer[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_buffer_prompt', '>Buffer[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 31:   call l9#defineVariableDefault('g:fuf_buffer_switchOrder', 10)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_buffer_switchOrder', 10)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 32:   call l9#defineVariableDefault('g:fuf_buffer_mruOrder'   , 1)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_buffer_mruOrder', 1)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 33:   call l9#defineVariableDefault('g:fuf_buffer_keyDelete'  , '<C-]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_buffer_keyDelete', '<C-]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 34:   "---------------------------------------------------------------------------
line 35:   call l9#defineVariableDefault('g:fuf_file_prompt'     , '>File[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_file_prompt', '>File[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 36:   call l9#defineVariableDefault('g:fuf_file_switchOrder', 20)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_file_switchOrder', 20)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 37:   call l9#defineVariableDefault('g:fuf_file_exclude'    , '\v\~$|\.(o|exe|dll|bak|orig|sw[po])$|(^|[/\\])\.(hg|git|bzr)($|[/\\])')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_file_exclude', '\v\~$|\.(o|exe|dll|bak|orig|sw[po])$|(^|[/\\])\.(hg|git|bzr)($|[/\\])')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 38:   "---------------------------------------------------------------------------
line 39:   call l9#defineVariableDefault('g:fuf_coveragefile_prompt'     , '>CoverageFile[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_coveragefile_prompt', '>CoverageFile[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 40:   call l9#defineVariableDefault('g:fuf_coveragefile_switchOrder', 30)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_coveragefile_switchOrder', 30)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 41:   call l9#defineVariableDefault('g:fuf_coveragefile_exclude'    , '\v\~$|\.(o|exe|dll|bak|orig|sw[po])$|(^|[/\\])\.(hg|git|bzr)($|[/\\])')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_coveragefile_exclude', '\v\~$|\.(o|exe|dll|bak|orig|sw[po])$|(^|[/\\])\.(hg|git|bzr)($|[/\\])')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 42:   call l9#defineVariableDefault('g:fuf_coveragefile_globPatterns', ['**/.*', '**/*'])
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_coveragefile_globPatterns', ['**/.*', '**/*'])

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 43:   "---------------------------------------------------------------------------
line 44:   call l9#defineVariableDefault('g:fuf_dir_prompt'     , '>Dir[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_dir_prompt', '>Dir[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 45:   call l9#defineVariableDefault('g:fuf_dir_switchOrder', 40)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_dir_switchOrder', 40)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 46:   call l9#defineVariableDefault('g:fuf_dir_exclude'    , '\v(^|[/\\])\.(hg|git|bzr)($|[/\\])')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_dir_exclude', '\v(^|[/\\])\.(hg|git|bzr)($|[/\\])')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 47:   "---------------------------------------------------------------------------
line 48:   call l9#defineVariableDefault('g:fuf_mrufile_prompt'     , '>MRU-File[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_mrufile_prompt', '>MRU-File[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 49:   call l9#defineVariableDefault('g:fuf_mrufile_switchOrder', 50)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_mrufile_switchOrder', 50)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 50:   call l9#defineVariableDefault('g:fuf_mrufile_exclude'    , '\v\~$|\.(o|exe|dll|bak|orig|sw[po])$|^(\/\/|\\\\|\/mnt\/|\/media\/)')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_mrufile_exclude', '\v\~$|\.(o|exe|dll|bak|orig|sw[po])$|^(\/\/|\\\\|\/mnt\/|\/media\/)')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 51:   call l9#defineVariableDefault('g:fuf_mrufile_maxItem'    , 200)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_mrufile_maxItem', 200)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 52:   call l9#defineVariableDefault('g:fuf_mrufile_maxItemDir' , 50)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_mrufile_maxItemDir', 50)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 53:   call l9#defineVariableDefault('g:fuf_mrufile_keyExpand'  , '<C-]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_mrufile_keyExpand', '<C-]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 54:   "---------------------------------------------------------------------------
line 55:   call l9#defineVariableDefault('g:fuf_mrucmd_prompt'     , '>MRU-Cmd[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_mrucmd_prompt', '>MRU-Cmd[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 56:   call l9#defineVariableDefault('g:fuf_mrucmd_switchOrder', 60)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_mrucmd_switchOrder', 60)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 57:   call l9#defineVariableDefault('g:fuf_mrucmd_exclude'    , '^$')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_mrucmd_exclude', '^$')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 58:   call l9#defineVariableDefault('g:fuf_mrucmd_maxItem'    , 200)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_mrucmd_maxItem', 200)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 59:   "---------------------------------------------------------------------------
line 60:   call l9#defineVariableDefault('g:fuf_bookmarkfile_prompt'     , '>Bookmark-File[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_bookmarkfile_prompt', '>Bookmark-File[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 61:   call l9#defineVariableDefault('g:fuf_bookmarkfile_switchOrder', 70)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_bookmarkfile_switchOrder', 70)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 62:   call l9#defineVariableDefault('g:fuf_bookmarkfile_searchRange', 400)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_bookmarkfile_searchRange', 400)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 63:   call l9#defineVariableDefault('g:fuf_bookmarkfile_keyDelete'  , '<C-]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_bookmarkfile_keyDelete', '<C-]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 64:   "---------------------------------------------------------------------------
line 65:   call l9#defineVariableDefault('g:fuf_bookmarkdir_prompt'     , '>Bookmark-Dir[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_bookmarkdir_prompt', '>Bookmark-Dir[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 66:   call l9#defineVariableDefault('g:fuf_bookmarkdir_switchOrder', 80)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_bookmarkdir_switchOrder', 80)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 67:   call l9#defineVariableDefault('g:fuf_bookmarkdir_keyDelete'  , '<C-]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_bookmarkdir_keyDelete', '<C-]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 68:   "---------------------------------------------------------------------------
line 69:   call l9#defineVariableDefault('g:fuf_tag_prompt'     , '>Tag[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_tag_prompt', '>Tag[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 70:   call l9#defineVariableDefault('g:fuf_tag_switchOrder', 90)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_tag_switchOrder', 90)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 71:   "---------------------------------------------------------------------------
line 72:   call l9#defineVariableDefault('g:fuf_buffertag_prompt'     , '>Buffer-Tag[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_buffertag_prompt', '>Buffer-Tag[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 73:   call l9#defineVariableDefault('g:fuf_buffertag_switchOrder', 100)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_buffertag_switchOrder', 100)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 74:   call l9#defineVariableDefault('g:fuf_buffertag_ctagsPath'  , 'ctags')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_buffertag_ctagsPath', 'ctags')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 75:   "---------------------------------------------------------------------------
line 76:   call l9#defineVariableDefault('g:fuf_taggedfile_prompt'     , '>Tagged-File[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_taggedfile_prompt', '>Tagged-File[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 77:   call l9#defineVariableDefault('g:fuf_taggedfile_switchOrder', 110)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_taggedfile_switchOrder', 110)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 78:   "---------------------------------------------------------------------------
line 79:   call l9#defineVariableDefault('g:fuf_jumplist_prompt'     , '>Jump-List[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_jumplist_prompt', '>Jump-List[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 80:   call l9#defineVariableDefault('g:fuf_jumplist_switchOrder', 120)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_jumplist_switchOrder', 120)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 81:   "---------------------------------------------------------------------------
line 82:   call l9#defineVariableDefault('g:fuf_changelist_prompt'     , '>Change-List[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_changelist_prompt', '>Change-List[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 83:   call l9#defineVariableDefault('g:fuf_changelist_switchOrder', 130)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_changelist_switchOrder', 130)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 84:   "---------------------------------------------------------------------------
line 85:   call l9#defineVariableDefault('g:fuf_quickfix_prompt'     , '>Quickfix[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_quickfix_prompt', '>Quickfix[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 86:   call l9#defineVariableDefault('g:fuf_quickfix_switchOrder', 140)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_quickfix_switchOrder', 140)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 87:   "---------------------------------------------------------------------------
line 88:   call l9#defineVariableDefault('g:fuf_line_prompt'     , '>Line[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_line_prompt', '>Line[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 89:   call l9#defineVariableDefault('g:fuf_line_switchOrder', 150)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_line_switchOrder', 150)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 90:   "---------------------------------------------------------------------------
line 91:   call l9#defineVariableDefault('g:fuf_help_prompt'     , '>Help[]>')
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_help_prompt', '>Help[]>')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 92:   call l9#defineVariableDefault('g:fuf_help_switchOrder', 160)
calling function <SNR>38_initialize..l9#defineVariableDefault('g:fuf_help_switchOrder', 160)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize

line 93:   "---------------------------------------------------------------------------
line 94:   command! -bang -narg=0 FufEditDataFile call fuf#editDataFile()
line 95:   command! -bang -narg=0 FufRenewCache   call s:renewCachesOfAllModes()
line 96:   "---------------------------------------------------------------------------
line 97:   call fuf#addMode('buffer')
Searching for "autoload/fuf.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFinder
Searching for "/home/max/.vim/autoload/fuf.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload)
fchdir() to previous dir
line 97: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: 
line 16: " returns list of paths.
line 17: " An argument for glob() is normalized in order to avoid a bug on Windows.
line 18: function fuf#glob(expr)
line 23: 
line 24: "
line 25: function fuf#countModifiedFiles(files, time)
line 28: 
line 29: "
line 30: function fuf#getCurrentTagFiles()
line 33: 
line 34: "
line 35: function fuf#mapToSetSerialIndex(in, offset)
line 41: 
line 42: "
line 43: function fuf#updateMruList(mrulist, newItem, maxItem, exclude)
line 52: 
line 53: " takes suffix number. if no digits, returns -1
line 54: function fuf#suffixNumber(str)
line 58: 
line 59: " "foo/bar/buz/hoge" -> { head: "foo/bar/buz/", tail: "hoge" }
line 60: function fuf#splitPath(path)
line 67: 
line 68: " "foo/.../bar/...hoge" -> "foo/.../bar/../../hoge"
line 69: function fuf#expandTailDotSequenceToParentDir(pattern)
line 73: 
line 74: "
line 75: function fuf#formatPrompt(prompt, partialMatching, otherString)
line 79: 
line 80: "
line 81: function fuf#getFileLines(file)
line 89: 
line 90: "
line 91: function fuf#makePreviewLinesAround(lines, indices, page, maxHeight)
line 107: 
line 108: " a:file: a path string or a buffer number
line 109: function fuf#makePreviewLinesForFile(file, count, maxHeight)
line 123: 
line 124: "
line 125: function fuf#echoWarning(msg)
line 128: 
line 129: "
line 130: function fuf#echoError(msg)
line 133: 
line 134: "
line 135: function fuf#openBuffer(bufNr, mode, reuse)
line 151: 
line 152: "
line 153: function fuf#openFile(path, mode, reuse)
line 166: 
line 167: "
line 168: function fuf#openTag(tag, mode)
line 176: 
line 177: "
line 178: function fuf#openHelp(tag, mode)
line 186: 
line 187: "
line 188: function fuf#prejump(mode)
line 196: 
line 197: "
line 198: function fuf#compareRanks(i1, i2)
line 210: 
line 211: "
line 212: function fuf#makePathItem(fname, menu, appendsDirSuffix)
line 227: 
line 228: "
line 229: function fuf#makeNonPathItem(word, menu)
line 240: 
line 241: "
line 242: function fuf#makePatternSet(patternBase, interpreter, partialMatching)
line 256: 
line 257: "
line 258: function fuf#enumExpandedDirsEntries(dir, exclude)
line 268: 
line 269: "
line 270: function fuf#mapToSetAbbrWithSnippedWordAsPath(items)
line 277: 
line 278: "
line 279: function fuf#setAbbrWithFormattedWord(item, abbrIndex)
line 289: 
line 290: "
line 291: function s:onCommandPre()
line 300: 
line 301: "
line 302: let s:modeNames = []
line 303: 
line 304: "
line 305: function fuf#addMode(modeName)
line 317: 
line 318: "
line 319: function fuf#getModeNames()
line 322: 
line 323: "
line 324: function fuf#defineLaunchCommand(CmdName, modeName, prefixInitialPattern, tempVars)
line 334: 
line 335: "
line 336: function fuf#defineKeyMappingInHandler(key, func)
line 342: 
line 343: "
line 344: let s:oneTimeVariables = []
line 345: 
line 346: " 
line 347: function fuf#setOneTimeVariables(...)
line 350: 
line 351: "
line 352: function fuf#launch(modeName, initialPattern, partialMatching)
line 411: 
line 412: "
line 413: function fuf#loadDataFile(modeName, dataName)
line 420: 
line 421: " 
line 422: function fuf#saveDataFile(modeName, dataName, items)
line 429: 
line 430: " 
line 431: function fuf#getDataFileTime(modeName, dataName)
line 437: 
line 438: "
line 439: function s:createDataBufferListener(dataFile)
line 452: 
line 453: "
line 454: function s:createEditDataListener()
line 466: 
line 467: "
line 468: function s:getEditableDataFiles(modeName)
line 473: 
line 474: "
line 475: function fuf#editDataFile()
line 480: 
line 481: " 
line 482: function fuf#getRunningHandler()
line 485: 
line 486: " 
line 487: function fuf#onComplete(findstart, base)
line 490: 
line 491: " }}}1
line 492: "=============================================================================
line 493: " LOCAL FUNCTIONS/VARIABLES {{{1
line 494: 
line 495: let s:TEMP_VARIABLES_GROUP = expand('<sfile>:p')
line 496: let s:ABBR_SNIP_MASK = '...'
line 497: let s:OPEN_TYPE_CURRENT = 1
line 498: let s:OPEN_TYPE_SPLIT   = 2
line 499: let s:OPEN_TYPE_VSPLIT  = 3
line 500: let s:OPEN_TYPE_TAB     = 4
line 501: 
line 502: " a:pattern: 'str' -> '\V\.\*s\.\*t\.\*r\.\*'
line 503: function s:makeFuzzyMatchingExpr(target, pattern)
line 513: 
line 514: " a:pattern: 'str' -> '\Vstr'
line 515: "            'st*r' -> '\Vst\.\*r'
line 516: function s:makePartialMatchingExpr(target, pattern)
line 525: 
line 526: " 
line 527: function s:makeRefiningExpr(pattern)
line 539: 
line 540: " 
line 541: function s:makeAdditionalMigemoPattern(pattern)
line 547: 
line 548: "
line 549: function s:interpretPrimaryPatternForPathTail(pattern)
line 558: 
line 559: "
line 560: function s:interpretPrimaryPatternForPath(pattern)
line 580: 
line 581: "
line 582: function s:interpretPrimaryPatternForNonPath(pattern)
line 590: 
line 591: "
line 592: function s:getWordBoundaries(word)
line 595: 
line 596: "
line 597: function s:toLowerForIgnoringCase(str)
line 600: 
line 601: "
line 602: function s:setRanks(item, pattern, exprBoundary, stats)
line 613: 
line 614: " 
line 615: function s:evaluateLearningRank(word, stats)
line 623: 
line 624: " range of return value is [0.0, 1.0]
line 625: function s:scoreSequentialMatching(word, pattern)
line 636: 
line 637: " range of return value is [0.0, 1.0]
line 638: function s:scoreBoundaryMatching(wordForBoundary, pattern, exprBoundary)
line 647: 
line 648: "
line 649: function s:highlightPrompt(prompt)
line 653: 
line 654: "
line 655: function s:highlightError()
line 659: 
line 660: "
line 661: function s:expandAbbrevMap(pattern, abbrevMap)
line 672: 
line 673: "
line 674: function s:makeFileAbbrInfo(item, maxLenStats)
line 690: 
line 691: "
line 692: function s:getSnippedHead(head, baseLen)
line 695: 
line 696: "
line 697: function s:setAbbrWithFileAbbrData(item, snippedHeads)
line 703: 
line 704: "
line 705: let s:FUF_BUF_NAME = '[fuf]'
line 706: 
line 707: "
line 708: function s:activateFufBuffer()
line 727: 
line 728: "
line 729: function s:deactivateFufBuffer()
line 737: 
line 738: " }}}1
line 739: "=============================================================================
line 740: " s:handlerBase {{{1
line 741: 
line 742: let s:handlerBase = {}
line 743: 
line 744: "-----------------------------------------------------------------------------
line 745: " PURE VIRTUAL FUNCTIONS {{{2
line 746: "
line 747: " "
line 748: " s:handler.getModeName()
line 749: " 
line 750: " "
line 751: " s:handler.getPrompt()
line 752: " 
line 753: " "
line 754: " s:handler.getCompleteItems(patternSet)
line 755: " 
line 756: " "
line 757: " s:handler.onOpen(word, mode)
line 758: " 
line 759: " " Before entering FuzzyFinder buffer. This function should return in a short time.
line 760: " s:handler.onModeEnterPre()
line 761: "
line 762: " " After entering FuzzyFinder buffer.
line 763: " s:handler.onModeEnterPost()
line 764: "
line 765: " " After leaving FuzzyFinder buffer.
line 766: " s:handler.onModeLeavePost(opened)
line 767: "
line 768: " }}}2
line 769: "-----------------------------------------------------------------------------
line 770: 
line 771: "
line 772: function s:handlerBase.concretize(deriv)
line 776: 
line 777: "
line 778: function s:handlerBase.addStat(pattern, word)
line 784: 
line 785: "
line 786: function s:handlerBase.getMatchingCompleteItems(patternBase)
line 801: 
line 802: "
line 803: function s:handlerBase.onComplete(findstart, base)
line 832: 
line 833: "
line 834: function s:handlerBase.existsPrompt(line)
line 838: 
line 839: "
line 840: function s:handlerBase.removePrompt(line)
line 843: 
line 844: "
line 845: function s:handlerBase.restorePrompt(line)
line 852: 
line 853: "
line 854: function s:handlerBase.onCursorMovedI()
line 868: 
line 869: "
line 870: function s:handlerBase.onInsertLeave()
line 888: 
line 889: "
line 890: function s:handlerBase.onCr(openType)
line 907: 
line 908: "
line 909: function s:handlerBase.onBs()
line 912: 
line 913: "
line 914: function s:getLastBlockLength(pattern, patternIsPath)
line 924: 
line 925: "
line 926: function s:handlerBase.onDeleteWord()
line 931: 
line 932: "
line 933: function s:handlerBase.onPreviewBase(repeatable)
line 958: 
line 959: "
line 960: function s:handlerBase.onSwitchMode(shift)
line 974: 
line 975: "
line 976: function s:handlerBase.onSwitchMatching()
line 983: 
line 984: "
line 985: function s:handlerBase.onRecallPattern(shift)
line 1000: 
line 1001: " }}}1
line 1002: "=============================================================================
line 1003: " INITIALIZATION {{{1
line 1004: 
line 1005: augroup FufGlobal
line 1006:   autocmd!
line 1007:   autocmd BufLeave * let s:bufferCursorPosMap[bufnr('')] = getpos('.')
line 1008: augroup END
line 1009: 
line 1010: let s:bufferCursorPosMap = {}
line 1011: 
line 1012: "
line 1013: let s:DATA_FILE_VERSION = 400
line 1014: 
line 1015: "
line 1016: function s:checkDataFileCompatibility()
line 1040: 
line 1041: call s:checkDataFileCompatibility()
calling function <SNR>39_checkDataFileCompatibility()

line 1:   if empty(g:fuf_dataDir)
line 2:     let s:dataFileAvailable = 0
line 3:     return
line 4:   endif
line 5:   let versionPath = l9#concatPaths([g:fuf_dataDir, 'VERSION'])
calling function <SNR>39_checkDataFileCompatibility..l9#concatPaths(['~/.vim-fuf-data', 'VERSION'])

line 1:   let result = ''
line 2:   for p in a:paths
line 3:     if empty(p)
line 4:       continue
line 5:     elseif empty(result)
line 6:       let result = p
line 7:     else
line 8:       let result = substitute(result, '[/\\]$', '', '') . l9#getPathSeparator()    . substitute(p, '^[/\\]', '', '')
line 10:     endif
line 11:   endfor
line 2:   for p in a:paths
line 3:     if empty(p)
line 4:       continue
line 5:     elseif empty(result)
line 6:       let result = p
line 7:     else
line 8:       let result = substitute(result, '[/\\]$', '', '') . l9#getPathSeparator()    . substitute(p, '^[/\\]', '', '')
calling function <SNR>39_checkDataFileCompatibility..l9#concatPaths..l9#getPathSeparator()

line 1:   return (!&shellslash && (has('win32') || has('win64')) ? '\' : '/')
function <SNR>39_checkDataFileCompatibility..l9#concatPaths..l9#getPathSeparator returning '/'

continuing in function <SNR>39_checkDataFileCompatibility..l9#concatPaths

line 10:     endif
line 11:   endfor
line 2:   for p in a:paths
line 3:     if empty(p)
line 4:       continue
line 5:     elseif empty(result)
line 6:       let result = p
line 7:     else
line 8:       let result = substitute(result, '[/\\]$', '', '') . l9#getPathSeparator()    . substitute(p, '^[/\\]', '', '')
line 10:     endif
line 11:   endfor
line 12:   return result
function <SNR>39_checkDataFileCompatibility..l9#concatPaths returning '~/.vim-fuf-data/VERSION'

continuing in function <SNR>39_checkDataFileCompatibility

line 6:   let lines = l9#readFile(versionPath)
calling function <SNR>39_checkDataFileCompatibility..l9#readFile('~/.vim-fuf-data/VERSION')

line 1:   let args = copy(a:000)
line 2:   let args[0] = expand(args[0])
line 3:   try
line 4:     return call('readfile', args)
:return ['400'] made pending

line 5:   catch
line 6:   endtry
:return ['400'] resumed

function <SNR>39_checkDataFileCompatibility..l9#readFile returning ['400']

continuing in function <SNR>39_checkDataFileCompatibility

line 7:   if empty(lines)
line 8:     call l9#writeFile([s:DATA_FILE_VERSION], versionPath)
line 9:     let s:dataFileAvailable = 1
line 10:   elseif str2nr(lines[0]) == s:DATA_FILE_VERSION
line 11:     let s:dataFileAvailable = 1
line 12:   else
line 13:     call fuf#echoWarning(printf( "=======================================================\n" . "  Existing data files for FuzzyFinder is no longer     \n" . "  compatible with this version of FuzzyFinder. Remove  \n" . "  %-53s\n" . "=======================================================\n" , string(g:fuf_dataDir)))
line 20:     call l9#inputHl('Question', 'Press Enter')
line 21:     let s:dataFileAvailable = 0
line 22:   endif
function <SNR>39_checkDataFileCompatibility returning #0

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf.vim

line 1042: 
line 1043: " }}}1
line 1044: "=============================================================================
line 1045: " vim: set fdm=marker:
line 1046: 
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf.vim
continuing in function <SNR>38_initialize
calling function <SNR>38_initialize..fuf#addMode('buffer')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/buffer.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/Fuzz
Searching for "/home/max/.vim/autoload/fuf/buffer.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/buffer.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/buffer.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/buffer.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/buffer.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/buffer.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/buffer.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/buffer.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/buffer.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/buffer.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/buffer.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#buffer#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#buffer#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#buffer#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#buffer#renewCache()
line 33: 
line 34: "
line 35: function fuf#buffer#requiresOnCommandPre()
line 38: 
line 39: "
line 40: function fuf#buffer#onInit()
line 48: 
line 49: " }}}1
line 50: "=============================================================================
line 51: " LOCAL FUNCTIONS/VARIABLES {{{1
line 52: 
line 53: let s:MODE_NAME = expand('<sfile>:t:r')
line 54: let s:OPEN_TYPE_DELETE = -1
line 55: 
line 56: let s:bufTimes = {}
line 57: 
line 58: "
line 59: function s:updateBufTimes()
line 62: 
line 63: "
line 64: function s:makeItem(nr)
line 76: 
line 77: "
line 78: function s:getBufIndicator(bufNr)
line 89: 
line 90: "
line 91: function s:compareTimeDescending(i1, i2)
line 94: 
line 95: "
line 96: function s:findItem(items, word)
line 104: 
line 105: " }}}1
line 106: "=============================================================================
line 107: " s:handler {{{1
line 108: 
line 109: let s:handler = {}
line 110: 
line 111: "
line 112: function s:handler.getModeName()
line 115: 
line 116: "
line 117: function s:handler.getPrompt()
line 120: 
line 121: "
line 122: function s:handler.getPreviewHeight()
line 125: 
line 126: "
line 127: function s:handler.isOpenable(enteredPattern)
line 130: 
line 131: "
line 132: function s:handler.makePatternSet(patternBase)
line 136: 
line 137: "
line 138: function s:handler.makePreviewLines(word, count)
line 145: 
line 146: "
line 147: function s:handler.getCompleteItems(patternPrimary)
line 150: 
line 151: "
line 152: function s:handler.onOpen(word, mode)
line 164: 
line 165: "
line 166: function s:handler.onModeEnterPre()
line 168: 
line 169: "
line 170: function s:handler.onModeEnterPost()
line 182: 
line 183: "
line 184: function s:handler.onModeLeavePost(opened)
line 186: 
line 187: " }}}1
line 188: "=============================================================================
line 189: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/buffer.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#buffer#renewCache()

function <SNR>38_initialize..fuf#addMode..fuf#buffer#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#buffer#onInit()

line 1:   call fuf#defineLaunchCommand('FufBuffer', s:MODE_NAME, '""', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#buffer#onInit..fuf#defineLaunchCommand('FufBuffer', 'buffer', '""', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufBuffer  call fuf#launch('buffer', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#buffer#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffer#onInit

line 2:   augroup fuf#buffer
line 3:     autocmd!
line 4:     autocmd BufEnter     * call s:updateBufTimes()
line 5:     autocmd BufWritePost * call s:updateBufTimes()
line 6:   augroup END
function <SNR>38_initialize..fuf#addMode..fuf#buffer#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#buffer#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#buffer#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 98:   call fuf#addMode('file')
calling function <SNR>38_initialize..fuf#addMode('file')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/file.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyF
Searching for "/home/max/.vim/autoload/fuf/file.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/file.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/file.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/file.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/file.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/file.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/file.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/file.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/file.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/file.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/file.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#file#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#file#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#file#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#file#renewCache()
line 34: 
line 35: "
line 36: function fuf#file#requiresOnCommandPre()
line 39: 
line 40: "
line 41: function fuf#file#onInit()
line 46: 
line 47: " }}}1
line 48: "=============================================================================
line 49: " LOCAL FUNCTIONS/VARIABLES {{{1
line 50: 
line 51: let s:MODE_NAME = expand('<sfile>:t:r')
line 52: 
line 53: "
line 54: function s:enumItems(dir)
line 63: 
line 64: "
line 65: function s:enumNonCurrentItems(dir, bufNrPrev, cache)
line 75: 
line 76: " }}}1
line 77: "=============================================================================
line 78: " s:handler {{{1
line 79: 
line 80: let s:handler = {}
line 81: 
line 82: "
line 83: function s:handler.getModeName()
line 86: 
line 87: "
line 88: function s:handler.getPrompt()
line 91: 
line 92: "
line 93: function s:handler.getPreviewHeight()
line 96: 
line 97: "
line 98: function s:handler.isOpenable(enteredPattern)
line 101: 
line 102: "
line 103: function s:handler.makePatternSet(patternBase)
line 107: 
line 108: "
line 109: function s:handler.makePreviewLines(word, count)
line 112: 
line 113: "
line 114: function s:handler.getCompleteItems(patternPrimary)
line 118: 
line 119: "
line 120: function s:handler.onOpen(word, mode)
line 123: 
line 124: "
line 125: function s:handler.onModeEnterPre()
line 127: 
line 128: "
line 129: function s:handler.onModeEnterPost()
line 132: 
line 133: "
line 134: function s:handler.onModeLeavePost(opened)
line 136: 
line 137: " }}}1
line 138: "=============================================================================
line 139: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/file.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#file#renewCache()

line 1:   let s:cache = {}
function <SNR>38_initialize..fuf#addMode..fuf#file#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#file#onInit()

line 1:   call fuf#defineLaunchCommand('FufFile'                    , s:MODE_NAME, '""', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#file#onInit..fuf#defineLaunchCommand('FufFile', 'file', '""', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufFile  call fuf#launch('file', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#file#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#file#onInit

line 2:   call fuf#defineLaunchCommand('FufFileWithFullCwd'         , s:MODE_NAME, 'fnamemodify(getcwd(), '':p'')', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#file#onInit..fuf#defineLaunchCommand('FufFileWithFullCwd', 'file', 'fnamemodify(getcwd(), '':p'')', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufFileWithFullCwd  call fuf#launch('file', fnamemodify(getcwd(), ':p') . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#file#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#file#onInit

line 3:   call fuf#defineLaunchCommand('FufFileWithCurrentBufferDir', s:MODE_NAME, 'expand(''%:~:.'')[:-1-len(expand(''%:~:.:t''))]', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#file#onInit..fuf#defineLaunchCommand('FufFileWithCurrentBufferDir', 'file', 'expand(''%:~:.'')[:-1-len(expand(''%:~:.:t''))]', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufFileWithCurrentBufferDir  call fuf#launch('file', expand('%:~:.')[:-1-len(expand('%:~:.:t'))] . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#file#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#file#onInit

function <SNR>38_initialize..fuf#addMode..fuf#file#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#file#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#file#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 99:   call fuf#addMode('coveragefile')
calling function <SNR>38_initialize..fuf#addMode('coveragefile')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/coveragefile.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundl
Searching for "/home/max/.vim/autoload/fuf/coveragefile.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/coveragefile.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/coveragefile.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/coveragefile.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/coveragefile.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/coveragefile.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/coveragefile.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/coveragefile.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/coveragefile.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/coveragefile.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/coveragefile.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#coveragefile#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#coveragefile#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#coveragefile#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#coveragefile#renewCache()
line 34: 
line 35: "
line 36: function fuf#coveragefile#requiresOnCommandPre()
line 39: 
line 40: "
line 41: function fuf#coveragefile#onInit()
line 47: 
line 48: " }}}1
line 49: "=============================================================================
line 50: " LOCAL FUNCTIONS/VARIABLES {{{1
line 51: 
line 52: let s:MODE_NAME = expand('<sfile>:t:r')
line 53: 
line 54: "
line 55: function s:enumItems()
line 71: 
line 72: "
line 73: function s:registerCoverage()
line 97: 
line 98: "
line 99: function s:createChangeCoverageListener()
line 108: 
line 109: "
line 110: function s:changeCoverage(name)
line 130: 
line 131: " }}}1
line 132: "=============================================================================
line 133: " s:handler {{{1
line 134: 
line 135: let s:handler = {}
line 136: 
line 137: "
line 138: function s:handler.getModeName()
line 141: 
line 142: "
line 143: function s:handler.getPrompt()
line 149: 
line 150: "
line 151: function s:handler.getPreviewHeight()
line 154: 
line 155: "
line 156: function s:handler.isOpenable(enteredPattern)
line 159: 
line 160: "
line 161: function s:handler.makePatternSet(patternBase)
line 165: 
line 166: "
line 167: function s:handler.makePreviewLines(word, count)
line 170: 
line 171: "
line 172: function s:handler.getCompleteItems(patternPrimary)
line 175: 
line 176: "
line 177: function s:handler.onOpen(word, mode)
line 180: 
line 181: "
line 182: function s:handler.onModeEnterPre()
line 184: 
line 185: "
line 186: function s:handler.onModeEnterPost()
line 192: 
line 193: "
line 194: function s:handler.onModeLeavePost(opened)
line 196: 
line 197: " }}}1
line 198: "=============================================================================
line 199: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/coveragefile.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#coveragefile#renewCache()

line 1:   let s:cache = {}
function <SNR>38_initialize..fuf#addMode..fuf#coveragefile#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#coveragefile#onInit()

line 1:   call fuf#defineLaunchCommand('FufCoverageFile', s:MODE_NAME, '""', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#coveragefile#onInit..fuf#defineLaunchCommand('FufCoverageFile', 'coveragefile', '""', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufCoverageFile  call fuf#launch('coveragefile', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#coveragefile#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#coveragefile#onInit

line 2:   call l9#defineVariableDefault('g:fuf_coveragefile_name', '') " private option
calling function <SNR>38_initialize..fuf#addMode..fuf#coveragefile#onInit..l9#defineVariableDefault('g:fuf_coveragefile_name', '')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#coveragefile#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#coveragefile#onInit

line 3:   command! -bang -narg=0        FufCoverageFileRegister call s:registerCoverage()
line 4:   command! -bang -narg=?        FufCoverageFileChange call s:changeCoverage(<q-args>)
function <SNR>38_initialize..fuf#addMode..fuf#coveragefile#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#coveragefile#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#coveragefile#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 100:   call fuf#addMode('dir')
calling function <SNR>38_initialize..fuf#addMode('dir')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/dir.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFi
Searching for "/home/max/.vim/autoload/fuf/dir.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/dir.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/dir.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/dir.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/dir.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/dir.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/dir.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/dir.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/dir.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/dir.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/dir.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#dir#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#dir#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#dir#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#dir#renewCache()
line 34: 
line 35: "
line 36: function fuf#dir#requiresOnCommandPre()
line 39: 
line 40: "
line 41: function fuf#dir#onInit()
line 46: 
line 47: " }}}1
line 48: "=============================================================================
line 49: " LOCAL FUNCTIONS/VARIABLES {{{1
line 50: 
line 51: let s:MODE_NAME = expand('<sfile>:t:r')
line 52: 
line 53: "
line 54: function s:enumItems(dir)
line 67: 
line 68: " }}}1
line 69: "=============================================================================
line 70: " s:handler {{{1
line 71: 
line 72: let s:handler = {}
line 73: 
line 74: "
line 75: function s:handler.getModeName()
line 78: 
line 79: "
line 80: function s:handler.getPrompt()
line 83: 
line 84: "
line 85: function s:handler.getPreviewHeight()
line 88: 
line 89: "
line 90: function s:handler.isOpenable(enteredPattern)
line 93: 
line 94: "
line 95: function s:handler.makePatternSet(patternBase)
line 99: 
line 100: "
line 101: function s:handler.makePreviewLines(word, count)
line 107: 
line 108: "
line 109: function s:handler.getCompleteItems(patternPrimary)
line 112: 
line 113: "
line 114: function s:handler.onOpen(word, mode)
line 117: 
line 118: "
line 119: function s:handler.onModeEnterPre()
line 121: 
line 122: "
line 123: function s:handler.onModeEnterPost()
line 125: 
line 126: "
line 127: function s:handler.onModeLeavePost(opened)
line 129: 
line 130: " }}}1
line 131: "=============================================================================
line 132: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/dir.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#dir#renewCache()

line 1:   let s:cache = {}
function <SNR>38_initialize..fuf#addMode..fuf#dir#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#dir#onInit()

line 1:   call fuf#defineLaunchCommand('FufDir'                    , s:MODE_NAME, '""', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#dir#onInit..fuf#defineLaunchCommand('FufDir', 'dir', '""', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufDir  call fuf#launch('dir', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#dir#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#dir#onInit

line 2:   call fuf#defineLaunchCommand('FufDirWithFullCwd'         , s:MODE_NAME, 'fnamemodify(getcwd(), '':p'')', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#dir#onInit..fuf#defineLaunchCommand('FufDirWithFullCwd', 'dir', 'fnamemodify(getcwd(), '':p'')', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufDirWithFullCwd  call fuf#launch('dir', fnamemodify(getcwd(), ':p') . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#dir#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#dir#onInit

line 3:   call fuf#defineLaunchCommand('FufDirWithCurrentBufferDir', s:MODE_NAME, 'expand(''%:~:.'')[:-1-len(expand(''%:~:.:t''))]', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#dir#onInit..fuf#defineLaunchCommand('FufDirWithCurrentBufferDir', 'dir', 'expand(''%:~:.'')[:-1-len(expand(''%:~:.:t''))]', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufDirWithCurrentBufferDir  call fuf#launch('dir', expand('%:~:.')[:-1-len(expand('%:~:.:t'))] . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#dir#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#dir#onInit

function <SNR>38_initialize..fuf#addMode..fuf#dir#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#dir#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#dir#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 101:   call fuf#addMode('mrufile')
calling function <SNR>38_initialize..fuf#addMode('mrufile')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 102:   call fuf#addMode('mrucmd')
calling function <SNR>38_initialize..fuf#addMode('mrucmd')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 103:   call fuf#addMode('bookmarkfile')
calling function <SNR>38_initialize..fuf#addMode('bookmarkfile')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/bookmarkfile.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundl
Searching for "/home/max/.vim/autoload/fuf/bookmarkfile.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/bookmarkfile.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/bookmarkfile.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/bookmarkfile.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/bookmarkfile.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/bookmarkfile.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/bookmarkfile.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/bookmarkfile.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/bookmarkfile.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/bookmarkfile.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/bookmarkfile.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#bookmarkfile#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#bookmarkfile#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#bookmarkfile#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#bookmarkfile#renewCache()
line 33: 
line 34: "
line 35: function fuf#bookmarkfile#requiresOnCommandPre()
line 38: 
line 39: "
line 40: function fuf#bookmarkfile#onInit()
line 45: 
line 46: " }}}1
line 47: "=============================================================================
line 48: " LOCAL FUNCTIONS/VARIABLES {{{1
line 49: 
line 50: let s:MODE_NAME = expand('<sfile>:t:r')
line 51: let s:OPEN_TYPE_DELETE = -1
line 52: 
line 53: " opens a:path and jumps to the line matching to a:pattern from a:lnum within
line 54: " a:range. if not found, jumps to a:lnum.
line 55: function s:jumpToBookmark(path, mode, pattern, lnum)
line 60: 
line 61: "
line 62: function s:getMatchingLineNumber(lines, pattern, lnumBegin)
line 74: 
line 75: "
line 76: function s:getLinePattern(lnum)
line 79: 
line 80: "
line 81: function s:bookmarkHere(word)
line 103: 
line 104: "
line 105: function s:findItem(items, word)
line 113: 
line 114: " }}}1
line 115: "=============================================================================
line 116: " s:handler {{{1
line 117: 
line 118: let s:handler = {}
line 119: 
line 120: "
line 121: function s:handler.getModeName()
line 124: 
line 125: "
line 126: function s:handler.getPrompt()
line 129: 
line 130: "
line 131: function s:handler.getPreviewHeight()
line 134: 
line 135: "
line 136: function s:handler.isOpenable(enteredPattern)
line 139: 
line 140: "
line 141: function s:handler.makePatternSet(patternBase)
line 145: 
line 146: "
line 147: function s:handler.makePreviewLines(word, count)
line 157: 
line 158: "
line 159: function s:handler.getCompleteItems(patternPrimary)
line 162: 
line 163: "
line 164: function s:handler.onOpen(word, mode)
line 178: 
line 179: "
line 180: function s:handler.onModeEnterPre()
line 182: 
line 183: "
line 184: function s:handler.onModeEnterPost()
line 192: 
line 193: "
line 194: function s:handler.onModeLeavePost(opened)
line 196: 
line 197: " }}}1
line 198: "=============================================================================
line 199: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/bookmarkfile.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#bookmarkfile#renewCache()

function <SNR>38_initialize..fuf#addMode..fuf#bookmarkfile#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#bookmarkfile#onInit()

line 1:   call fuf#defineLaunchCommand('FufBookmarkFile', s:MODE_NAME, '""', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#bookmarkfile#onInit..fuf#defineLaunchCommand('FufBookmarkFile', 'bookmarkfile', '""', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufBookmarkFile  call fuf#launch('bookmarkfile', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#bookmarkfile#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#bookmarkfile#onInit

line 2:   command! -bang -narg=?        FufBookmarkFileAdd               call s:bookmarkHere(<q-args>)
line 3:   command! -bang -narg=0 -range FufBookmarkFileAddAsSelectedText call s:bookmarkHere(l9#getSelectedText())
function <SNR>38_initialize..fuf#addMode..fuf#bookmarkfile#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#bookmarkfile#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#bookmarkfile#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 104:   call fuf#addMode('bookmarkdir')
calling function <SNR>38_initialize..fuf#addMode('bookmarkdir')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/bookmarkdir.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle
Searching for "/home/max/.vim/autoload/fuf/bookmarkdir.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/bookmarkdir.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/bookmarkdir.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/bookmarkdir.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/bookmarkdir.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/bookmarkdir.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/bookmarkdir.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/bookmarkdir.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/bookmarkdir.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/bookmarkdir.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/bookmarkdir.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#bookmarkdir#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#bookmarkdir#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#bookmarkdir#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#bookmarkdir#renewCache()
line 33: 
line 34: "
line 35: function fuf#bookmarkdir#requiresOnCommandPre()
line 38: 
line 39: "
line 40: function fuf#bookmarkdir#onInit()
line 44: 
line 45: " }}}1
line 46: "=============================================================================
line 47: " LOCAL FUNCTIONS/VARIABLES {{{1
line 48: 
line 49: let s:MODE_NAME = expand('<sfile>:t:r')
line 50: let s:OPEN_TYPE_DELETE = -1
line 51: 
line 52: "
line 53: function s:bookmark(word)
line 74: 
line 75: "
line 76: function s:findItem(items, word)
line 84: 
line 85: " }}}1
line 86: "=============================================================================
line 87: " s:handler {{{1
line 88: 
line 89: let s:handler = {}
line 90: 
line 91: "
line 92: function s:handler.getModeName()
line 95: 
line 96: "
line 97: function s:handler.getPrompt()
line 100: 
line 101: "
line 102: function s:handler.getPreviewHeight()
line 105: 
line 106: "
line 107: function s:handler.isOpenable(enteredPattern)
line 110: 
line 111: "
line 112: function s:handler.makePatternSet(patternBase)
line 116: 
line 117: "
line 118: function s:handler.makePreviewLines(word, count)
line 121: 
line 122: "
line 123: function s:handler.getCompleteItems(patternPrimary)
line 126: 
line 127: "
line 128: function s:handler.onOpen(word, mode)
line 142: 
line 143: "
line 144: function s:handler.onModeEnterPre()
line 146: 
line 147: "
line 148: function s:handler.onModeEnterPost()
line 156: 
line 157: "
line 158: function s:handler.onModeLeavePost(opened)
line 160: 
line 161: " }}}1
line 162: "=============================================================================
line 163: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/bookmarkdir.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#bookmarkdir#renewCache()

function <SNR>38_initialize..fuf#addMode..fuf#bookmarkdir#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#bookmarkdir#onInit()

line 1:   call fuf#defineLaunchCommand('FufBookmarkDir', s:MODE_NAME, '""', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#bookmarkdir#onInit..fuf#defineLaunchCommand('FufBookmarkDir', 'bookmarkdir', '""', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufBookmarkDir  call fuf#launch('bookmarkdir', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#bookmarkdir#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#bookmarkdir#onInit

line 2:   command! -bang -narg=?        FufBookmarkDirAdd call s:bookmark(<q-args>)
function <SNR>38_initialize..fuf#addMode..fuf#bookmarkdir#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#bookmarkdir#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#bookmarkdir#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 105:   call fuf#addMode('tag')
calling function <SNR>38_initialize..fuf#addMode('tag')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/tag.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFi
Searching for "/home/max/.vim/autoload/fuf/tag.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/tag.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/tag.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/tag.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/tag.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/tag.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/tag.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/tag.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/tag.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/tag.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/tag.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#tag#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#tag#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#tag#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#tag#renewCache()
line 34: 
line 35: "
line 36: function fuf#tag#requiresOnCommandPre()
line 39: 
line 40: "
line 41: function fuf#tag#onInit()
line 45: 
line 46: " }}}1
line 47: "=============================================================================
line 48: " LOCAL FUNCTIONS/VARIABLES {{{1
line 49: 
line 50: let s:MODE_NAME = expand('<sfile>:t:r')
line 51: 
line 52: "
line 53: function s:getTagNames(tagFile)
line 57: 
line 58: "
line 59: function s:parseTagFiles(tagFiles, key)
line 72: 
line 73: "
line 74: function s:enumTags(tagFiles)
line 87: 
line 88: "
line 89: function s:getMatchingIndex(lines, cmd)
line 104: 
line 105: " }}}1
line 106: "=============================================================================
line 107: " s:handler {{{1
line 108: 
line 109: let s:handler = {}
line 110: 
line 111: "
line 112: function s:handler.getModeName()
line 115: 
line 116: "
line 117: function s:handler.getPrompt()
line 120: 
line 121: "
line 122: function s:handler.getPreviewHeight()
line 125: 
line 126: "
line 127: function s:handler.isOpenable(enteredPattern)
line 130: 
line 131: "
line 132: function s:handler.makePatternSet(patternBase)
line 136: 
line 137: " 'cmd' is '/^hoge hoge$/' or line number
line 138: function s:handler.makePreviewLines(word, count)
line 150: 
line 151: "
line 152: function s:handler.getCompleteItems(patternPrimary)
line 155: 
line 156: "
line 157: function s:handler.onOpen(word, mode)
line 160: 
line 161: "
line 162: function s:handler.onModeEnterPre()
line 165: 
line 166: "
line 167: function s:handler.onModeEnterPost()
line 170: 
line 171: "
line 172: function s:handler.onModeLeavePost(opened)
line 175: 
line 176: " }}}1
line 177: "=============================================================================
line 178: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/tag.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#tag#renewCache()

line 1:   let s:cache = {}
function <SNR>38_initialize..fuf#addMode..fuf#tag#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#tag#onInit()

line 1:   call fuf#defineLaunchCommand('FufTag'              , s:MODE_NAME, '""', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#tag#onInit..fuf#defineLaunchCommand('FufTag', 'tag', '""', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufTag  call fuf#launch('tag', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#tag#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#tag#onInit

line 2:   call fuf#defineLaunchCommand('FufTagWithCursorWord', s:MODE_NAME, 'expand(''<cword>'')', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#tag#onInit..fuf#defineLaunchCommand('FufTagWithCursorWord', 'tag', 'expand(''<cword>'')', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufTagWithCursorWord  call fuf#launch('tag', expand('<cword>') . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#tag#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#tag#onInit

function <SNR>38_initialize..fuf#addMode..fuf#tag#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#tag#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#tag#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 106:   call fuf#addMode('buffertag')
calling function <SNR>38_initialize..fuf#addMode('buffertag')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/buffertag.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/F
Searching for "/home/max/.vim/autoload/fuf/buffertag.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/buffertag.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/buffertag.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/buffertag.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/buffertag.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/buffertag.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/buffertag.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/buffertag.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/buffertag.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/buffertag.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/buffertag.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#buffertag#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#buffertag#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#buffertag#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#buffertag#renewCache()
line 35: 
line 36: "
line 37: function fuf#buffertag#requiresOnCommandPre()
line 40: 
line 41: "
line 42: function fuf#buffertag#onInit()
line 95: 
line 96: " }}}1
line 97: "=============================================================================
line 98: " LOCAL FUNCTIONS/VARIABLES {{{1
line 99: 
line 100: let s:MODE_NAME = expand('<sfile>:t:r')
line 101: 
line 102: "
line 103: function s:parseTagLine(line)
line 117: 
line 118: "
line 119: let s:TEMP_VARIABLES_GROUP = expand('<sfile>:p')
line 120: 
line 121: "
line 122: function s:getFileType(bufNr)
line 140: 
line 141: "
line 142: function s:makeCtagsCmd(bufNr)
line 154: 
line 155: "
line 156: function s:getTagItems(bufNr)
line 176: 
line 177: "
line 178: function s:makeItem(tag, itemMap)
line 187: 
line 188: "
line 189: function s:getTagData(bufNrs)
line 213: 
line 214: "
line 215: function s:jumpToTag(item, mode)
line 220: 
line 221: " }}}1
line 222: "=============================================================================
line 223: " s:handler {{{1
line 224: 
line 225: let s:handler = {}
line 226: 
line 227: "
line 228: function s:handler.getModeName()
line 231: 
line 232: "
line 233: function s:handler.getPrompt()
line 236: 
line 237: "
line 238: function s:handler.getPreviewHeight()
line 241: 
line 242: "
line 243: function s:handler.isOpenable(enteredPattern)
line 246: 
line 247: "
line 248: function s:handler.makePatternSet(patternBase)
line 252: 
line 253: "
line 254: function s:handler.makePreviewLines(word, count)
line 257: 
line 258: "
line 259: function s:handler.getCompleteItems(patternPrimary)
line 262: 
line 263: "
line 264: function s:handler.onOpen(word, mode)
line 279: 
line 280: "
line 281: function s:handler.onModeEnterPre()
line 283: 
line 284: "
line 285: function s:handler.onModeEnterPost()
line 293: 
line 294: "
line 295: function s:handler.onModeLeavePost(opened)
line 297: 
line 298: " }}}1
line 299: "=============================================================================
line 300: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/buffertag.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#renewCache()

line 1:   let s:tagItemsCache = {}
line 2:   let s:tagDataCache = {}
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit()

line 1:   call fuf#defineLaunchCommand('FufBufferTag', s:MODE_NAME, '""',                      [['g:fuf_buffertag_forAll', 0]])
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..fuf#defineLaunchCommand('FufBufferTag', 'buffertag', '""', [['g:fuf_buffertag_forAll', 0]])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufBufferTag call l9#tempvariables#setList('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf.vim', [['g:fuf_buffertag_forAll', 0]]) |  call fuf#launch('buffertag', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 3:   call fuf#defineLaunchCommand('FufBufferTagAll', s:MODE_NAME, '""',                      [['g:fuf_buffertag_forAll', 1]])
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..fuf#defineLaunchCommand('FufBufferTagAll', 'buffertag', '""', [['g:fuf_buffertag_forAll', 1]])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufBufferTagAll call l9#tempvariables#setList('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf.vim', [['g:fuf_buffertag_forAll', 1]]) |  call fuf#launch('buffertag', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 5:   call fuf#defineLaunchCommand('FufBufferTagWithCursorWord', s:MODE_NAME,                      'expand(''<cword>'')', [['g:fuf_buffertag_forAll', 0]])
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..fuf#defineLaunchCommand('FufBufferTagWithCursorWord', 'buffertag', 'expand(''<cword>'')', [['g:fuf_buffertag_forAll', 0]])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufBufferTagWithCursorWord call l9#tempvariables#setList('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf.vim', [['g:fuf_buffertag_forAll', 0]]) |  call fuf#launch('buffertag', expand('<cword>') . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 7:   call fuf#defineLaunchCommand('FufBufferTagAllWithCursorWord', s:MODE_NAME,                      'expand(''<cword>'')', [['g:fuf_buffertag_forAll', 1]])
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..fuf#defineLaunchCommand('FufBufferTagAllWithCursorWord', 'buffertag', 'expand(''<cword>'')', [['g:fuf_buffertag_forAll', 1]])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufBufferTagAllWithCursorWord call l9#tempvariables#setList('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf.vim', [['g:fuf_buffertag_forAll', 1]]) |  call fuf#launch('buffertag', expand('<cword>') . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 9:   call fuf#defineLaunchCommand('FufBufferTagWithSelectedText', s:MODE_NAME,                      'l9#getSelectedText()', [['g:fuf_buffertag_forAll', 0]])
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..fuf#defineLaunchCommand('FufBufferTagWithSelectedText', 'buffertag', 'l9#getSelectedText()', [['g:fuf_buffertag_forAll', 0]])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufBufferTagWithSelectedText call l9#tempvariables#setList('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf.vim', [['g:fuf_buffertag_forAll', 0]]) |  call fuf#launch('buffertag', l9#getSelectedText() . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 11:   call fuf#defineLaunchCommand('FufBufferTagAllWithSelectedText', s:MODE_NAME,                      'l9#getSelectedText()', [['g:fuf_buffertag_forAll', 1]])
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..fuf#defineLaunchCommand('FufBufferTagAllWithSelectedText', 'buffertag', 'l9#getSelectedText()', [['g:fuf_buffertag_forAll', 1]])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufBufferTagAllWithSelectedText call l9#tempvariables#setList('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf.vim', [['g:fuf_buffertag_forAll', 1]]) |  call fuf#launch('buffertag', l9#getSelectedText() . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 13:   call l9#defineVariableDefault('g:fuf_buffertag_forAll', 0) " private option
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag_forAll', 0)

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 14:   " the following settings originate from taglist.vim
line 15:   call l9#defineVariableDefault('g:fuf_buffertag__asm'       , '--language-force=asm --asm-types=dlmt')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__asm', '--language-force=asm --asm-types=dlmt')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 16:   call l9#defineVariableDefault('g:fuf_buffertag__aspperl'   , '--language-force=asp --asp-types=fsv')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__aspperl', '--language-force=asp --asp-types=fsv')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 17:   call l9#defineVariableDefault('g:fuf_buffertag__aspvbs'    , '--language-force=asp --asp-types=fsv')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__aspvbs', '--language-force=asp --asp-types=fsv')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 18:   call l9#defineVariableDefault('g:fuf_buffertag__awk'       , '--language-force=awk --awk-types=f')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__awk', '--language-force=awk --awk-types=f')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 19:   call l9#defineVariableDefault('g:fuf_buffertag__beta'      , '--language-force=beta --beta-types=fsv')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__beta', '--language-force=beta --beta-types=fsv')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 20:   call l9#defineVariableDefault('g:fuf_buffertag__c'         , '--language-force=c --c-types=dgsutvf')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__c', '--language-force=c --c-types=dgsutvf')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 21:   call l9#defineVariableDefault('g:fuf_buffertag__cpp'       , '--language-force=c++ --c++-types=nvdtcgsuf')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__cpp', '--language-force=c++ --c++-types=nvdtcgsuf')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 22:   call l9#defineVariableDefault('g:fuf_buffertag__cs'        , '--language-force=c# --c#-types=dtncEgsipm')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__cs', '--language-force=c# --c#-types=dtncEgsipm')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 23:   call l9#defineVariableDefault('g:fuf_buffertag__cobol'     , '--language-force=cobol --cobol-types=dfgpPs')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__cobol', '--language-force=cobol --cobol-types=dfgpPs')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 24:   call l9#defineVariableDefault('g:fuf_buffertag__eiffel'    , '--language-force=eiffel --eiffel-types=cf')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__eiffel', '--language-force=eiffel --eiffel-types=cf')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 25:   call l9#defineVariableDefault('g:fuf_buffertag__erlang'    , '--language-force=erlang --erlang-types=drmf')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__erlang', '--language-force=erlang --erlang-types=drmf')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 26:   call l9#defineVariableDefault('g:fuf_buffertag__expect'    , '--language-force=tcl --tcl-types=cfp')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__expect', '--language-force=tcl --tcl-types=cfp')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 27:   call l9#defineVariableDefault('g:fuf_buffertag__fortran'   , '--language-force=fortran --fortran-types=pbceiklmntvfs')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__fortran', '--language-force=fortran --fortran-types=pbceiklmntvfs')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 28:   call l9#defineVariableDefault('g:fuf_buffertag__html'      , '--language-force=html --html-types=af')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__html', '--language-force=html --html-types=af')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 29:   call l9#defineVariableDefault('g:fuf_buffertag__java'      , '--language-force=java --java-types=pcifm')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__java', '--language-force=java --java-types=pcifm')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 30:   call l9#defineVariableDefault('g:fuf_buffertag__javascript', '--language-force=javascript --javascript-types=f')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__javascript', '--language-force=javascript --javascript-types=f')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 31:   call l9#defineVariableDefault('g:fuf_buffertag__lisp'      , '--language-force=lisp --lisp-types=f')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__lisp', '--language-force=lisp --lisp-types=f')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 32:   call l9#defineVariableDefault('g:fuf_buffertag__lua'       , '--language-force=lua --lua-types=f')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__lua', '--language-force=lua --lua-types=f')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 33:   call l9#defineVariableDefault('g:fuf_buffertag__make'      , '--language-force=make --make-types=m')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__make', '--language-force=make --make-types=m')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 34:   call l9#defineVariableDefault('g:fuf_buffertag__pascal'    , '--language-force=pascal --pascal-types=fp')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__pascal', '--language-force=pascal --pascal-types=fp')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 35:   call l9#defineVariableDefault('g:fuf_buffertag__perl'      , '--language-force=perl --perl-types=clps')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__perl', '--language-force=perl --perl-types=clps')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 36:   call l9#defineVariableDefault('g:fuf_buffertag__php'       , '--language-force=php --php-types=cdvf')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__php', '--language-force=php --php-types=cdvf')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 37:   call l9#defineVariableDefault('g:fuf_buffertag__python'    , '--language-force=python --python-types=cmf')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__python', '--language-force=python --python-types=cmf')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 38:   call l9#defineVariableDefault('g:fuf_buffertag__rexx'      , '--language-force=rexx --rexx-types=s')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__rexx', '--language-force=rexx --rexx-types=s')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 39:   call l9#defineVariableDefault('g:fuf_buffertag__ruby'      , '--language-force=ruby --ruby-types=cfFm')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__ruby', '--language-force=ruby --ruby-types=cfFm')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 40:   call l9#defineVariableDefault('g:fuf_buffertag__scheme'    , '--language-force=scheme --scheme-types=sf')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__scheme', '--language-force=scheme --scheme-types=sf')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 41:   call l9#defineVariableDefault('g:fuf_buffertag__sh'        , '--language-force=sh --sh-types=f')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__sh', '--language-force=sh --sh-types=f')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 42:   call l9#defineVariableDefault('g:fuf_buffertag__csh'       , '--language-force=sh --sh-types=f')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__csh', '--language-force=sh --sh-types=f')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 43:   call l9#defineVariableDefault('g:fuf_buffertag__zsh'       , '--language-force=sh --sh-types=f')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__zsh', '--language-force=sh --sh-types=f')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 44:   call l9#defineVariableDefault('g:fuf_buffertag__slang'     , '--language-force=slang --slang-types=nf')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__slang', '--language-force=slang --slang-types=nf')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 45:   call l9#defineVariableDefault('g:fuf_buffertag__sml'       , '--language-force=sml --sml-types=ecsrtvf')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__sml', '--language-force=sml --sml-types=ecsrtvf')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 46:   call l9#defineVariableDefault('g:fuf_buffertag__sql'       , '--language-force=sql --sql-types=cFPrstTvfp')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__sql', '--language-force=sql --sql-types=cFPrstTvfp')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 47:   call l9#defineVariableDefault('g:fuf_buffertag__tcl'       , '--language-force=tcl --tcl-types=cfmp')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__tcl', '--language-force=tcl --tcl-types=cfmp')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 48:   call l9#defineVariableDefault('g:fuf_buffertag__vera'      , '--language-force=vera --vera-types=cdefgmpPtTvx')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__vera', '--language-force=vera --vera-types=cdefgmpPtTvx')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 49:   call l9#defineVariableDefault('g:fuf_buffertag__verilog'   , '--language-force=verilog --verilog-types=mcPertwpvf')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__verilog', '--language-force=verilog --verilog-types=mcPertwpvf')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 50:   call l9#defineVariableDefault('g:fuf_buffertag__vim'       , '--language-force=vim --vim-types=avf')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__vim', '--language-force=vim --vim-types=avf')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

line 51:   call l9#defineVariableDefault('g:fuf_buffertag__yacc'      , '--language-force=yacc --yacc-types=l')
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault('g:fuf_buffertag__yacc', '--language-force=yacc --yacc-types=l')

line 1:   if !exists(a:name)
line 2:     let {a:name} = a:default
line 3:   endif
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit..l9#defineVariableDefault returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit

function <SNR>38_initialize..fuf#addMode..fuf#buffertag#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#buffertag#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#buffertag#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 107:   call fuf#addMode('taggedfile')
calling function <SNR>38_initialize..fuf#addMode('taggedfile')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/taggedfile.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/
Searching for "/home/max/.vim/autoload/fuf/taggedfile.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/taggedfile.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/taggedfile.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/taggedfile.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/taggedfile.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/taggedfile.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/taggedfile.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/taggedfile.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/taggedfile.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/taggedfile.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/taggedfile.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#taggedfile#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#taggedfile#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#taggedfile#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#taggedfile#renewCache()
line 34: 
line 35: "
line 36: function fuf#taggedfile#requiresOnCommandPre()
line 39: 
line 40: "
line 41: function fuf#taggedfile#onInit()
line 44: 
line 45: " }}}1
line 46: "=============================================================================
line 47: " LOCAL FUNCTIONS/VARIABLES {{{1
line 48: 
line 49: let s:MODE_NAME = expand('<sfile>:t:r')
line 50: 
line 51: "
line 52: function s:getTaggedFileList(tagfile)
line 60: 
line 61: "
line 62: function s:parseTagFiles(tagFiles, key)
line 75: 
line 76: "
line 77: function s:enumTaggedFiles(tagFiles)
line 90: 
line 91: " }}}1
line 92: "=============================================================================
line 93: " s:handler {{{1
line 94: 
line 95: let s:handler = {}
line 96: 
line 97: "
line 98: function s:handler.getModeName()
line 101: 
line 102: "
line 103: function s:handler.getPrompt()
line 106: 
line 107: "
line 108: function s:handler.getPreviewHeight()
line 111: 
line 112: "
line 113: function s:handler.isOpenable(enteredPattern)
line 116: 
line 117: "
line 118: function s:handler.makePatternSet(patternBase)
line 122: 
line 123: "
line 124: function s:handler.makePreviewLines(word, count)
line 127: 
line 128: "
line 129: function s:handler.getCompleteItems(patternPrimary)
line 132: 
line 133: "
line 134: function s:handler.onOpen(word, mode)
line 137: 
line 138: "
line 139: function s:handler.onModeEnterPre()
line 142: 
line 143: "
line 144: function s:handler.onModeEnterPost()
line 152: 
line 153: "
line 154: function s:handler.onModeLeavePost(opened)
line 156: 
line 157: " }}}1
line 158: "=============================================================================
line 159: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/taggedfile.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#taggedfile#renewCache()

line 1:   let s:cache = {}
function <SNR>38_initialize..fuf#addMode..fuf#taggedfile#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#taggedfile#onInit()

line 1:   call fuf#defineLaunchCommand('FufTaggedFile', s:MODE_NAME, '""', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#taggedfile#onInit..fuf#defineLaunchCommand('FufTaggedFile', 'taggedfile', '""', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufTaggedFile  call fuf#launch('taggedfile', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#taggedfile#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#taggedfile#onInit

function <SNR>38_initialize..fuf#addMode..fuf#taggedfile#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#taggedfile#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#taggedfile#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 108:   call fuf#addMode('jumplist')
calling function <SNR>38_initialize..fuf#addMode('jumplist')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/jumplist.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/Fu
Searching for "/home/max/.vim/autoload/fuf/jumplist.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/jumplist.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/jumplist.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/jumplist.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/jumplist.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/jumplist.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/jumplist.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/jumplist.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/jumplist.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/jumplist.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/jumplist.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#jumplist#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#jumplist#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#jumplist#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#jumplist#renewCache()
line 33: 
line 34: "
line 35: function fuf#jumplist#requiresOnCommandPre()
line 38: 
line 39: "
line 40: function fuf#jumplist#onInit()
line 43: 
line 44: " }}}1
line 45: "=============================================================================
line 46: " LOCAL FUNCTIONS/VARIABLES {{{1
line 47: 
line 48: let s:MODE_NAME = expand('<sfile>:t:r')
line 49: 
line 50: "
line 51: function s:getJumpsLines()
line 57: 
line 58: "
line 59: function s:parseJumpsLine(line, bufnrPrev)
line 81: 
line 82: "
line 83: function s:makeItem(line, bufnrPrev)
line 94: 
line 95: " }}}1
line 96: "=============================================================================
line 97: " s:handler {{{1
line 98: 
line 99: let s:handler = {}
line 100: 
line 101: "
line 102: function s:handler.getModeName()
line 105: 
line 106: "
line 107: function s:handler.getPrompt()
line 110: 
line 111: "
line 112: function s:handler.getPreviewHeight()
line 115: 
line 116: "
line 117: function s:handler.isOpenable(enteredPattern)
line 120: 
line 121: "
line 122: function s:handler.makePatternSet(patternBase)
line 126: 
line 127: "
line 128: function s:handler.makePreviewLines(word, count)
line 137: 
line 138: "
line 139: function s:handler.getCompleteItems(patternPrimary)
line 142: 
line 143: "
line 144: function s:handler.onOpen(word, mode)
line 160: 
line 161: "
line 162: function s:handler.onModeEnterPre()
line 165: 
line 166: "
line 167: function s:handler.onModeEnterPost()
line 174: 
line 175: "
line 176: function s:handler.onModeLeavePost(opened)
line 178: 
line 179: " }}}1
line 180: "=============================================================================
line 181: " vim: set fdm=marker:
line 182: 
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/jumplist.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#jumplist#renewCache()

function <SNR>38_initialize..fuf#addMode..fuf#jumplist#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#jumplist#onInit()

line 1:   call fuf#defineLaunchCommand('FufJumpList', s:MODE_NAME, '""', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#jumplist#onInit..fuf#defineLaunchCommand('FufJumpList', 'jumplist', '""', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufJumpList  call fuf#launch('jumplist', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#jumplist#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#jumplist#onInit

function <SNR>38_initialize..fuf#addMode..fuf#jumplist#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#jumplist#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#jumplist#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 109:   call fuf#addMode('changelist')
calling function <SNR>38_initialize..fuf#addMode('changelist')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/changelist.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/
Searching for "/home/max/.vim/autoload/fuf/changelist.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/changelist.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/changelist.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/changelist.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/changelist.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/changelist.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/changelist.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/changelist.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/changelist.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/changelist.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/changelist.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#changelist#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#changelist#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#changelist#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#changelist#renewCache()
line 33: 
line 34: "
line 35: function fuf#changelist#requiresOnCommandPre()
line 38: 
line 39: "
line 40: function fuf#changelist#onInit()
line 43: 
line 44: " }}}1
line 45: "=============================================================================
line 46: " LOCAL FUNCTIONS/VARIABLES {{{1
line 47: 
line 48: let s:MODE_NAME = expand('<sfile>:t:r')
line 49: 
line 50: "
line 51: function s:getChangesLines()
line 57: 
line 58: "
line 59: function s:parseChangesLine(line)
line 72: 
line 73: "
line 74: function s:makeItem(line)
line 84: 
line 85: " }}}1
line 86: "=============================================================================
line 87: " s:handler {{{1
line 88: 
line 89: let s:handler = {}
line 90: 
line 91: "
line 92: function s:handler.getModeName()
line 95: 
line 96: "
line 97: function s:handler.getPrompt()
line 100: 
line 101: "
line 102: function s:handler.getPreviewHeight()
line 105: 
line 106: "
line 107: function s:handler.isOpenable(enteredPattern)
line 110: 
line 111: "
line 112: function s:handler.makePatternSet(patternBase)
line 116: 
line 117: "
line 118: function s:handler.makePreviewLines(word, count)
line 127: 
line 128: "
line 129: function s:handler.getCompleteItems(patternPrimary)
line 132: 
line 133: "
line 134: function s:handler.onOpen(word, mode)
line 150: 
line 151: "
line 152: function s:handler.onModeEnterPre()
line 155: 
line 156: "
line 157: function s:handler.onModeEnterPost()
line 164: 
line 165: "
line 166: function s:handler.onModeLeavePost(opened)
line 168: 
line 169: " }}}1
line 170: "=============================================================================
line 171: " vim: set fdm=marker:
line 172: 
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/changelist.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#changelist#renewCache()

function <SNR>38_initialize..fuf#addMode..fuf#changelist#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#changelist#onInit()

line 1:   call fuf#defineLaunchCommand('FufChangeList', s:MODE_NAME, '""', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#changelist#onInit..fuf#defineLaunchCommand('FufChangeList', 'changelist', '""', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufChangeList  call fuf#launch('changelist', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#changelist#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#changelist#onInit

function <SNR>38_initialize..fuf#addMode..fuf#changelist#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#changelist#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#changelist#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 110:   call fuf#addMode('quickfix')
calling function <SNR>38_initialize..fuf#addMode('quickfix')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/quickfix.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/Fu
Searching for "/home/max/.vim/autoload/fuf/quickfix.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/quickfix.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/quickfix.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/quickfix.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/quickfix.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/quickfix.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/quickfix.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/quickfix.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/quickfix.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/quickfix.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/quickfix.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#quickfix#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#quickfix#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#quickfix#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#quickfix#renewCache()
line 33: 
line 34: "
line 35: function fuf#quickfix#requiresOnCommandPre()
line 38: 
line 39: "
line 40: function fuf#quickfix#onInit()
line 43: 
line 44: " }}}1
line 45: "=============================================================================
line 46: " LOCAL FUNCTIONS/VARIABLES {{{1
line 47: 
line 48: let s:MODE_NAME = expand('<sfile>:t:r')
line 49: 
line 50: "
line 51: function s:getJumpsLines()
line 57: 
line 58: "
line 59: function s:parseJumpsLine(line)
line 62: 
line 63: "
line 64: function s:makeItem(qfItem)
line 76: 
line 77: " }}}1
line 78: "=============================================================================
line 79: " s:handler {{{1
line 80: 
line 81: let s:handler = {}
line 82: 
line 83: "
line 84: function s:handler.getModeName()
line 87: 
line 88: "
line 89: function s:handler.getPrompt()
line 92: 
line 93: "
line 94: function s:handler.getPreviewHeight()
line 97: 
line 98: "
line 99: function s:handler.isOpenable(enteredPattern)
line 102: 
line 103: "
line 104: function s:handler.makePatternSet(patternBase)
line 108: 
line 109: "
line 110: function s:handler.makePreviewLines(word, count)
line 119: 
line 120: "
line 121: function s:handler.getCompleteItems(patternPrimary)
line 124: 
line 125: "
line 126: function s:handler.onOpen(word, mode)
line 133: 
line 134: "
line 135: function s:handler.onModeEnterPre()
line 137: 
line 138: "
line 139: function s:handler.onModeEnterPost()
line 146: 
line 147: "
line 148: function s:handler.onModeLeavePost(opened)
line 150: 
line 151: " }}}1
line 152: "=============================================================================
line 153: " vim: set fdm=marker:
line 154: 
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/quickfix.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#quickfix#renewCache()

function <SNR>38_initialize..fuf#addMode..fuf#quickfix#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#quickfix#onInit()

line 1:   call fuf#defineLaunchCommand('FufQuickfix', s:MODE_NAME, '""', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#quickfix#onInit..fuf#defineLaunchCommand('FufQuickfix', 'quickfix', '""', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufQuickfix  call fuf#launch('quickfix', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#quickfix#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#quickfix#onInit

function <SNR>38_initialize..fuf#addMode..fuf#quickfix#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#quickfix#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#quickfix#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 111:   call fuf#addMode('line')
calling function <SNR>38_initialize..fuf#addMode('line')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/line.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyF
Searching for "/home/max/.vim/autoload/fuf/line.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/line.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/line.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/line.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/line.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/line.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/line.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/line.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/line.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/line.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/line.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#line#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#line#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#line#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#line#renewCache()
line 33: 
line 34: "
line 35: function fuf#line#requiresOnCommandPre()
line 38: 
line 39: "
line 40: function fuf#line#onInit()
line 43: 
line 44: " }}}1
line 45: "=============================================================================
line 46: " LOCAL FUNCTIONS/VARIABLES {{{1
line 47: 
line 48: let s:MODE_NAME = expand('<sfile>:t:r')
line 49: let s:OPEN_TYPE_DELETE = -1
line 50: 
line 51: " }}}1
line 52: "=============================================================================
line 53: " s:handler {{{1
line 54: 
line 55: let s:handler = {}
line 56: 
line 57: "
line 58: function s:handler.getModeName()
line 61: 
line 62: "
line 63: function s:handler.getPrompt()
line 66: 
line 67: "
line 68: function s:handler.getPreviewHeight()
line 71: 
line 72: "
line 73: function s:handler.isOpenable(enteredPattern)
line 76: 
line 77: "
line 78: function s:handler.makePatternSet(patternBase)
line 82: 
line 83: "
line 84: function s:handler.makePreviewLines(word, count)
line 93: 
line 94: "
line 95: function s:handler.getCompleteItems(patternPrimary)
line 98: 
line 99: "
line 100: function s:handler.onOpen(word, mode)
line 110: 
line 111: "
line 112: function s:handler.onModeEnterPre()
line 114: 
line 115: "
line 116: function s:handler.onModeEnterPost()
line 128: 
line 129: "
line 130: function s:handler.onModeLeavePost(opened)
line 132: 
line 133: " }}}1
line 134: "=============================================================================
line 135: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/line.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#line#renewCache()

function <SNR>38_initialize..fuf#addMode..fuf#line#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#line#onInit()

line 1:   call fuf#defineLaunchCommand('FufLine', s:MODE_NAME, '""', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#line#onInit..fuf#defineLaunchCommand('FufLine', 'line', '""', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufLine  call fuf#launch('line', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#line#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#line#onInit

function <SNR>38_initialize..fuf#addMode..fuf#line#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#line#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#line#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 112:   call fuf#addMode('help')
calling function <SNR>38_initialize..fuf#addMode('help')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/help.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyF
Searching for "/home/max/.vim/autoload/fuf/help.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/help.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/help.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/help.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/help.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/help.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/help.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/help.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/help.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/help.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/help.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#help#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#help#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#help#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#help#renewCache()
line 34: 
line 35: "
line 36: function fuf#help#requiresOnCommandPre()
line 39: 
line 40: "
line 41: function fuf#help#onInit()
line 45: 
line 46: " }}}1
line 47: "=============================================================================
line 48: " LOCAL FUNCTIONS/VARIABLES {{{1
line 49: 
line 50: let s:MODE_NAME = expand('<sfile>:t:r')
line 51: 
line 52: "
line 53: function s:getCurrentHelpTagFiles()
line 59: 
line 60: "
line 61: function s:parseHelpTagEntry(line, tagFile)
line 79: 
line 80: "
line 81: function s:getHelpTagEntries(tagFile)
line 85: 
line 86: "
line 87: function s:parseHelpTagFiles(tagFiles, key)
line 100: 
line 101: "
line 102: function s:enumHelpTags(tagFiles)
line 115: 
line 116: "
line 117: function s:getMatchingIndex(lines, pattern)
line 128: 
line 129: " }}}1
line 130: "=============================================================================
line 131: " s:handler {{{1
line 132: 
line 133: let s:handler = {}
line 134: 
line 135: "
line 136: function s:handler.getModeName()
line 139: 
line 140: "
line 141: function s:handler.getPrompt()
line 144: 
line 145: "
line 146: function s:handler.getPreviewHeight()
line 149: 
line 150: "
line 151: function s:handler.isOpenable(enteredPattern)
line 154: 
line 155: "
line 156: function s:handler.makePatternSet(patternBase)
line 160: 
line 161: "
line 162: function s:handler.makePreviewLines(word, count)
line 172: 
line 173: "
line 174: function s:handler.getCompleteItems(patternPrimary)
line 177: 
line 178: "
line 179: function s:handler.onOpen(word, mode)
line 182: 
line 183: "
line 184: function s:handler.onModeEnterPre()
line 187: 
line 188: "
line 189: function s:handler.onModeEnterPost()
line 191: 
line 192: "
line 193: function s:handler.onModeLeavePost(opened)
line 195: 
line 196: " }}}1
line 197: "=============================================================================
line 198: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/help.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#help#renewCache()

line 1:   let s:cache = {}
function <SNR>38_initialize..fuf#addMode..fuf#help#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#help#onInit()

line 1:   call fuf#defineLaunchCommand('FufHelp'              , s:MODE_NAME, '""', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#help#onInit..fuf#defineLaunchCommand('FufHelp', 'help', '""', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufHelp  call fuf#launch('help', "" . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#help#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#help#onInit

line 2:   call fuf#defineLaunchCommand('FufHelpWithCursorWord', s:MODE_NAME, 'expand(''<cword>'')', [])
calling function <SNR>38_initialize..fuf#addMode..fuf#help#onInit..fuf#defineLaunchCommand('FufHelpWithCursorWord', 'help', 'expand(''<cword>'')', [])

line 1:   if empty(a:tempVars)
line 2:     let preCmd = ''
line 3:   else
line 4:     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
line 6:   endif
line 7:   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
line 7: command! -range -bang -narg=? FufHelpWithCursorWord  call fuf#launch('help', expand('<cword>') . <q-args>, len(<q-bang>))
function <SNR>38_initialize..fuf#addMode..fuf#help#onInit..fuf#defineLaunchCommand returning #0

continuing in function <SNR>38_initialize..fuf#addMode..fuf#help#onInit

function <SNR>38_initialize..fuf#addMode..fuf#help#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#help#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#help#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 113:   call fuf#addMode('givenfile')
calling function <SNR>38_initialize..fuf#addMode('givenfile')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/givenfile.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/F
Searching for "/home/max/.vim/autoload/fuf/givenfile.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/givenfile.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/givenfile.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/givenfile.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/givenfile.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/givenfile.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/givenfile.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givenfile.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givenfile.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givenfile.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givenfile.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#givenfile#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#givenfile#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#givenfile#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#givenfile#renewCache()
line 33: 
line 34: "
line 35: function fuf#givenfile#requiresOnCommandPre()
line 38: 
line 39: "
line 40: function fuf#givenfile#onInit()
line 42: 
line 43: "
line 44: function fuf#givenfile#launch(initialPattern, partialMatching, prompt, items)
line 51: 
line 52: 
line 53: " }}}1
line 54: "=============================================================================
line 55: " LOCAL FUNCTIONS/VARIABLES {{{1
line 56: 
line 57: let s:MODE_NAME = expand('<sfile>:t:r')
line 58: 
line 59: " }}}1
line 60: "=============================================================================
line 61: " s:handler {{{1
line 62: 
line 63: let s:handler = {}
line 64: 
line 65: "
line 66: function s:handler.getModeName()
line 69: 
line 70: "
line 71: function s:handler.getPrompt()
line 74: 
line 75: "
line 76: function s:handler.getPreviewHeight()
line 79: 
line 80: "
line 81: function s:handler.isOpenable(enteredPattern)
line 84: 
line 85: "
line 86: function s:handler.makePatternSet(patternBase)
line 90: 
line 91: "
line 92: function s:handler.makePreviewLines(word, count)
line 95: 
line 96: "
line 97: function s:handler.getCompleteItems(patternPrimary)
line 100: 
line 101: "
line 102: function s:handler.onOpen(word, mode)
line 105: 
line 106: 
line 107: "
line 108: function s:handler.onModeEnterPre()
line 110: 
line 111: "
line 112: function s:handler.onModeEnterPost()
line 114: 
line 115: "
line 116: function s:handler.onModeLeavePost(opened)
line 118: 
line 119: " }}}1
line 120: "=============================================================================
line 121: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givenfile.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#givenfile#renewCache()

function <SNR>38_initialize..fuf#addMode..fuf#givenfile#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#givenfile#onInit()

function <SNR>38_initialize..fuf#addMode..fuf#givenfile#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#givenfile#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#givenfile#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 114:   call fuf#addMode('givendir')
calling function <SNR>38_initialize..fuf#addMode('givendir')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/givendir.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/Fu
Searching for "/home/max/.vim/autoload/fuf/givendir.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/givendir.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/givendir.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/givendir.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/givendir.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/givendir.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/givendir.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givendir.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givendir.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givendir.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givendir.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#givendir#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#givendir#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#givendir#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#givendir#renewCache()
line 33: 
line 34: "
line 35: function fuf#givendir#requiresOnCommandPre()
line 38: 
line 39: "
line 40: function fuf#givendir#onInit()
line 42: 
line 43: "
line 44: function fuf#givendir#launch(initialPattern, partialMatching, prompt, items)
line 52: 
line 53: " }}}1
line 54: "=============================================================================
line 55: " LOCAL FUNCTIONS/VARIABLES {{{1
line 56: 
line 57: let s:MODE_NAME = expand('<sfile>:t:r')
line 58: 
line 59: " }}}1
line 60: "=============================================================================
line 61: " s:handler {{{1
line 62: 
line 63: let s:handler = {}
line 64: 
line 65: "
line 66: function s:handler.getModeName()
line 69: 
line 70: "
line 71: function s:handler.getPrompt()
line 74: 
line 75: "
line 76: function s:handler.getPreviewHeight()
line 79: 
line 80: "
line 81: function s:handler.isOpenable(enteredPattern)
line 84: 
line 85: "
line 86: function s:handler.makePatternSet(patternBase)
line 90: 
line 91: "
line 92: function s:handler.makePreviewLines(word, count)
line 98: 
line 99: "
line 100: function s:handler.getCompleteItems(patternPrimary)
line 103: 
line 104: "
line 105: function s:handler.onOpen(word, mode)
line 108: 
line 109: "
line 110: function s:handler.onModeEnterPre()
line 112: 
line 113: "
line 114: function s:handler.onModeEnterPost()
line 116: 
line 117: "
line 118: function s:handler.onModeLeavePost(opened)
line 120: 
line 121: " }}}1
line 122: "=============================================================================
line 123: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givendir.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#givendir#renewCache()

function <SNR>38_initialize..fuf#addMode..fuf#givendir#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#givendir#onInit()

function <SNR>38_initialize..fuf#addMode..fuf#givendir#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#givendir#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#givendir#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 115:   call fuf#addMode('givencmd')
calling function <SNR>38_initialize..fuf#addMode('givencmd')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/givencmd.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/Fu
Searching for "/home/max/.vim/autoload/fuf/givencmd.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/givencmd.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/givencmd.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/givencmd.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/givencmd.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/givencmd.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/givencmd.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givencmd.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givencmd.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givencmd.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givencmd.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#givencmd#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#givencmd#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#givencmd#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#givencmd#renewCache()
line 33: 
line 34: "
line 35: function fuf#givencmd#requiresOnCommandPre()
line 38: 
line 39: "
line 40: function fuf#givencmd#onInit()
line 42: 
line 43: "
line 44: function fuf#givencmd#launch(initialPattern, partialMatching, prompt, items)
line 52: 
line 53: " }}}1
line 54: "=============================================================================
line 55: " LOCAL FUNCTIONS/VARIABLES {{{1
line 56: 
line 57: let s:MODE_NAME = expand('<sfile>:t:r')
line 58: 
line 59: " }}}1
line 60: "=============================================================================
line 61: " s:handler {{{1
line 62: 
line 63: let s:handler = {}
line 64: 
line 65: "
line 66: function s:handler.getModeName()
line 69: 
line 70: "
line 71: function s:handler.getPrompt()
line 74: 
line 75: "
line 76: function s:handler.getPreviewHeight()
line 79: 
line 80: "
line 81: function s:handler.isOpenable(enteredPattern)
line 84: 
line 85: "
line 86: function s:handler.makePatternSet(patternBase)
line 90: 
line 91: "
line 92: function s:handler.makePreviewLines(word, count)
line 95: 
line 96: "
line 97: function s:handler.getCompleteItems(patternPrimary)
line 100: 
line 101: "
line 102: function s:handler.onOpen(word, mode)
line 108: 
line 109: "
line 110: function s:handler.onModeEnterPre()
line 112: 
line 113: "
line 114: function s:handler.onModeEnterPost()
line 116: 
line 117: "
line 118: function s:handler.onModeLeavePost(opened)
line 120: 
line 121: " }}}1
line 122: "=============================================================================
line 123: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/givencmd.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#givencmd#renewCache()

function <SNR>38_initialize..fuf#addMode..fuf#givencmd#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#givencmd#onInit()

function <SNR>38_initialize..fuf#addMode..fuf#givencmd#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#givencmd#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#givencmd#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 116:   call fuf#addMode('callbackfile')
calling function <SNR>38_initialize..fuf#addMode('callbackfile')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/callbackfile.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundl
Searching for "/home/max/.vim/autoload/fuf/callbackfile.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/callbackfile.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/callbackfile.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/callbackfile.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/callbackfile.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/callbackfile.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/callbackfile.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/callbackfile.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/callbackfile.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/callbackfile.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/callbackfile.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#callbackfile#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#callbackfile#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#callbackfile#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#callbackfile#renewCache()
line 34: 
line 35: "
line 36: function fuf#callbackfile#requiresOnCommandPre()
line 39: 
line 40: "
line 41: function fuf#callbackfile#onInit()
line 43: 
line 44: "
line 45: function fuf#callbackfile#launch(initialPattern, partialMatching, prompt, exclude, listener)
line 51: 
line 52: " }}}1
line 53: "=============================================================================
line 54: " LOCAL FUNCTIONS/VARIABLES {{{1
line 55: 
line 56: let s:MODE_NAME = expand('<sfile>:t:r')
line 57: 
line 58: "
line 59: function s:enumItems(dir)
line 71: 
line 72: " }}}1
line 73: "=============================================================================
line 74: " s:handler {{{1
line 75: 
line 76: let s:handler = {}
line 77: 
line 78: "
line 79: function s:handler.getModeName()
line 82: 
line 83: "
line 84: function s:handler.getPrompt()
line 87: 
line 88: "
line 89: function s:handler.getPreviewHeight()
line 92: 
line 93: "
line 94: function s:handler.isOpenable(enteredPattern)
line 97: 
line 98: "
line 99: function s:handler.makePatternSet(patternBase)
line 103: 
line 104: "
line 105: function s:handler.makePreviewLines(word, count)
line 108: 
line 109: "
line 110: function s:handler.getCompleteItems(patternPrimary)
line 114: 
line 115: "
line 116: function s:handler.onOpen(word, mode)
line 119: 
line 120: "
line 121: function s:handler.onModeEnterPre()
line 123: 
line 124: "
line 125: function s:handler.onModeEnterPost()
line 127: 
line 128: "
line 129: function s:handler.onModeLeavePost(opened)
line 134: 
line 135: " }}}1
line 136: "=============================================================================
line 137: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/callbackfile.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#callbackfile#renewCache()

line 1:   let s:cache = {}
function <SNR>38_initialize..fuf#addMode..fuf#callbackfile#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#callbackfile#onInit()

function <SNR>38_initialize..fuf#addMode..fuf#callbackfile#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#callbackfile#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#callbackfile#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 117:   call fuf#addMode('callbackitem')
calling function <SNR>38_initialize..fuf#addMode('callbackitem')

line 1:   if count(g:fuf_modesDisable, a:modeName) > 0
line 2:     return
line 3:   endif
line 4:   call add(s:modeNames, a:modeName)
line 5:   call fuf#{a:modeName}#renewCache()
Searching for "autoload/fuf/callbackitem.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundl
Searching for "/home/max/.vim/autoload/fuf/callbackitem.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/fuf/callbackitem.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/fuf/callbackitem.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/fuf/callbackitem.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/fuf/callbackitem.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/fuf/callbackitem.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/fuf/callbackitem.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/callbackitem.vim"
chdir(/home/max/.vim/bundle/FuzzyFinder/autoload/fuf)
fchdir() to previous dir
line 5: sourcing "/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/callbackitem.vim"
line 1: "=============================================================================
line 2: " Copyright (c) 2007-2010 Takeshi NISHIDA
line 3: "
line 4: "=============================================================================
line 5: " LOAD GUARD {{{1
line 6: 
line 7: if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
calling function l9#guardScriptLoading('/home/max/.vim/bundle/FuzzyFinder/autoload/fuf/callbackitem.vim', 0, 0, [])

line 1:   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
line 2:   if exists(loadedVarName)
line 3:     return 0
line 4:   elseif a:vimVersion > 0 && a:vimVersion > v:version
line 5:     echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
line 6:     return 0
line 7:   elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
line 9:     echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
line 10:     return 0
line 11:   endif
line 12:   for expr in a:exprs
line 13:     if !eval(expr)
line 14:       echoerr a:path . ' requires: ' . expr
line 15:       return 0
line 16:     endif
line 17:   endfor
line 18:   let {loadedVarName} = 1
line 19:   return 1
function l9#guardScriptLoading returning #1

continuing in /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/callbackitem.vim

line 8:   finish
line 9: endif
line 10: 
line 11: " }}}1
line 12: "=============================================================================
line 13: " GLOBAL FUNCTIONS {{{1
line 14: 
line 15: "
line 16: function fuf#callbackitem#createHandler(base)
line 19: 
line 20: "
line 21: function fuf#callbackitem#getSwitchOrder()
line 24: 
line 25: "
line 26: function fuf#callbackitem#getEditableDataNames()
line 29: 
line 30: "
line 31: function fuf#callbackitem#renewCache()
line 33: 
line 34: "
line 35: function fuf#callbackitem#requiresOnCommandPre()
line 38: 
line 39: "
line 40: function fuf#callbackitem#onInit()
line 42: 
line 43: "
line 44: function fuf#callbackitem#launch(initialPattern, partialMatching, prompt, listener, items, forPath)
line 60: 
line 61: " }}}1
line 62: "=============================================================================
line 63: " LOCAL FUNCTIONS/VARIABLES {{{1
line 64: 
line 65: let s:MODE_NAME = expand('<sfile>:t:r')
line 66: 
line 67: " }}}1
line 68: "=============================================================================
line 69: " s:handler {{{1
line 70: 
line 71: let s:handler = {}
line 72: 
line 73: "
line 74: function s:handler.getModeName()
line 77: 
line 78: "
line 79: function s:handler.getPrompt()
line 82: 
line 83: "
line 84: function s:handler.getPreviewHeight()
line 90: 
line 91: "
line 92: function s:handler.isOpenable(enteredPattern)
line 95: 
line 96: "
line 97: function s:handler.makePatternSet(patternBase)
line 103: 
line 104: "
line 105: function s:handler.makePreviewLines(word, count)
line 111: 
line 112: "
line 113: function s:handler.getCompleteItems(patternPrimary)
line 116: 
line 117: "
line 118: function s:handler.onOpen(word, mode)
line 121: 
line 122: "
line 123: function s:handler.onModeEnterPre()
line 125: 
line 126: "
line 127: function s:handler.onModeEnterPost()
line 129: 
line 130: "
line 131: function s:handler.onModeLeavePost(opened)
line 136: 
line 137: " }}}1
line 138: "=============================================================================
line 139: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/autoload/fuf/callbackitem.vim
continuing in function <SNR>38_initialize..fuf#addMode
calling function <SNR>38_initialize..fuf#addMode..fuf#callbackitem#renewCache()

function <SNR>38_initialize..fuf#addMode..fuf#callbackitem#renewCache returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 6:   call fuf#{a:modeName}#onInit()
calling function <SNR>38_initialize..fuf#addMode..fuf#callbackitem#onInit()

function <SNR>38_initialize..fuf#addMode..fuf#callbackitem#onInit returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 7:   if fuf#{a:modeName}#requiresOnCommandPre()
calling function <SNR>38_initialize..fuf#addMode..fuf#callbackitem#requiresOnCommandPre()

line 1:   return 0
function <SNR>38_initialize..fuf#addMode..fuf#callbackitem#requiresOnCommandPre returning #0

continuing in function <SNR>38_initialize..fuf#addMode

line 8:     " cnoremap has a problem, which doesn't expand cabbrev.
line 9:     cmap <silent> <expr> <CR> <SID>onCommandPre()
line 10:   endif
function <SNR>38_initialize..fuf#addMode returning #0

continuing in function <SNR>38_initialize

line 118:   "---------------------------------------------------------------------------
function <SNR>38_initialize returning #0

continuing in /home/max/.vim/bundle/FuzzyFinder/plugin/fuf.vim

line 155: 
line 156: " }}}1
line 157: "=============================================================================
line 158: " vim: set fdm=marker:
finished sourcing /home/max/.vim/bundle/FuzzyFinder/plugin/fuf.vim
Searching for "/home/max/.vim/bundle/command-t/plugin/**/*.vim"
chdir(/home/max/.vim/bundle/command-t/plugin)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/command-t/plugin/command-t.vim"
line 1: " Copyright 2010-2014 Greg Hurrell. All rights reserved.
line 2: " Licensed under the terms of the BSD 2-clause license.
line 3: 
line 4: if exists("g:command_t_loaded") || &cp
line 5:   finish
line 6: endif
line 7: let g:command_t_loaded = 1
line 8: 
line 9: command CommandTBuffer call commandt#CommandTShowBufferFinder()
line 10: command CommandTJump call commandt#CommandTShowJumpFinder()
line 11: command CommandTMRU call commandt#CommandTShowMRUFinder()
line 12: command CommandTTag call commandt#CommandTShowTagFinder()
line 13: command -nargs=? -complete=dir CommandT call commandt#CommandTShowFileFinder(<q-args>)
line 14: command CommandTFlush call commandt#CommandTFlush()
line 15: 
line 16: if !hasmapto(':CommandT<CR>') && maparg('<Leader>t', 'n') == ''
line 17:   silent! nnoremap <unique> <silent> <Leader>t :CommandT<CR>
line 18: endif
line 19: 
line 20: if !hasmapto(':CommandTBuffer<CR>') && maparg('<Leader>b', 'n') == ''
line 21:   silent! nnoremap <unique> <silent> <Leader>b :CommandTBuffer<CR>
line 22: endif
line 23: 
line 24: if !has('ruby')
line 25:   finish
line 26: endif
finished sourcing /home/max/.vim/bundle/command-t/plugin/command-t.vim
Searching for "/home/max/.vim/bundle/YouCompleteMe/plugin/**/*.vim"
chdir(/home/max/.vim/bundle/YouCompleteMe/plugin)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim"
line 1: " Copyright (C) 2011, 2012  Google Inc.
line 2: "
line 3: " This file is part of YouCompleteMe.
line 4: "
line 5: " YouCompleteMe is free software: you can redistribute it and/or modify
line 6: " it under the terms of the GNU General Public License as published by
line 7: " the Free Software Foundation, either version 3 of the License, or
line 8: " (at your option) any later version.
line 9: "
line 10: " YouCompleteMe is distributed in the hope that it will be useful,
line 11: " but WITHOUT ANY WARRANTY; without even the implied warranty of
line 12: " MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
line 13: " GNU General Public License for more details.
line 14: "
line 15: " You should have received a copy of the GNU General Public License
line 16: " along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.
line 17: 
line 18: " This is basic vim plugin boilerplate
line 19: let s:save_cpo = &cpo
line 20: set cpo&vim
line 21: 
line 22: function! s:restore_cpo()
line 26: 
line 27: if exists( "g:loaded_youcompleteme" )
line 28:   call s:restore_cpo()
line 29:   finish
line 30: elseif v:version < 703 || (v:version == 703 && !has('patch584'))
line 33:   echohl WarningMsg | echomsg "YouCompleteMe unavailable: requires Vim 7.3.584+" | echohl None
line 33:  echomsg "YouCompleteMe unavailable: requires Vim 7.3.584+" | echohl None
line 33:  echohl None
line 34:   call s:restore_cpo()
line 35:   finish
line 36: elseif !has( 'python' )
line 40:   echohl WarningMsg | echomsg "YouCompleteMe unavailable: requires Vim compiled with " . "Python 2.x support" | echohl None
line 40:  echomsg "YouCompleteMe unavailable: requires Vim compiled with " . "Python 2.x support" | echohl None
line 40:  echohl None
line 41:   call s:restore_cpo()
line 42:   finish
line 43: endif
line 44: 
line 45: let s:script_folder_path = escape( expand( '<sfile>:p:h' ), '\' )
line 46: let s:python_folder_path = s:script_folder_path . '/../python/'
line 47: let s:ycmd_folder_path = s:script_folder_path . '/../third_party/ycmd/'
line 48: 
line 49: function! s:YcmLibsPresentIn( path_prefix )
line 62: 
line 63: if s:YcmLibsPresentIn( s:python_folder_path )
calling function <SNR>60_YcmLibsPresentIn('/home/max/.vim/bundle/YouCompleteMe/plugin/../python/')

line 1:   if filereadable(a:path_prefix . 'ycm_client_support.so') && filereadable(a:path_prefix . 'ycm_core.so')
line 3:     return 1
line 4:   elseif filereadable(a:path_prefix . 'ycm_client_support.pyd') && filereadable(a:path_prefix . 'ycm_core.pyd')
line 6:     return 1
line 7:   elseif filereadable(a:path_prefix . 'ycm_client_support.dll') && filereadable(a:path_prefix . 'ycm_core.dll')
line 9:     return 1
line 10:   endif
line 11:   return 0
function <SNR>60_YcmLibsPresentIn returning #0

continuing in /home/max/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim

line 67:   echohl WarningMsg | echomsg "YCM libraries found in old YouCompleteMe/python location; " . "please RECOMPILE YCM." | echohl None
line 67:  echomsg "YCM libraries found in old YouCompleteMe/python location; " . "please RECOMPILE YCM." | echohl None
line 67:  echohl None
line 68:   call s:restore_cpo()
line 69:   finish
line 70: endif
line 71: 
line 73: let g:ycm_check_if_ycm_core_present = get( g:, 'ycm_check_if_ycm_core_present', 1 )
line 74: 
line 76: if g:ycm_check_if_ycm_core_present && !s:YcmLibsPresentIn( s:ycmd_folder_path )
calling function <SNR>60_YcmLibsPresentIn('/home/max/.vim/bundle/YouCompleteMe/plugin/../third_party/ycmd/')

line 1:   if filereadable(a:path_prefix . 'ycm_client_support.so') && filereadable(a:path_prefix . 'ycm_core.so')
line 3:     return 1
function <SNR>60_YcmLibsPresentIn returning #1

continuing in /home/max/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim

line 81:   echohl WarningMsg | echomsg "ycm_client_support.[so|pyd|dll] and " . "ycm_core.[so|pyd|dll] not detected; you need to compile " . "YCM before using it. Read the docs!" | echohl None
line 81:  echomsg "ycm_client_support.[so|pyd|dll] and " . "ycm_core.[so|pyd|dll] not detected; you need to compile " . "YCM before using it. Read the docs!" | echohl None
line 81:  echohl None
line 82:   call s:restore_cpo()
line 83:   finish
line 84: endif
line 85: 
line 86: let g:loaded_youcompleteme = 1
line 87: 
line 88: " NOTE: Most defaults are in default_settings.json. They are loaded into Vim
line 89: " global with the 'ycm_' prefix if such a key does not already exist; thus, the
line 90: " user can override the defaults.
line 91: " The only defaults that are here are the ones that are only relevant to the YCM
line 92: " Vim client and not the server.
line 93: 
line 95: let g:ycm_allow_changing_updatetime = get( g:, 'ycm_allow_changing_updatetime', 1 )
line 96: 
line 98: let g:ycm_open_loclist_on_ycm_diags = get( g:, 'ycm_open_loclist_on_ycm_diags', 1 )
line 99: 
line 101: let g:ycm_add_preview_to_completeopt = get( g:, 'ycm_add_preview_to_completeopt', 0 )
line 102: 
line 104: let g:ycm_autoclose_preview_window_after_completion = get( g:, 'ycm_autoclose_preview_window_after_completion', 0 )
line 105: 
line 107: let g:ycm_autoclose_preview_window_after_insertion = get( g:, 'ycm_autoclose_preview_window_after_insertion', 0 )
line 108: 
line 110: let g:ycm_key_list_select_completion = get( g:, 'ycm_key_list_select_completion', ['<TAB>', '<Down>'] )
line 111: 
line 113: let g:ycm_key_list_previous_completion = get( g:, 'ycm_key_list_previous_completion', ['<S-TAB>', '<Up>'] )
line 114: 
line 116: let g:ycm_key_invoke_completion = get( g:, 'ycm_key_invoke_completion', '<C-Space>' )
line 117: 
line 119: let g:ycm_key_detailed_diagnostics = get( g:, 'ycm_key_detailed_diagnostics', '<leader>d' )
line 120: 
line 122: let g:ycm_cache_omnifunc = get( g:, 'ycm_cache_omnifunc', 1 )
line 123: 
line 125: let g:ycm_server_use_vim_stdout = get( g:, 'ycm_server_use_vim_stdout', 0 )
line 126: 
line 128: let g:ycm_server_log_level = get( g:, 'ycm_server_log_level', 'info' )
line 129: 
line 131: let g:ycm_server_keep_logfiles = get( g:, 'ycm_server_keep_logfiles', 0 )
line 132: 
line 134: let g:ycm_extra_conf_vim_data = get( g:, 'ycm_extra_conf_vim_data', [] )
line 135: 
line 137: let g:ycm_path_to_python_interpreter = get( g:, 'ycm_path_to_python_interpreter', '' )
line 138: 
line 141: let g:ycm_show_diagnostics_ui = get( g:, 'ycm_show_diagnostics_ui', get( g:, 'ycm_register_as_syntastic_checker', 1 ) )
line 142: 
line 145: let g:ycm_enable_diagnostic_signs = get( g:, 'ycm_enable_diagnostic_signs', get( g:, 'syntastic_enable_signs', 1 ) )
line 146: 
line 149: let g:ycm_enable_diagnostic_highlighting = get( g:, 'ycm_enable_diagnostic_highlighting', get( g:, 'syntastic_enable_highlighting', 1 ) )
line 150: 
line 153: let g:ycm_echo_current_diagnostic = get( g:, 'ycm_echo_current_diagnostic', get( g:, 'syntastic_echo_current_error', 1 ) )
line 154: 
line 157: let g:ycm_always_populate_location_list = get( g:, 'ycm_always_populate_location_list', get( g:, 'syntastic_always_populate_loc_list', 0 ) )
line 158: 
line 161: let g:ycm_error_symbol = get( g:, 'ycm_error_symbol', get( g:, 'syntastic_error_symbol', '>>' ) )
line 162: 
line 165: let g:ycm_warning_symbol = get( g:, 'ycm_warning_symbol', get( g:, 'syntastic_warning_symbol', '>>' ) )
line 166: 
line 168: let g:ycm_goto_buffer_command = get( g:, 'ycm_goto_buffer_command', 'same-buffer' )
line 169: 
line 170: " On-demand loading. Let's use the autoload folder and not slow down vim's
line 171: " startup procedure.
line 172: augroup youcompletemeStart
line 173:   autocmd!
line 174:   autocmd VimEnter * call youcompleteme#Enable()
line 175: augroup END
line 176: 
line 177: " This is basic vim plugin boilerplate
line 178: call s:restore_cpo()
calling function <SNR>60_restore_cpo()

line 1:   let &cpo = s:save_cpo
line 2:   unlet s:save_cpo
function <SNR>60_restore_cpo returning #0

continuing in /home/max/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim

finished sourcing /home/max/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim
Searching for "/home/max/.vim/bundle/syntastic/plugin/**/*.vim"
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/autoloclist.vim"
line 1: if exists("g:loaded_syntastic_notifier_autoloclist") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/autoloclist.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/balloons.vim"
line 1: if exists("g:loaded_syntastic_notifier_balloons") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/balloons.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/checker.vim"
line 1: if exists("g:loaded_syntastic_checker") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/checker.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/cursor.vim"
line 1: if exists("g:loaded_syntastic_notifier_cursor") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/cursor.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/highlighting.vim"
line 1: if exists("g:loaded_syntastic_notifier_highlighting") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/highlighting.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/loclist.vim"
line 1: if exists("g:loaded_syntastic_loclist") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/loclist.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/modemap.vim"
line 1: if exists("g:loaded_syntastic_modemap") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/modemap.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/notifiers.vim"
line 1: if exists("g:loaded_syntastic_notifiers") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/notifiers.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/registry.vim"
line 1: if exists("g:loaded_syntastic_registry") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/registry.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/signs.vim"
line 1: if exists("g:loaded_syntastic_notifier_signs") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/signs.vim
chdir(/home/max/.vim/bundle/syntastic/plugin)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic.vim"
line 1: "============================================================================
line 2: "File:        syntastic.vim
line 3: "Description: Vim plugin for on the fly syntax checking.
line 4: "License:     This program is free software. It comes without any warranty,
line 5: "             to the extent permitted by applicable law. You can redistribute
line 6: "             it and/or modify it under the terms of the Do What The Fuck You
line 7: "             Want To Public License, Version 2, as published by Sam Hocevar.
line 8: "             See http://sam.zoy.org/wtfpl/COPYING for more details.
line 9: "
line 10: "============================================================================
line 11: 
line 12: if exists("g:loaded_syntastic_plugin")
line 13:     finish
line 14: endif
line 15: let g:loaded_syntastic_plugin = 1
line 16: 
line 17: if has('reltime')
line 18:     let g:syntastic_start = reltime()
line 19:     lockvar! g:syntastic_start
line 20: endif
line 21: 
line 22: let g:syntastic_version = '3.5.0-25'
line 23: lockvar g:syntastic_version
line 24: 
line 25: " Sanity checks {{{1
line 26: 
line 27: for s:feature in ['autocmd', 'eval', 'modify_fname', 'quickfix', 'reltime', 'user_commands']
line 28:     if !has(s:feature)
line 29:         call syntastic#log#error("need Vim compiled with feature " . s:feature)
Searching for "autoload/syntastic/log.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/F
Searching for "/home/max/.vim/autoload/syntastic/log.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/syntastic/log.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/syntastic/log.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/syntastic/log.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/syntastic/log.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/syntastic/log.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/syntastic/log.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/syntastic/log.vim"
Searching for "/home/max/.vim/bundle/command-t/autoload/syntastic/log.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/autoload/syntastic/log.vim"
Searching for "/home/max/.vim/bundle/syntastic/autoload/syntastic/log.vim"
chdir(/home/max/.vim/bundle/syntastic/autoload/syntastic)
fchdir() to previous dir
line 29: sourcing "/home/max/.vim/bundle/syntastic/autoload/syntastic/log.vim"
line 1: if exists("g:loaded_syntastic_log_autoload") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_log_autoload = 1
line 5: 
line 6: let s:save_cpo = &cpo
line 7: set cpo&vim
line 8: 
line 9: let s:one_time_notices_issued = []
line 10: 
line 11: " Public functions {{{1
line 12: 
line 13: function! syntastic#log#info(msg) " {{{2
line 16: 
line 17: function! syntastic#log#warn(msg) " {{{2
line 22: 
line 23: function! syntastic#log#error(msg) " {{{2
line 29: 
line 30: function! syntastic#log#oneTimeWarn(msg) " {{{2
line 38: 
line 39: " @vimlint(EVL102, 1, l:OLD_VAR)
line 40: function! syntastic#log#deprecationWarn(old, new, ...) " {{{2
line 61: " @vimlint(EVL102, 0, l:OLD_VAR)
line 62: 
line 63: function! syntastic#log#debug(level, msg, ...) " {{{2
line 82: 
line 83: function! syntastic#log#debugShowOptions(level, names) " {{{2
line 98: 
line 99: function! syntastic#log#debugShowVariables(level, names) " {{{2
line 117: 
line 118: function! syntastic#log#debugDump(level) " {{{2
line 125: 
line 126: " }}}1
line 127: 
line 128: " Private functions {{{1
line 129: 
line 130: function! s:_isDebugEnabled_smart(level) " {{{2
line 133: 
line 134: function! s:_isDebugEnabled_dumb(level) " {{{2
line 138: 
line 139: let s:isDebugEnabled = function(exists('*and') ? 's:_isDebugEnabled_smart' : 's:_isDebugEnabled_dumb')
line 140: lockvar s:isDebugEnabled
line 141: 
line 142: function! s:_logRedirect(on) " {{{2
line 156: 
line 157: function! s:_logTimestamp() " {{{2
line 160: 
line 161: function! s:_formatVariable(name) " {{{2
line 172: 
line 173: " }}}1
line 174: 
line 175: let &cpo = s:save_cpo
line 176: unlet s:save_cpo
line 177: 
line 178: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/max/.vim/bundle/syntastic/autoload/syntastic/log.vim
continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim
line 30:         finish
line 31:     endif
line 32: endfor
line 27: for s:feature in ['autocmd', 'eval', 'modify_fname', 'quickfix', 'reltime', 'user_commands']
line 28:     if !has(s:feature)
line 29:         call syntastic#log#error("need Vim compiled with feature " . s:feature)
line 30:         finish
line 31:     endif
line 32: endfor
line 27: for s:feature in ['autocmd', 'eval', 'modify_fname', 'quickfix', 'reltime', 'user_commands']
line 28:     if !has(s:feature)
line 29:         call syntastic#log#error("need Vim compiled with feature " . s:feature)
line 30:         finish
line 31:     endif
line 32: endfor
line 27: for s:feature in ['autocmd', 'eval', 'modify_fname', 'quickfix', 'reltime', 'user_commands']
line 28:     if !has(s:feature)
line 29:         call syntastic#log#error("need Vim compiled with feature " . s:feature)
line 30:         finish
line 31:     endif
line 32: endfor
line 27: for s:feature in ['autocmd', 'eval', 'modify_fname', 'quickfix', 'reltime', 'user_commands']
line 28:     if !has(s:feature)
line 29:         call syntastic#log#error("need Vim compiled with feature " . s:feature)
line 30:         finish
line 31:     endif
line 32: endfor
line 27: for s:feature in ['autocmd', 'eval', 'modify_fname', 'quickfix', 'reltime', 'user_commands']
line 28:     if !has(s:feature)
line 29:         call syntastic#log#error("need Vim compiled with feature " . s:feature)
line 30:         finish
line 31:     endif
line 32: endfor
line 27: for s:feature in ['autocmd', 'eval', 'modify_fname', 'quickfix', 'reltime', 'user_commands']
line 28:     if !has(s:feature)
line 29:         call syntastic#log#error("need Vim compiled with feature " . s:feature)
line 30:         finish
line 31:     endif
line 32: endfor
line 33: 
line 34: let s:running_windows = syntastic#util#isRunningWindows()
Searching for "autoload/syntastic/util.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/
Searching for "/home/max/.vim/autoload/syntastic/util.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/syntastic/util.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/syntastic/util.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/syntastic/util.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/syntastic/util.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/syntastic/util.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/syntastic/util.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/syntastic/util.vim"
Searching for "/home/max/.vim/bundle/command-t/autoload/syntastic/util.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/autoload/syntastic/util.vim"
Searching for "/home/max/.vim/bundle/syntastic/autoload/syntastic/util.vim"
chdir(/home/max/.vim/bundle/syntastic/autoload/syntastic)
fchdir() to previous dir
line 34: sourcing "/home/max/.vim/bundle/syntastic/autoload/syntastic/util.vim"
line 1: if exists('g:loaded_syntastic_util_autoload') || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_util_autoload = 1
line 5: 
line 6: let s:save_cpo = &cpo
line 7: set cpo&vim
line 8: 
line 9: " Public functions {{{1
line 10: 
line 11: function! syntastic#util#isRunningWindows() " {{{2
line 14: 
line 15: function! syntastic#util#DevNull() " {{{2
line 21: 
line 22: " Get directory separator
line 23: function! syntastic#util#Slash() abort " {{{2
line 26: 
line 27: "search the first 5 lines of the file for a magic number and return a map
line 28: "containing the args and the executable
line 29: "
line 30: "e.g.
line 31: "
line 32: "#!/usr/bin/perl -f -bar
line 33: "
line 34: "returns
line 35: "
line 36: "{'exe': '/usr/bin/perl', 'args': ['-f', '-bar']}
line 37: function! syntastic#util#parseShebang() " {{{2
line 50: 
line 51: " Get the value of a variable.  Allow local variables to override global ones.
line 52: function! syntastic#util#var(name, ...) " {{{2
line 58: 
line 59: " Parse a version string.  Return an array of version components.
line 60: function! syntastic#util#parseVersion(version) " {{{2
line 63: 
line 64: " Run 'command' in a shell and parse output as a version string.
line 65: " Returns an array of version components.
line 66: function! syntastic#util#getVersion(command) " {{{2
line 69: 
line 70: " Verify that the 'installed' version is at least the 'required' version.
line 71: "
line 72: " 'installed' and 'required' must be arrays. If they have different lengths,
line 73: " the "missing" elements will be assumed to be 0 for the purposes of checking.
line 74: "
line 75: " See http://semver.org for info about version numbers.
line 76: function! syntastic#util#versionIsAtLeast(installed, required) " {{{2
line 79: 
line 80: " Almost lexicographic comparison of two lists of integers. :) If lists
line 81: " have different lengths, the "missing" elements are assumed to be 0.
line 82: function! syntastic#util#compareLexi(a, b) " {{{2
line 93: 
line 94: " strwidth() was added in Vim 7.3; if it doesn't exist, we use strlen()
line 95: " and hope for the best :)
line 96: let s:width = function(exists('*strwidth') ? 'strwidth' : 'strlen')
line 97: lockvar s:width
line 98: 
line 99: function! syntastic#util#screenWidth(str, tabstop) " {{{2
line 108: 
line 109: "print as much of a:msg as possible without "Press Enter" prompt appearing
line 110: function! syntastic#util#wideMsg(msg) " {{{2
line 132: 
line 133: " Check whether a buffer is loaded, listed, and not hidden
line 134: function! syntastic#util#bufIsActive(buffer) " {{{2
line 151: 
line 152: " start in directory a:where and walk up the parent folders until it
line 153: " finds a file matching a:what; return path to that file
line 154: function! syntastic#util#findInParent(what, where) " {{{2
line 184: 
line 185: " Returns unique elements in a list
line 186: function! syntastic#util#unique(list) " {{{2
line 197: 
line 198: " A less noisy shellescape()
line 199: function! syntastic#util#shescape(string) " {{{2
line 202: 
line 203: " A less noisy shellescape(expand())
line 204: function! syntastic#util#shexpand(string) " {{{2
line 207: 
line 208: " decode XML entities
line 209: function! syntastic#util#decodeXMLEntities(string) " {{{2
line 218: 
line 219: function! syntastic#util#redraw(full) " {{{2
line 226: 
line 227: function! syntastic#util#dictFilter(errors, filter) " {{{2
line 237: 
line 238: " Return a [high, low] list of integers, representing the time
line 239: " (hopefully high resolution) since program start
line 240: " TODO: This assumes reltime() returns a list of integers.
line 241: function! syntastic#util#stamp() " {{{2
line 244: 
line 245: " }}}1
line 246: 
line 247: " Private functions {{{1
line 248: 
line 249: function! s:_translateFilter(filters) " {{{2
line 264: 
line 265: function! s:_translateElement(key, term) " {{{2
line 280: 
line 281: " }}}1
line 282: 
line 283: let &cpo = s:save_cpo
line 284: unlet s:save_cpo
line 285: 
line 286: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/max/.vim/bundle/syntastic/autoload/syntastic/util.vim
continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim
calling function syntastic#util#isRunningWindows()

line 1:     return has('win16') || has('win32') || has('win64')
function syntastic#util#isRunningWindows returning #0

continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim

line 35: lockvar s:running_windows
line 36: 
line 37: if !s:running_windows && executable('uname')
line 38:     try
line 39:         let s:uname = system('uname')
Calling shell to execute: "(uname) > /tmp/v7HsCz8/0"
line 40:     catch /\m^Vim\%((\a\+)\)\=:E484/
line 41:         call syntastic#log#error("your shell " . &shell . " doesn't use traditional UNIX syntax for redirections")
line 42:         finish
line 43:     endtry
line 44:     lockvar s:uname
line 45: endif
line 46: 
line 47: " }}}1
line 48: 
line 49: " Defaults {{{1
line 50: 
line 80: let g:syntastic_defaults = { 'aggregate_errors':         0, 'always_populate_loc_list': 0, 'auto_jump':                0, 'auto_loc_list':            2, 'bash_hack':                1, 'check_on_open':            0, 'check_on_wq':              1, 'cursor_columns':           1, 'debug':                    0, 'echo_current_error':       1, 'enable_balloons':          1, 'enable_highlighting':      1, 'enable_signs':             1, 'error_symbol':             '>>', 'exit_checks':              !(s:running_windows && &shell =~? '\m\<cmd\.exe$'), 'filetype_map':             {}, 'full_redraws':             !(has('gui_running') || has('gui_macvim')), 'id_checkers':              1, 'ignore_extensions':        '\c\v^([gx]?z|lzma|bz2)$', 'ignore_files':             [], 'loc_list_height':          10, 'quiet_messages':           {}, 'reuse_loc_lists':          0, 'sort_aggregated_errors':   1, 'stl_format':               '[Syntax: line:%F (%t)]', 'style_error_symbol':       'S>', 'style_warning_symbol':     'S>',
line 81: lockvar! g:syntastic_defaults
line 82: 
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 83: for s:key in keys(g:syntastic_defaults)
line 84:     if !exists('g:syntastic_' . s:key)
line 85:         let g:syntastic_{s:key} = g:syntastic_defaults[s:key]
line 86:     endif
line 87: endfor
line 88: 
line 89: if exists("g:syntastic_quiet_warnings")
line 90:     call syntastic#log#oneTimeWarn("variable g:syntastic_quiet_warnings is deprecated, please use let g:syntastic_quiet_messages = {'level': 'warnings'} instead")
line 91:     if g:syntastic_quiet_warnings
line 92:         let s:quiet_warnings = get(g:syntastic_quiet_messages, 'type', [])
line 93:         if type(s:quiet_warnings) != type([])
line 94:             let s:quiet_warnings = [s:quiet_warnings]
line 95:         endif
line 96:         call add(s:quiet_warnings, 'warnings')
line 97:         let g:syntastic_quiet_messages['type'] = s:quiet_warnings
line 98:     endif
line 99: endif
line 100: 
line 101: " }}}1
line 102: 
line 103: " Debug {{{1
line 104: 
line 114: let s:debug_dump_options = [ 'shell', 'shellcmdflag', 'shellpipe', 'shellquote', 'shellredir', 'shellslash', 'shelltemp', 'shellxquote' ]
line 115: if v:version > 703 || (v:version == 703 && has('patch446'))
line 116:     call add(s:debug_dump_options, 'shellxescape')
line 117: endif
line 118: lockvar! s:debug_dump_options
line 119: 
line 120: " debug constants
line 121: let     g:SyntasticDebugTrace         = 1
line 122: lockvar g:SyntasticDebugTrace
line 123: let     g:SyntasticDebugLoclist       = 2
line 124: lockvar g:SyntasticDebugLoclist
line 125: let     g:SyntasticDebugNotifications = 4
line 126: lockvar g:SyntasticDebugNotifications
line 127: let     g:SyntasticDebugAutocommands  = 8
line 128: lockvar g:SyntasticDebugAutocommands
line 129: let     g:SyntasticDebugVariables     = 16
line 130: lockvar g:SyntasticDebugVariables
line 131: 
line 132: " }}}1
line 133: 
line 134: runtime! plugin/syntastic/*.vim
Searching for "plugin/syntastic/*.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/Fuzzy
Searching for "/home/max/.vim/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/vundle/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/vim-rails/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/L9/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/command-t/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/syntastic/plugin/syntastic/*.vim"
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/autoloclist.vim"
line 1: if exists("g:loaded_syntastic_notifier_autoloclist") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_autoloclist = 1
line 5: 
line 6: let g:SyntasticAutoloclistNotifier = {}
line 7: 
line 8: " Public methods {{{1
line 9: "
line 10: function! g:SyntasticAutoloclistNotifier.New() " {{{2
line 14: 
line 15: function! g:SyntasticAutoloclistNotifier.refresh(loclist) " {{{2
line 19: 
line 20: function! g:SyntasticAutoloclistNotifier.AutoToggle(loclist) " {{{2
line 35: 
line 36: " }}}1
line 37: 
line 38: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/autoloclist.vim
continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/balloons.vim"
line 1: if exists("g:loaded_syntastic_notifier_balloons") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_balloons = 1
line 5: 
line 6: if !has('balloon_eval')
line 7:     let g:syntastic_enable_balloons = 0
line 8: endif
line 9: 
line 10: let g:SyntasticBalloonsNotifier = {}
line 11: 
line 12: " Public methods {{{1
line 13: 
line 14: function! g:SyntasticBalloonsNotifier.New() " {{{2
line 18: 
line 19: function! g:SyntasticBalloonsNotifier.enabled() " {{{2
line 22: 
line 23: " Update the error balloons
line 24: function! g:SyntasticBalloonsNotifier.refresh(loclist) " {{{2
line 42: 
line 43: " Reset the error balloons
line 44: " @vimlint(EVL103, 1, a:loclist)
line 45: function! g:SyntasticBalloonsNotifier.reset(loclist) " {{{2
line 52: " @vimlint(EVL103, 0, a:loclist)
line 53: 
line 54: " }}}1
line 55: 
line 56: " Private functions {{{1
line 57: 
line 58: function! SyntasticBalloonsExprNotifier() " {{{2
line 64: 
line 65: " }}}1
line 66: 
line 67: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/balloons.vim
continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/checker.vim"
line 1: if exists("g:loaded_syntastic_checker") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_checker = 1
line 5: 
line 6: let g:SyntasticChecker = {}
line 7: 
line 8: " Public methods {{{1
line 9: 
line 10: function! g:SyntasticChecker.New(args) " {{{2
line 39: 
line 40: function! g:SyntasticChecker.getFiletype() " {{{2
line 43: 
line 44: function! g:SyntasticChecker.getName() " {{{2
line 47: 
line 48: function! g:SyntasticChecker.getExec() " {{{2
line 55: 
line 56: function! g:SyntasticChecker.getExecEscaped() " {{{2
line 59: 
line 60: function! g:SyntasticChecker.getLocListRaw() " {{{2
line 74: 
line 75: function! g:SyntasticChecker.getLocList() " {{{2
line 78: 
line 79: function! g:SyntasticChecker.getWantSort() " {{{2
line 82: 
line 83: function! g:SyntasticChecker.setWantSort(val) " {{{2
line 86: 
line 87: function! g:SyntasticChecker.makeprgBuild(opts) " {{{2
line 99: 
line 100: function! g:SyntasticChecker.isAvailable() " {{{2
line 106: 
line 107: " }}}1
line 108: 
line 109: " Private methods {{{1
line 110: 
line 111: function! g:SyntasticChecker._quietMessages(errors) " {{{2
line 135: 
line 136: function! g:SyntasticChecker._populateHighlightRegexes(errors) " {{{2
line 148: 
line 149: function! g:SyntasticChecker._getOpt(opts, basename, name, default) " {{{2
line 157: 
line 158: function! g:SyntasticChecker._shescape(opt) " {{{2
line 167: 
line 168: " }}}1
line 169: 
line 170: " Non-method functions {{{1
line 171: 
line 172: function! SyntasticCheckerIsAvailableDefault() dict " {{{2
line 175: 
line 176: " }}}1
line 177: 
line 178: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/checker.vim
continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/cursor.vim"
line 1: if exists("g:loaded_syntastic_notifier_cursor") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_cursor = 1
line 5: 
line 6: let g:SyntasticCursorNotifier = {}
line 7: 
line 8: " Public methods {{{1
line 9: 
line 10: function! g:SyntasticCursorNotifier.New() " {{{2
line 14: 
line 15: function! g:SyntasticCursorNotifier.enabled() " {{{2
line 18: 
line 19: function! g:SyntasticCursorNotifier.refresh(loclist) " {{{2
line 29: 
line 30: " @vimlint(EVL103, 1, a:loclist)
line 31: function! g:SyntasticCursorNotifier.reset(loclist) " {{{2
line 37: " @vimlint(EVL103, 0, a:loclist)
line 38: 
line 39: " }}}1
line 40: 
line 41: " Private methods {{{1
line 42: 
line 43: function! SyntasticRefreshCursor() " {{{2
line 91: 
line 92: " }}}1
line 93: 
line 94: " Private functions {{{1
line 95: 
line 96: function! s:_isSameIndex(line, old_line, column, idx, messages) " {{{2
line 115: 
line 116: function! s:_findIndex(column, messages) " {{{2
line 135: 
line 136: " }}}1
line 137: 
line 138: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/cursor.vim
continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/highlighting.vim"
line 1: if exists("g:loaded_syntastic_notifier_highlighting") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_highlighting = 1
line 5: 
line 6: " Highlighting requires getmatches introduced in 7.1.040
line 7: let s:has_highlighting = v:version > 701 || (v:version == 701 && has('patch040'))
line 8: lockvar s:has_highlighting
line 9: 
line 10: let g:SyntasticHighlightingNotifier = {}
line 11: 
line 12: let s:setup_done = 0
line 13: 
line 14: " Public methods {{{1
line 15: 
line 16: function! g:SyntasticHighlightingNotifier.New() " {{{2
line 27: 
line 28: function! g:SyntasticHighlightingNotifier.enabled() " {{{2
line 31: 
line 32: " Sets error highlights in the cuirrent window
line 33: function! g:SyntasticHighlightingNotifier.refresh(loclist) " {{{2
line 61: 
line 62: " Remove all error highlights from the window
line 63: " @vimlint(EVL103, 1, a:loclist)
line 64: function! g:SyntasticHighlightingNotifier.reset(loclist) " {{{2
line 70: " @vimlint(EVL103, 0, a:loclist)
line 71: 
line 72: " }}}1
line 73: 
line 74: " Private methods {{{1
line 75: 
line 76: " One time setup: define our own highlighting
line 77: function! g:SyntasticHighlightingNotifier._setup() " {{{2
line 93: 
line 94: function! g:SyntasticHighlightingNotifier._reset() " {{{2
line 101: 
line 102: " }}}1
line 103: 
line 104: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/highlighting.vim
continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/loclist.vim"
line 1: if exists("g:loaded_syntastic_loclist") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_loclist = 1
line 5: 
line 6: let g:SyntasticLoclist = {}
line 7: 
line 8: " Public methods {{{1
line 9: 
line 10: function! g:SyntasticLoclist.New(rawLoclist) " {{{2
line 29: 
line 30: function! g:SyntasticLoclist.current() " {{{2
line 36: 
line 37: function! g:SyntasticLoclist.extend(other) " {{{2
line 42: 
line 43: function! g:SyntasticLoclist.sort() " {{{2
line 54: 
line 55: function! g:SyntasticLoclist.isEmpty() " {{{2
line 58: 
line 59: function! g:SyntasticLoclist.isNewerThan(stamp) " {{{2
line 66: 
line 67: function! g:SyntasticLoclist.copyRaw() " {{{2
line 70: 
line 71: function! g:SyntasticLoclist.getRaw() " {{{2
line 74: 
line 75: function! g:SyntasticLoclist.getBuffers() " {{{2
line 78: 
line 79: function! g:SyntasticLoclist.getCursorColumns() " {{{2
line 82: 
line 83: function! g:SyntasticLoclist.getStatuslineFlag() " {{{2
line 135: 
line 136: function! g:SyntasticLoclist.getFirstIssue() " {{{2
line 139: 
line 140: function! g:SyntasticLoclist.getName() " {{{2
line 143: 
line 144: function! g:SyntasticLoclist.setName(name) " {{{2
line 147: 
line 148: function! g:SyntasticLoclist.getOwner() " {{{2
line 151: 
line 152: function! g:SyntasticLoclist.setOwner(buffer) " {{{2
line 155: 
line 156: function! g:SyntasticLoclist.deploy() " {{{2
line 163: 
line 164: function! g:SyntasticLoclist.destroy() " {{{2
line 169: 
line 170: function! g:SyntasticLoclist.decorate(tag) " {{{2
line 175: 
line 176: function! g:SyntasticLoclist.errors() " {{{2
line 182: 
line 183: function! g:SyntasticLoclist.warnings() " {{{2
line 189: 
line 190: " Legacy function.  Syntastic no longer calls it, but we keep it
line 191: " around because other plugins (f.i. powerline) depend on it.
line 192: function! g:SyntasticLoclist.hasErrorsOrWarningsToDisplay() " {{{2
line 195: 
line 196: " cache used by EchoCurrentError()
line 197: function! g:SyntasticLoclist.messages(buf) " {{{2
line 241: 
line 242: "Filter the list and return new native loclist
line 243: "e.g.
line 244: "  .filter({'bufnr': 10, 'type': 'e'})
line 245: "
line 246: "would return all errors for buffer 10.
line 247: "
line 248: "Note that all comparisons are done with ==?
line 249: function! g:SyntasticLoclist.filter(filters) " {{{2
line 255: 
line 256: function! g:SyntasticLoclist.setloclist() " {{{2
line 265: 
line 266: "display the cached errors for this buf in the location list
line 267: function! g:SyntasticLoclist.show() " {{{2
line 297: 
line 298: " }}}1
line 299: 
line 300: " Non-method functions {{{1
line 301: 
line 302: function! SyntasticLoclistHide() " {{{2
line 306: 
line 307: " }}}1
line 308: 
line 309: " Private functions {{{1
line 310: 
line 311: function! s:_translate(key, val) " {{{2
line 314: 
line 315: function! s:_setScreenColumn(item) " {{{2
line 331: 
line 332: function! s:_removeShadowedItems(errors) " {{{2
line 363: 
line 364: function! s:_compareErrorItemsByColumns(a, b) " {{{2
line 381: 
line 382: function! s:_compareErrorItemsByLines(a, b) " {{{2
line 397: 
line 398: " }}}1
line 399: 
line 400: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/loclist.vim
continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/modemap.vim"
line 1: if exists("g:loaded_syntastic_modemap") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_modemap = 1
line 5: 
line 6: let g:SyntasticModeMap = {}
line 7: 
line 8: " Public methods {{{1
line 9: 
line 10: function! g:SyntasticModeMap.Instance() " {{{2
line 18: 
line 19: function! g:SyntasticModeMap.synch() " {{{2
line 30: 
line 31: function! g:SyntasticModeMap.allowsAutoChecking(filetype) " {{{2
line 40: 
line 41: function! g:SyntasticModeMap.isPassive() " {{{2
line 44: 
line 45: function! g:SyntasticModeMap.toggleMode() " {{{2
line 60: 
line 61: function! g:SyntasticModeMap.echoMode() " {{{2
line 64: 
line 65: function! g:SyntasticModeMap.modeInfo(...) " {{{2
line 85: 
line 86: " }}}1
line 87: 
line 88: " Private methods {{{1
line 89: 
line 90: function! g:SyntasticModeMap._isOneFiletypeActive(filetypes) " {{{2
line 93: 
line 94: function! g:SyntasticModeMap._noFiletypesArePassive(filetypes) " {{{2
line 97: 
line 98: " }}}1
line 99: 
line 100: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/modemap.vim
continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/notifiers.vim"
line 1: if exists("g:loaded_syntastic_notifiers") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifiers = 1
line 5: 
line 6: let g:SyntasticNotifiers = {}
line 7: 
line 8: let s:notifier_types = ['signs', 'balloons', 'highlighting', 'cursor', 'autoloclist']
line 9: lockvar! s:notifier_types
line 10: 
line 11: let s:persistent_notifiers = ['signs', 'balloons']
line 12: lockvar! s:persistent_notifiers
line 13: 
line 14: " Public methods {{{1
line 15: 
line 16: function! g:SyntasticNotifiers.Instance() " {{{2
line 24: 
line 25: function! g:SyntasticNotifiers.refresh(loclist) " {{{2
line 50: 
line 51: function! g:SyntasticNotifiers.reset(loclist) " {{{2
line 69: 
line 70: " }}}1
line 71: 
line 72: " Private methods {{{1
line 73: 
line 74: function! g:SyntasticNotifiers._initNotifiers() " {{{2
line 83: 
line 84: " }}}1
line 85: 
line 86: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/notifiers.vim
continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/registry.vim"
line 1: if exists("g:loaded_syntastic_registry") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_registry = 1
line 5: 
line 6: " Initialisation {{{1
line 7: 
line 93: let s:defaultCheckers = { 'actionscript':['mxmlc'], 'ada':         ['gcc'], 'applescript': ['osacompile'], 'arduino':     ['avrgcc'], 'asciidoc':    ['asciidoc'], 'asm':         ['gcc'], 'bro':         ['bro'], 'bemhtml':     ['bemhtmllint'], 'c':           ['gcc'], 'cabal':       ['cabal'], 'chef':        ['foodcritic'], 'co':          ['coco'], 'cobol':       ['cobc'], 'coffee':      ['coffee', 'coffeelint'], 'coq':         ['coqtop'], 'cpp':         ['gcc'], 'cs':          ['mcs'], 'css':         ['csslint'], 'cucumber':    ['cucumber'], 'cuda':        ['nvcc'], 'd':           ['dmd'], 'dart':        ['dartanalyzer'], 'docbk':       ['xmllint'], 'dustjs':      ['swiffer'], 'elixir':      [], 'erlang':      ['escript'], 'eruby':       ['ruby'], 'fortran':     ['gfortran'], 'glsl':        ['cgc'], 'go':          ['go'], 'haml':        ['haml'], 'handlebars':  ['handlebars'], 'haskell':     ['ghc_mod', 'hdevtools', 'hlint'], 'haxe':        ['haxe'], 'hss':         ['hss'], 'html':        ['tidy'], 'j
line 94: lockvar! s:defaultCheckers
line 95: 
line 101: let s:defaultFiletypeMap = { 'gentoo-metadata': 'xml', 'lhaskell': 'haskell', 'litcoffee': 'coffee', 'mail': 'text' }
line 102: lockvar! s:defaultFiletypeMap
line 103: 
line 104: let g:SyntasticRegistry = {}
line 105: 
line 106: " }}}1
line 107: 
line 108: " Public methods {{{1
line 109: 
line 110: " Note: Handling of filetype aliases: all public methods take aliases as
line 111: " parameters, all private methods take normalized filetypes.  Public methods
line 112: " are thus supposed to normalize filetypes before calling private methods.
line 113: 
line 114: function! g:SyntasticRegistry.Instance() " {{{2
line 122: 
line 123: function! g:SyntasticRegistry.CreateAndRegisterChecker(args) " {{{2
line 128: 
line 129: " Given a list of checker names hints_list, return a map name --> checker.
line 130: " If hints_list is empty, user settings are are used instead. Checkers are
line 131: " not checked for availability (that is, the corresponding IsAvailable() are
line 132: " not run).
line 133: function! g:SyntasticRegistry.getCheckers(ftalias, hints_list) " {{{2
line 153: 
line 154: " Same as getCheckers(), but keep only the checkers available.  This runs the
line 155: " corresponding IsAvailable() functions for all checkers.
line 156: function! g:SyntasticRegistry.getCheckersAvailable(ftalias, hints_list) " {{{2
line 159: 
line 160: function! g:SyntasticRegistry.getKnownFiletypes() " {{{2
line 175: 
line 176: function! g:SyntasticRegistry.getNamesOfAvailableCheckers(ftalias) " {{{2
line 181: 
line 182: function! g:SyntasticRegistry.echoInfoFor(ftalias_list) " {{{2
line 208: 
line 209: " }}}1
line 210: 
line 211: " Private methods {{{1
line 212: 
line 213: function! g:SyntasticRegistry._registerChecker(checker) abort " {{{2
line 226: 
line 227: function! g:SyntasticRegistry._filterCheckersByName(checkers_map, list) " {{{2
line 230: 
line 231: function! g:SyntasticRegistry._loadCheckersFor(filetype) " {{{2
line 242: 
line 243: " Check for obsolete variable g:syntastic_<filetype>_checker
line 244: function! g:SyntasticRegistry._checkDeprecation(filetype) " {{{2
line 250: 
line 251: " }}}1
line 252: 
line 253: " Private functions {{{1
line 254: 
line 255: "resolve filetype aliases, and replace - with _ otherwise we cant name
line 256: "syntax checker functions legally for filetypes like "gentoo-metadata"
line 257: function! s:_normaliseFiletype(ftalias) " {{{2
line 263: 
line 264: " }}}1
line 265: 
line 266: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/registry.vim
continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/home/max/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 134: sourcing "/home/max/.vim/bundle/syntastic/plugin/syntastic/signs.vim"
line 1: if exists("g:loaded_syntastic_notifier_signs") || !exists("g:loaded_syntastic_plugin")
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_signs = 1
line 5: 
line 6: " Initialisation {{{1
line 7: 
line 8: " start counting sign ids at 5000, start here to hopefully avoid conflicting
line 9: " with any other code that places signs (not sure if this precaution is
line 10: " actually needed)
line 11: let s:first_sign_id = 5000
line 12: let s:next_sign_id = s:first_sign_id
line 13: 
line 14: let g:SyntasticSignsNotifier = {}
line 15: 
line 16: let s:setup_done = 0
line 17: 
line 18: " }}}1
line 19: 
line 20: " Public methods {{{1
line 21: 
line 22: function! g:SyntasticSignsNotifier.New() " {{{2
line 33: 
line 34: function! g:SyntasticSignsNotifier.enabled() " {{{2
line 37: 
line 38: function! g:SyntasticSignsNotifier.refresh(loclist) " {{{2
line 46: 
line 47: " }}}1
line 48: 
line 49: " Private methods {{{1
line 50: 
line 51: " One time setup: define our own sign types and highlighting
line 52: function! g:SyntasticSignsNotifier._setup() " {{{2
line 84: 
line 85: " Place signs by all syntax errors in the buffer
line 86: function! g:SyntasticSignsNotifier._signErrors(loclist) " {{{2
line 117: 
line 118: " Remove the signs with the given ids from this buffer
line 119: function! g:SyntasticSignsNotifier._removeSigns(ids) " {{{2
line 127: 
line 128: " Get all the ids of the SyntaxError signs in the buffer
line 129: function! g:SyntasticSignsNotifier._bufSignIds() " {{{2
line 135: 
line 136: " }}}1
line 137: 
line 138: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic/signs.vim
continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim
Searching for "/home/max/.vim/bundle/ctrlp.vim/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/vim-golang/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/google.vim/plugin/syntastic/*.vim"
Searching for "/var/lib/vim/addons/plugin/syntastic/*.vim"
Searching for "/usr/share/vim/vimfiles/plugin/syntastic/*.vim"
Searching for "/usr/share/vim/vim74/plugin/syntastic/*.vim"
Searching for "/usr/share/vim/vimfiles/after/plugin/syntastic/*.vim"
Searching for "/var/lib/vim/addons/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/vundle/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/L9/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/command-t/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/plugin/syntastic/*.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/plugin/syntastic/*.vim"
line 135: 
line 136: let s:registry = g:SyntasticRegistry.Instance()
calling function 299()

line 1:     if !exists('s:SyntasticRegistryInstance')
line 2:         let s:SyntasticRegistryInstance = copy(self)
line 3:         let s:SyntasticRegistryInstance._checkerMap = {}
line 4:     endif
line 5: 
line 6:     return s:SyntasticRegistryInstance
function 299 returning {'getCheckers': function('301'), 'get...ateAndRegisterChecker': function('300')}

continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim

line 137: let s:notifiers = g:SyntasticNotifiers.Instance()
calling function 295()

line 1:     if !exists('s:SyntasticNotifiersInstance')
line 2:         let s:SyntasticNotifiersInstance = copy(self)
line 3:         call s:SyntasticNotifiersInstance._initNotifiers()
calling function 295..298()

line 1:     let self._notifier = {}
line 2:     for type in s:notifier_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 295..298..310()

line 1:     let newObj = copy(self)
line 2: 
line 3:     if !s:setup_done
line 4:         call self._setup()
calling function 295..298..310..313()

line 1:     if has('signs')
line 2:         if !hlexists('SyntasticErrorSign')
line 3:             highlight link SyntasticErrorSign error
line 4:         endif
line 5:         if !hlexists('SyntasticWarningSign')
line 6:             highlight link SyntasticWarningSign todo
line 7:         endif
line 8:         if !hlexists('SyntasticStyleErrorSign')
line 9:             highlight link SyntasticStyleErrorSign SyntasticErrorSign
line 10:         endif
line 11:         if !hlexists('SyntasticStyleWarningSign')
line 12:             highlight link SyntasticStyleWarningSign SyntasticWarningSign
line 13:         endif
line 14:         if !hlexists('SyntasticStyleErrorLine')
line 15:             highlight link SyntasticStyleErrorLine SyntasticErrorLine
line 16:         endif
line 17:         if !hlexists('SyntasticStyleWarningLine')
line 18:             highlight link SyntasticStyleWarningLine SyntasticWarningLine
line 19:         endif
line 20: 
line 21:         " define the signs used to display syntax and style errors/warns
line 22:         exe 'sign define SyntasticError text=' . g:syntastic_error_symbol . ' texthl=SyntasticErrorSign linehl=SyntasticErrorLine'
line 22: sign define SyntasticError text=>> texthl=SyntasticErrorSign linehl=SyntasticErrorLine
line 24:         exe 'sign define SyntasticWarning text=' . g:syntastic_warning_symbol . ' texthl=SyntasticWarningSign linehl=SyntasticWarningLine'
line 24: sign define SyntasticWarning text=>> texthl=SyntasticWarningSign linehl=SyntasticWarningLine
line 26:         exe 'sign define SyntasticStyleError text=' . g:syntastic_style_error_symbol . ' texthl=SyntasticStyleErrorSign linehl=SyntasticStyleErrorLine'
line 26: sign define SyntasticStyleError text=S> texthl=SyntasticStyleErrorSign linehl=SyntasticStyleErrorLine
line 28:         exe 'sign define SyntasticStyleWarning text=' . g:syntastic_style_warning_symbol . ' texthl=SyntasticStyleWarningSign linehl=SyntasticStyleWarningLine'
line 28: sign define SyntasticStyleWarning text=S> texthl=SyntasticStyleWarningSign linehl=SyntasticStyleWarningLine
line 30:     endif
function 295..298..310..313 returning #0

continuing in function 295..298..310

line 5:         let s:setup_done = 1
line 6:         lockvar s:setup_done
line 7:     endif
line 8: 
line 9:     return newObj
function 295..298..310 returning {'_signErrors': function('314'), '_bu...tion('310'), 'refresh': function('312')}

continuing in function 295..298

line 5:     endfor
line 2:     for type in s:notifier_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 295..298..231()

line 1:     let newObj = copy(self)
line 2:     return newObj
function 295..298..231 returning {'enabled': function('232'), 'reset':...tion('231'), 'refresh': function('233')}

continuing in function 295..298

line 5:     endfor
line 2:     for type in s:notifier_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 295..298..254()

line 1:     let newObj = copy(self)
line 2: 
line 3:     if !s:setup_done
line 4:         call self._setup()
calling function 295..298..254..258()

line 1:     if s:has_highlighting
line 2:         if !hlexists('SyntasticError')
line 3:             highlight link SyntasticError SpellBad
line 4:         endif
line 5:         if !hlexists('SyntasticWarning')
line 6:             highlight link SyntasticWarning SpellCap
line 7:         endif
line 8:         if !hlexists('SyntasticStyleError')
line 9:             highlight link SyntasticStyleError SyntasticError
line 10:         endif
line 11:         if !hlexists('SyntasticStyleWarning')
line 12:             highlight link SyntasticStyleWarning SyntasticWarning
line 13:         endif
line 14:     endif
function 295..298..254..258 returning #0

continuing in function 295..298..254

line 5:         let s:setup_done = 1
line 6:         lockvar s:setup_done
line 7:     endif
line 8: 
line 9:     return newObj
function 295..298..254 returning {'_reset': function('259'), 'enabled'...tion('254'), 'refresh': function('256')}

continuing in function 295..298

line 5:     endfor
line 2:     for type in s:notifier_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 295..298..250()

line 1:     let newObj = copy(self)
line 2:     return newObj
function 295..298..250 returning {'enabled': function('251'), 'reset':...tion('250'), 'refresh': function('252')}

continuing in function 295..298

line 5:     endfor
line 2:     for type in s:notifier_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 295..298..228()

line 1:     let newObj = copy(self)
line 2:     return newObj
function 295..298..228 returning {'AutoToggle': function('230'), 'New'...tion('228'), 'refresh': function('229')}

continuing in function 295..298

line 5:     endfor
line 2:     for type in s:notifier_types
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
line 5:     endfor
line 6: 
line 7:     let self._enabled_types = copy(s:notifier_types)
function 295..298 returning #0

continuing in function 295

line 4:     endif
line 5: 
line 6:     return s:SyntasticNotifiersInstance
function 295 returning {'_notifier': {'signs': {'_signErrors...tion('297'), 'refresh': function('296')}

continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim

line 138: let s:modemap = g:SyntasticModeMap.Instance()
calling function 286()

line 1:     if !exists('s:SyntasticModeMapInstance')
line 2:         let s:SyntasticModeMapInstance = copy(self)
line 3:         call s:SyntasticModeMapInstance.synch()
calling function 286..287()

line 1:     if exists('g:syntastic_mode_map')
line 2:         let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
line 3:         let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
line 4:         let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
line 5:     else
line 6:         let self._mode = 'active'
line 7:         let self._activeFiletypes = []
line 8:         let self._passiveFiletypes = []
line 9:     endif
function 286..287 returning #0

continuing in function 286

line 4:     endif
line 5: 
line 6:     return s:SyntasticModeMapInstance
function 286 returning {'_passiveFiletypes': [], '_activeFil...'_isOneFiletypeActive': function('293')}

continuing in /home/max/.vim/bundle/syntastic/plugin/syntastic.vim

line 139: 
line 140: " Commands {{{1
line 141: 
line 142: " @vimlint(EVL103, 1, a:cursorPos)
line 143: " @vimlint(EVL103, 1, a:cmdLine)
line 144: " @vimlint(EVL103, 1, a:argLead)
line 145: function! s:CompleteCheckerName(argLead, cmdLine, cursorPos) " {{{2
line 152: " @vimlint(EVL103, 0, a:cursorPos)
line 153: " @vimlint(EVL103, 0, a:cmdLine)
line 154: " @vimlint(EVL103, 0, a:argLead)
line 155: 
line 156: 
line 157: " @vimlint(EVL103, 1, a:cursorPos)
line 158: " @vimlint(EVL103, 1, a:cmdLine)
line 159: " @vimlint(EVL103, 1, a:argLead)
line 160: function! s:CompleteFiletypes(argLead, cmdLine, cursorPos) " {{{2
line 163: " @vimlint(EVL103, 0, a:cursorPos)
line 164: " @vimlint(EVL103, 0, a:cmdLine)
line 165: " @vimlint(EVL103, 0, a:argLead)
line 166: 
line 167: command! SyntasticToggleMode call s:ToggleMode()
line 170: command! -nargs=* -complete=custom,s:CompleteCheckerName SyntasticCheck call s:UpdateErrors(0, <f-args>) <bar> call syntastic#util#redraw(g:syntastic_full_redraws)
line 171: command! Errors call s:ShowLocList()
line 174: command! -nargs=? -complete=custom,s:CompleteFiletypes SyntasticInfo call s:modemap.modeInfo(<f-args>) | call s:registry.echoInfoFor(s:resolveFiletypes(<f-args>))
line 177: command! SyntasticReset call s:ClearCache() | call s:notifiers.refresh(g:SyntasticLoclist.New([]))
line 178: command! SyntasticSetLoclist call g:SyntasticLoclist.current().setloclist()
line 179: 
line 180: " }}}1
line 181: 
line 182: " Autocommands and hooks {{{1
line 183: 
line 184: augroup syntastic
line 185:     autocmd BufReadPost * call s:BufReadPostHook()
line 186:     autocmd BufWritePost * call s:BufWritePostHook()
line 187:     autocmd BufEnter * call s:BufEnterHook()
line 188: augroup END
line 189: 
line 190: if v:version > 703 || (v:version == 703 && has('patch544'))
line 191:     " QuitPre was added in Vim 7.3.544
line 192:     augroup syntastic
line 193:         autocmd QuitPre * call s:QuitPreHook()
line 194:     augroup END
line 195: endif
line 196: 
line 197: function! s:BufReadPostHook() " {{{2
line 204: 
line 205: function! s:BufWritePostHook() " {{{2
line 210: 
line 211: function! s:BufEnterHook() " {{{2
line 229: 
line 230: function! s:QuitPreHook() " {{{2
line 236: 
line 237: " }}}1
line 238: 
line 239: " Main {{{1
line 240: 
line 241: "refresh and redraw all the error info for this buf when saving or reading
line 242: function! s:UpdateErrors(auto_invoked, ...) " {{{2
line 290: 
line 291: "clear the loc list for the buffer
line 292: function! s:ClearCache() " {{{2
line 296: 
line 297: "detect and cache all syntax errors in this buffer
line 298: function! s:CacheErrors(checker_names) " {{{2
line 388: 
line 389: function! s:ToggleMode() " {{{2
line 395: 
line 396: "display the cached errors for this buf in the location list
line 397: function! s:ShowLocList() " {{{2
line 400: 
line 401: "Emulates the :lmake command. Sets up the make environment according to the
line 402: "options given, runs make, resets the environment, returns the location list
line 403: "
line 404: "a:options can contain the following keys:
line 405: "    'makeprg'
line 406: "    'errorformat'
line 407: "
line 408: "The corresponding options are set for the duration of the function call. They
line 409: "are set with :let, so dont escape spaces.
line 410: "
line 411: "a:options may also contain:
line 412: "   'defaults' - a dict containing default values for the returned errors
line 413: "   'subtype' - all errors will be assigned the given subtype
line 414: "   'preprocess' - a function to be applied to the error file before parsing errors
line 415: "   'postprocess' - a list of functions to be applied to the error list
line 416: "   'cwd' - change directory to the given path before running the checker
line 417: "   'env' - environment variables to set before running the checker
line 418: "   'returns' - a list of valid exit codes for the checker
line 419: " @vimlint(EVL102, 1, l:env_save)
line 420: function! SyntasticMake(options) " {{{2
line 528: " @vimlint(EVL102, 0, l:env_save)
line 529: 
line 530: "return a string representing the state of buffer according to
line 531: "g:syntastic_stl_format
line 532: "
line 533: "return '' if no errors are cached for the buffer
line 534: function! SyntasticStatuslineFlag() " {{{2
line 537: 
line 538: " }}}1
line 539: 
line 540: " Utilities {{{1
line 541: 
line 542: function! s:resolveFiletypes(...) " {{{2
line 546: 
line 547: function! s:ignoreFile(filename) " {{{2
line 556: 
line 557: " Skip running in special buffers
line 558: function! s:skipFile() " {{{2
line 568: 
line 569: " Take a list of errors and add default values to them from a:options
line 570: function! s:addToErrors(errors, options) " {{{2
line 581: 
line 582: " The script changes &shellredir and &shell to stop the screen flicking when
line 583: " shelling out to syntax checkers. Not all OSs support the hacks though.
line 584: function! s:bashHack() " {{{2
line 600: 
line 601: function! s:uname() " {{{2
line 608: 
line 609: " }}}1
line 610: 
line 611: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/max/.vim/bundle/syntastic/plugin/syntastic.vim
Searching for "/home/max/.vim/bundle/ctrlp.vim/plugin/**/*.vim"
chdir(/home/max/.vim/bundle/ctrlp.vim/plugin)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/ctrlp.vim/plugin/ctrlp.vim"
line 1: " =============================================================================
line 2: " File:          plugin/ctrlp.vim
line 3: " Description:   Fuzzy file, buffer, mru, tag, etc finder.
line 4: " Author:        Kien Nguyen <github.com/kien>
line 5: " =============================================================================
line 6: " GetLatestVimScripts: 3736 1 :AutoInstall: ctrlp.zip
line 7: 
line 8: if ( exists('g:loaded_ctrlp') && g:loaded_ctrlp ) || v:version < 700 || &cp
line 9: ^Ifini
line 10: en
line 11: let g:loaded_ctrlp = 1
line 12: 
line 15: let [g:ctrlp_lines, g:ctrlp_allfiles, g:ctrlp_alltags, g:ctrlp_alldirs, g:ctrlp_allmixes, g:ctrlp_buftags, g:ctrlp_ext_vars, g:ctrlp_builtins] = [[], [], [], [], {}, {}, [], 2]
line 16: 
line 17: if !exists('g:ctrlp_map') | let g:ctrlp_map = '<c-p>' | en
line 17:  let g:ctrlp_map = '<c-p>' | en
line 17:  en
line 18: if !exists('g:ctrlp_cmd') | let g:ctrlp_cmd = 'CtrlP' | en
line 18:  let g:ctrlp_cmd = 'CtrlP' | en
line 18:  en
line 19: 
line 20: com! -n=? -com=dir CtrlP         cal ctrlp#init(0, { 'dir': <q-args> })
line 21: com! -n=? -com=dir CtrlPMRUFiles cal ctrlp#init(2, { 'dir': <q-args> })
line 22: 
line 23: com! -bar CtrlPBuffer   cal ctrlp#init(1)
line 24: com! -n=? CtrlPLastMode cal ctrlp#init(-1, { 'args': <q-args> })
line 25: 
line 26: com! -bar CtrlPClearCache     cal ctrlp#clr()
line 27: com! -bar CtrlPClearAllCaches cal ctrlp#clra()
line 28: 
line 29: com! -bar ClearCtrlPCache     cal ctrlp#clr()
line 30: com! -bar ClearAllCtrlPCaches cal ctrlp#clra()
line 31: 
line 32: com! -bar CtrlPCurWD   cal ctrlp#init(0, { 'mode': '' })
line 33: com! -bar CtrlPCurFile cal ctrlp#init(0, { 'mode': 'c' })
line 34: com! -bar CtrlPRoot    cal ctrlp#init(0, { 'mode': 'r' })
line 35: 
line 36: if g:ctrlp_map != '' && !hasmapto(':<c-u>'.g:ctrlp_cmd.'<cr>', 'n')
line 37: ^Iexe 'nn <silent>' g:ctrlp_map ':<c-u>'.g:ctrlp_cmd.'<cr>'
line 37: nn <silent> <c-p> :<c-u>CtrlP<cr>
line 38: en
line 39: 
line 40: cal ctrlp#mrufiles#init()
Searching for "autoload/ctrlp/mrufiles.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/
Searching for "/home/max/.vim/autoload/ctrlp/mrufiles.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/ctrlp/mrufiles.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/ctrlp/mrufiles.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/ctrlp/mrufiles.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/ctrlp/mrufiles.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/ctrlp/mrufiles.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/ctrlp/mrufiles.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/ctrlp/mrufiles.vim"
Searching for "/home/max/.vim/bundle/command-t/autoload/ctrlp/mrufiles.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/autoload/ctrlp/mrufiles.vim"
Searching for "/home/max/.vim/bundle/syntastic/autoload/ctrlp/mrufiles.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim"
chdir(/home/max/.vim/bundle/ctrlp.vim/autoload/ctrlp)
fchdir() to previous dir
line 40: sourcing "/home/max/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim"
line 1: " =============================================================================
line 2: " File:          autoload/ctrlp/mrufiles.vim
line 3: " Description:   Most Recently Used Files extension
line 4: " Author:        Kien Nguyen <github.com/kien>
line 5: " =============================================================================
line 6: 
line 7: " Static variables {{{1
line 8: let [s:mrbs, s:mrufs] = [[], []]
line 9: 
line 10: fu! ctrlp#mrufiles#opts()
line 23: cal ctrlp#mrufiles#opts()
calling function ctrlp#mrufiles#opts()

line 1: ^Ilet [pref, opts] = ['g:ctrlp_mruf_', { 'max': ['s:max', 250], 'include': ['s:in', ''], 'exclude': ['s:ex', ''], 'case_sensitive': ['s:cseno', 1], 'relative': ['s:re', 0], 'save_on_update': ['s:soup', 1], }]
line 9: ^Ifor [ke, va] in items(opts)
line 10: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 11: ^Iendfo
line 9: ^Ifor [ke, va] in items(opts)
line 10: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 11: ^Iendfo
line 9: ^Ifor [ke, va] in items(opts)
line 10: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 11: ^Iendfo
line 9: ^Ifor [ke, va] in items(opts)
line 10: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 11: ^Iendfo
line 9: ^Ifor [ke, va] in items(opts)
line 10: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 11: ^Iendfo
line 9: ^Ifor [ke, va] in items(opts)
line 10: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 11: ^Iendfo
line 9: ^Ifor [ke, va] in items(opts)
line 10: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 11: ^Iendfo
function ctrlp#mrufiles#opts returning #0

continuing in /home/max/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim

line 24: " Utilities {{{1
line 25: fu! s:excl(fn)
line 28: 
line 29: fu! s:mergelists()
line 35: 
line 36: fu! s:chop(mrufs)
line 40: 
line 41: fu! s:reformat(mrufs, ...)
line 56: 
line 57: fu! s:record(bufnr)
line 67: 
line 68: fu! s:addtomrufs(fname)
line 83: 
line 84: fu! s:savetofile(mrufs)
line 87: " Public {{{1
line 88: fu! ctrlp#mrufiles#refresh(...)
line 101: 
line 102: fu! ctrlp#mrufiles#remove(files)
line 113: 
line 114: fu! ctrlp#mrufiles#add(fn)
line 119: 
line 120: fu! ctrlp#mrufiles#list(...)
line 124: 
line 125: fu! ctrlp#mrufiles#bufs()
line 128: 
line 129: fu! ctrlp#mrufiles#tgrel()
line 132: 
line 133: fu! ctrlp#mrufiles#cachefile()
line 140: 
line 141: fu! ctrlp#mrufiles#init()
line 152: "}}}
line 153: 
line 154: " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
finished sourcing /home/max/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim
continuing in /home/max/.vim/bundle/ctrlp.vim/plugin/ctrlp.vim
calling function ctrlp#mrufiles#init()

line 1: ^Iif !has('autocmd') | retu | en
line 1:  retu | en
line 1:  en
line 2: ^Ilet s:locked = 0
line 3: ^Iaug CtrlPMRUF
line 4: ^I^Iau!
line 5: ^I^Iau BufAdd,BufEnter,BufLeave,BufWritePost * cal s:record(expand('<abuf>', 1))
line 6: ^I^Iau QuickFixCmdPre  *vimgrep* let s:locked = 1
line 7: ^I^Iau QuickFixCmdPost *vimgrep* let s:locked = 0
line 8: ^I^Iau VimLeavePre * cal s:savetofile(s:mergelists())
line 9: ^Iaug END
function ctrlp#mrufiles#init returning #0

continuing in /home/max/.vim/bundle/ctrlp.vim/plugin/ctrlp.vim

line 41: 
line 42: com! -bar CtrlPTag      cal ctrlp#init(ctrlp#tag#id())
line 43: com! -bar CtrlPQuickfix cal ctrlp#init(ctrlp#quickfix#id())
line 44: 
line 46: com! -n=? -com=dir CtrlPDir cal ctrlp#init(ctrlp#dir#id(), { 'dir': <q-args> })
line 47: 
line 49: com! -n=? -com=buffer CtrlPBufTag cal ctrlp#init(ctrlp#buffertag#cmd(0, <q-args>))
line 50: 
line 51: com! -bar CtrlPBufTagAll cal ctrlp#init(ctrlp#buffertag#cmd(1))
line 52: com! -bar CtrlPRTS       cal ctrlp#init(ctrlp#rtscript#id())
line 53: com! -bar CtrlPUndo      cal ctrlp#init(ctrlp#undo#id())
line 54: 
line 56: com! -n=? -com=buffer CtrlPLine cal ctrlp#init(ctrlp#line#cmd(1, <q-args>))
line 57: 
line 59: com! -n=? -com=buffer CtrlPChange cal ctrlp#init(ctrlp#changes#cmd(0, <q-args>))
line 60: 
line 61: com! -bar CtrlPChangeAll   cal ctrlp#init(ctrlp#changes#cmd(1))
line 62: com! -bar CtrlPMixed       cal ctrlp#init(ctrlp#mixed#id())
line 63: com! -bar CtrlPBookmarkDir cal ctrlp#init(ctrlp#bookmarkdir#id())
line 64: 
line 66: com! -n=? -com=dir CtrlPBookmarkDirAdd cal ctrlp#call('ctrlp#bookmarkdir#add', <q-args>)
line 67: 
line 68: " vim:ts=2:sw=2:sts=2
finished sourcing /home/max/.vim/bundle/ctrlp.vim/plugin/ctrlp.vim
Searching for "/home/max/.vim/bundle/vim-golang/plugin/**/*.vim"
chdir(/home/max/.vim/bundle/vim-golang/plugin)
fchdir() to previous dir
sourcing "/home/max/.vim/bundle/vim-golang/plugin/godoc.vim"
line 1: " Copyright 2011 The Go Authors. All rights reserved.
line 2: " Use of this source code is governed by a BSD-style
line 3: " license that can be found in the LICENSE file.
line 4: "
line 5: " godoc.vim: Vim command to see godoc.
line 6: "
line 7: "
line 8: " Commands:
line 9: "
line 10: "   :Godoc
line 11: "
line 12: "       Open the relevant Godoc for either the word[s] passed to the command or
line 13: "       the, by default, the word under the cursor.
line 14: "
line 15: " Options:
line 16: "
line 17: "   g:go_godoc_commands [default=1]
line 18: "
line 19: "       Flag to indicate whether to enable the commands listed above.
line 20: 
line 21: if exists("g:loaded_godoc")
line 22:   finish
line 23: endif
line 24: let g:loaded_godoc = 1
line 25: 
line 26: let s:buf_nr = -1
line 27: let s:last_word = ''
line 28: 
line 29: if !exists('g:go_godoc_commands')
line 30:   let g:go_godoc_commands = 1
line 31: endif
line 32: 
line 33: if g:go_godoc_commands
line 34:   command! -nargs=* -range -complete=customlist,go#complete#Package Godoc :call s:Godoc(<f-args>)
line 35: endif
line 36: 
line 37: nnoremap <silent> <Plug>(godoc-keyword) :<C-u>call <SID>Godoc('')<CR>
line 38: 
line 39: function! s:GodocView()
line 67: 
line 68: function! s:GodocWord(word)
line 101: 
line 102: function! s:Godoc(...)
line 129: 
line 130: " vim:ts=4:sw=4:et
finished sourcing /home/max/.vim/bundle/vim-golang/plugin/godoc.vim
Searching for "/home/max/.vim/bundle/scss-syntax.vim/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/google.vim/plugin/**/*.vim"
Searching for "/var/lib/vim/addons/plugin/**/*.vim"
Searching for "/usr/share/vim/vimfiles/plugin/**/*.vim"
Searching for "/usr/share/vim/vim74/plugin/**/*.vim"
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/getscriptPlugin.vim"
line 1: " ---------------------------------------------------------------------
line 2: " getscriptPlugin.vim
line 3: "  Author:^ICharles E. Campbell
line 4: "  Date:^IJan 07, 2008
line 5: "  Installing:^I:help glvs-install
line 6: "  Usage:^I:help glvs
line 7: "
line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
line 9: "
line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
line 11: " all the peoples praise Him."
line 12: " ---------------------------------------------------------------------
line 13: " Initialization:^I{{{1
line 14: " if you're sourcing this file, surely you can't be
line 15: " expecting vim to be in its vi-compatible mode
line 16: if &cp || exists("g:loaded_getscriptPlugin")
line 17:  if &verbose
line 18:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
line 19:  endif
line 20:  finish
line 21: endif
line 22: let g:loaded_getscriptPlugin = "v35"
line 23: let s:keepcpo                = &cpo
line 24: set cpo&vim
line 25: 
line 26: " ---------------------------------------------------------------------
line 27: "  Public Interface: {{{1
line 28: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
line 29: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
line 30: silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()
line 31: 
line 32: " ---------------------------------------------------------------------
line 33: " Restore Options: {{{1
line 34: let &cpo= s:keepcpo
line 35: unlet s:keepcpo
line 36: 
line 37: " ---------------------------------------------------------------------
line 38: " vim: ts=8 sts=2 fdm=marker nowrap
finished sourcing /usr/share/vim/vim74/plugin/getscriptPlugin.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2010 Mar 10
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of compressed files
line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 10:   finish
line 11: endif
line 12: let loaded_gzip = 1
line 13: 
line 14: augroup gzip
line 15:   " Remove all gzip autocommands
line 16:   au!
line 17: 
line 18:   " Enable editing of gzipped files.
line 19:   " The functions are defined in autoload/gzip.vim.
line 20:   "
line 21:   " Set binary mode before reading the file.
line 22:   " Use "gzip -d", gunzip isn't always available.
line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz setlocal bin
line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 29:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 30:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 31:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 32:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 33:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 34:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 35:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 36:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 37:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 38:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 39:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 40:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 41:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 42:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 43:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 44: augroup END
finished sourcing /usr/share/vim/vim74/plugin/gzip.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2013 May 08
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded (or disabled)
line 7: " - when 'compatible' is set
line 8: " - the "CursorMoved" autocmd event is not available.
line 9: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
line 10:   finish
line 11: endif
line 12: let g:loaded_matchparen = 1
line 13: 
line 14: if !exists("g:matchparen_timeout")
line 15:   let g:matchparen_timeout = 300
line 16: endif
line 17: if !exists("g:matchparen_insert_timeout")
line 18:   let g:matchparen_insert_timeout = 60
line 19: endif
line 20: 
line 21: augroup matchparen
line 22:   " Replace all matchparen autocommands
line 23:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
line 24:   if exists('##TextChanged')
line 25:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 26:   endif
line 27: augroup END
line 28: 
line 29: " Skip the rest if it was already done.
line 30: if exists("*s:Highlight_Matching_Pair")
line 31:   finish
line 32: endif
line 33: 
line 34: let s:cpo_save = &cpo
line 35: set cpo-=C
line 36: 
line 37: " The function that is invoked (very often) to define a ":match" highlighting
line 38: " for any matching paren.
line 39: function! s:Highlight_Matching_Pair()
line 160: 
line 161: " Define commands that will disable and enable the plugin.
line 163: command! NoMatchParen windo 3match none | unlet! g:loaded_matchparen | au! matchparen
line 164: command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved
line 165: 
line 166: let &cpo = s:cpo_save
line 167: unlet s:cpo_save
finished sourcing /usr/share/vim/vim74/plugin/matchparen.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/netrwPlugin.vim"
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
line 2: "            PLUGIN SECTION
line 3: " Date:^I^IApr 30, 2013
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
line 6: " Copyright:    Copyright (C) 1999-2012 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
line 11: "               *as is* and comes with no warranty of any kind, either
line 12: "               expressed or implied. By using this plugin, you agree that
line 13: "               in no event will the copyright holder be liable for any damages
line 14: "               resulting from the use of this software.
line 15: "
line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
line 17: "  (James 1:22 RSV)
line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_netrwPlugin")
line 21:  finish
line 22: endif
line 23: "DechoTabOn
line 24: let g:loaded_netrwPlugin = "v149"
line 25: if v:version < 702
line 26:  echohl WarningMsg | echo "***netrw*** you need vim version 7.2 for this version of netrw" | echohl None
line 26:  echo "***netrw*** you need vim version 7.2 for this version of netrw" | echohl None
line 26:  echohl None
line 27:  finish
line 28: endif
line 29: let s:keepcpo = &cpo
line 30: set cpo&vim
line 31: "DechoTabOn
line 32: 
line 33: " ---------------------------------------------------------------------
line 34: " Public Interface: {{{1
line 35: 
line 36: " Local Browsing: {{{2
line 37: augroup FileExplorer
line 38:  au!
line 39:  " SEE Benzinger problem...
line 40:  au BufEnter *^Isil! call s:LocalBrowse(expand("<amatch>"))
line 41:  au VimEnter *^Isil! call s:VimEnter(expand("<amatch>"))
line 42:  if has("win32") || has("win95") || has("win64") || has("win16")
line 43:   au BufEnter .* sil! call s:LocalBrowse(expand("<amatch>"))
line 44:  endif
line 45: augroup END
line 46: 
line 47: " Network Browsing Reading Writing: {{{2
line 48: augroup Network
line 49:  au!
line 50:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^Icall netrw#FileUrlRead(expand("<amatch>"))
line 51:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
line 52:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
line 53:  au BufWriteCmd  ftp://*,rcp://*,scp://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
line 54:  au FileWriteCmd ftp://*,rcp://*,scp://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
line 55:  try
line 56:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 57:  catch /^Vim\%((\a\+)\)\=:E216/
line 58:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 59:  endtry
line 60: augroup END
line 61: 
line 62: " Commands: :Nread, :Nwrite, :NetUserPass {{{2
line 63: com! -count=1 -nargs=*^INread^I^Icall netrw#NetrwSavePosn()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call netrw#NetrwRestorePosn()
line 64: com! -range=% -nargs=*^INwrite^I^Icall netrw#NetrwSavePosn()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call netrw#NetrwRestorePosn()
line 65: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)
line 66: com! -nargs=*^I        Nsource^I^Icall netrw#NetrwSavePosn()<bar>call netrw#NetSource(<f-args>)<bar>call netrw#NetrwRestorePosn()
line 67: 
line 68: " Commands: :Explore, :Sexplore, Hexplore, Vexplore {{{2
line 69: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)
line 70: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)
line 71: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)
line 72: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)
line 73: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)
line 74: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)
line 75: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)
line 76: 
line 77: " Commands: NetrwSettings {{{2
line 78: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()
line 79: com! -bang^INetrwClean^Icall netrw#NetrwClean(<bang>0)
line 80: 
line 81: " Maps:
line 82: if !exists("g:netrw_nogx") && maparg('gx','n') == ""
line 83:  if !hasmapto('<Plug>NetrwBrowseX')
line 84:   nmap <unique> gx <Plug>NetrwBrowseX
line 85:  endif
line 86:  nno <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)<cr>
line 87: endif
line 88: 
line 89: " ---------------------------------------------------------------------
line 90: " LocalBrowse: {{{2
line 91: fun! s:LocalBrowse(dirname)
line 116: 
line 117: " ---------------------------------------------------------------------
line 118: " s:VimEnter: {{{2
line 119: fun! s:VimEnter(dirname)
line 127: 
line 128: " ---------------------------------------------------------------------
line 129: " NetrwStatusLine: {{{1
line 130: fun! NetrwStatusLine()
line 141: 
line 142: " ------------------------------------------------------------------------
line 143: " NetUserPass: set username and password for subsequent ftp transfer {{{1
line 144: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password
line 145: "^I    :call NetUserPass("uid")^I^I-- will prompt for password
line 146: "^I    :call NetUserPass("uid","password") -- sets global userid and password
line 147: fun! NetUserPass(...)
line 171: 
line 172: " ------------------------------------------------------------------------
line 173: " Modelines And Restoration: {{{1
line 174: let &cpo= s:keepcpo
line 175: unlet s:keepcpo
line 176: " vim:ts=8 fdm=marker
finished sourcing /usr/share/vim/vim74/plugin/netrwPlugin.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/rrhelper.vim"
line 1: " Vim plugin with helper function(s) for --remote-wait
line 2: " Maintainer: Flemming Madsen <fma@cci.dk>
line 3: " Last Change: 2008 May 29
line 4: 
line 5: " Has this already been loaded?
line 6: if exists("loaded_rrhelper") || !has("clientserver")
line 7:   finish
line 8: endif
line 9: let loaded_rrhelper = 1
line 10: 
line 11: " Setup answers for a --remote-wait client who will assume
line 12: " a SetupRemoteReplies() function in the command server
line 13: 
line 14: function SetupRemoteReplies()
line 41: 
line 42: function DoRemoteReply(id, cnt, group, file)
line 47: 
line 48: " vim: set sw=2 sts=2 :
finished sourcing /usr/share/vim/vim74/plugin/rrhelper.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2006 Feb 01
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of spell files
line 9: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 10:   finish
line 11: endif
line 12: let loaded_spellfile_plugin = 1
line 13: 
line 14: " The function is in the autoload directory.
line 15: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /usr/share/vim/vim74/plugin/spellfile.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 3: " Modified by Charles E. Campbell
line 4: " Distributed under the GNU General Public License.
line 5: "
line 6: " Updates are available from <http://michael.toren.net/code/>.  If you
line 7: " find this script useful, or have suggestions for improvements, please
line 8: " let me know.
line 9: " Also look there for further comments and documentation.
line 10: "
line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: if &cp || exists("g:loaded_tarPlugin")
line 15:  finish
line 16: endif
line 17: let g:loaded_tarPlugin = "v29"
line 18: let s:keepcpo          = &cpo
line 19: set cpo&vim
line 20: 
line 21: " ---------------------------------------------------------------------
line 22: "  Public Interface: {{{1
line 23: augroup tar
line 24:   au!
line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29: 
line 30:   if has("unix")
line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:   endif
line 36: 
line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 46: augroup END
line 47: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
line 48: 
line 49: " ---------------------------------------------------------------------
line 50: " Restoration And Modelines: {{{1
line 51: " vim: fdm=marker
line 52: let &cpo= s:keepcpo
line 53: unlet s:keepcpo
finished sourcing /usr/share/vim/vim74/plugin/tarPlugin.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/tohtml.vim"
line 1: " Vim plugin for converting a syntax highlighted file to HTML.
line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
line 3: " Last Change: 2013 Jul 08
line 4: "
line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
line 6: " $VIMRUNTIME/syntax/2html.vim
line 7: "
line 8: " TODO: {{{
line 9: "   * Options for generating the CSS in external style sheets. New :TOcss
line 10: "     command to convert the current color scheme into a (mostly) generic CSS
line 11: "     stylesheet which can be re-used. Alternate stylesheet support? Good start
line 12: "     by Erik Falor
line 13: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
line 14: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
line 15: "     term) to use for the styling. Suggestion by "nacitar".
line 16: "   * Add way to override or specify which RGB colors map to the color numbers
line 17: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
line 18: "   * Disable filetype detection until after all processing is done.
line 19: "   * Add option for not generating the hyperlink on stuff that looks like a
line 20: "     URL? Or just color the link to fit with the colorscheme (and only special
line 21: "     when hovering)?
line 22: "   * Bug: Opera does not allow printing more than one page if uncopyable
line 23: "     regions is turned on. Possible solution: Add normal text line numbers with
line 24: "     display:none, set to display:inline for print style sheets, and hide
line 25: "     <input> elements for print, to allow Opera printing multiple pages (and
line 26: "     other uncopyable areas?). May need to make the new text invisible to IE
line 27: "     with conditional comments to prevent copying it, IE for some reason likes
line 28: "     to copy hidden text. Other browsers too?
line 29: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
line 30: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
line 31: "     on Windows). Perhaps it is font related?
line 32: "   * Bug: still some gaps in the fold column when html_prevent_copy contains
line 33: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
line 34: "     on diff lines though.
line 35: "   * Undercurl support via CSS3, with fallback to dotted or something:
line 36: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
line 37: "   * Redo updates for modified default foldtext (v11) when/if the patch is
line 38: "     accepted to modify it.
line 39: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
line 40: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
line 41: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
line 42: "     does not show the whole diff filler as it is supposed to?
line 43: "   * Bug: when 'isprint' is wrong for the current encoding, will generate
line 44: "     invalid content. Can/should anything be done about this? Maybe a separate
line 45: "     plugin to correct 'isprint' based on encoding?
line 46: "   * Check to see if the windows-125\d encodings actually work in Unix without
line 47: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
line 48: "   * Font auto-detection similar to
line 49: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
line 50: "     platforms.
line 51: "   * Error thrown when sourcing 2html.vim directly when plugins are not loaded.
line 52: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
line 53: "^I- listchars support
line 54: "^I- full-line background highlight
line 55: "^I- other?
line 56: "   * Make it so deleted lines in a diff don't create side-scrolling (get it
line 57: "     free with full-line background highlight above).
line 58: "   * Restore open/closed folds and cursor position after processing each file
line 59: "     with option not to restore for speed increase.
line 60: "   * Add extra meta info (generation time, etc.)?
line 61: "   * Tidy up so we can use strict doctype in even more situations
line 62: "   * Implementation detail: add threshold for writing the lines to the html
line 63: "     buffer before we're done (5000 or so lines should do it)
line 64: "   * TODO comments for code cleanup scattered throughout
line 65: "}}}
line 66: 
line 67: if exists('g:loaded_2html_plugin')
line 68:   finish
line 69: endif
line 70: let g:loaded_2html_plugin = 'vim7.4_v1'
line 71: 
line 72: "
line 73: " Changelog: {{{
line 74: "   7.4_v1  (this version): Fix modeline mangling for new "Vim:" format, and
line 75: "^I^I^I    also for version-specific modelines like "vim>703:".
line 76: "
line 77: "   7.3 updates: {{{
line 78: "   7.3_v14 (ad6996a23e3e): Allow suppressing line number anchors using
line 79: "^I^I^I    g:html_line_ids=0. Allow customizing
line 80: "^I^I^I    important IDs (like line IDs and fold IDs) using
line 81: "^I^I^I    g:html_id_expr evalutated when the buffer conversion
line 82: "^I^I^I    is started.
line 83: "   7.3_v13 (2eb30f341e8d): Keep foldmethod at manual in the generated file and
line 84: "^I^I^I    insert modeline to set it to manual.
line 85: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a
line 86: "^I^I^I    duplicate of one buffer instead of including both.
line 87: "^I^I^I    Add anchors to each line so you can put '#L123'
line 88: "^I^I^I    or '#123' at the end of the URL to jump to line 123
line 89: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds
line 90: "^I^I^I    to show the anchor being jumped to if it is hidden.
line 91: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.
line 92: "^I^I^I    Allow TOhtml to chain together with other commands
line 93: "^I^I^I    using |.
line 94: "   7.3_v12 (9910cbff5f16): Fix modeline mangling to also work for when multiple
line 95: "^I^I^I    highlight groups make up the start-of-modeline text.
line 96: "^I^I^I    Improve render time of page with uncopyable regions
line 97: "^I^I^I    by not using one-input-per-char. Change name of
line 98: "^I^I^I    uncopyable option from html_unselectable to
line 99: "^I^I^I    html_prevent_copy. Added html_no_invalid option and
line 100: "^I^I^I    default to inserting invalid markup for uncopyable
line 101: "^I^I^I    regions to prevent MS Word from pasting undeletable
line 102: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).
line 103: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to
line 104: "^I^I^I    eliminate post-processing substitute commands in
line 105: "^I^I^I    favor of doing the work up front. Remove unnecessary
line 106: "^I^I^I    special treatment of 'LineNr' highlight group. Minor
line 107: "^I^I^I    speed improvements. Fix modeline mangling in
line 108: "^I^I^I    generated output so it works for text in the first
line 109: "^I^I^I    column. Fix missing line number and fold column in
line 110: "^I^I^I    diff filler lines. Fix that some fonts have a 1px
line 111: "^I^I^I    gap (using a dirty hack, improvements welcome). Add
line 112: "^I^I^I    "colorscheme" meta tag. Does NOT include support for
line 113: "^I^I^I    the new default foldtext added in v11, as the patch
line 114: "^I^I^I    adding it has not yet been included in Vim.
line 115: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
line 116: "^I^I^I    Brabandt in
line 117: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
line 118: "^I^I^I    This patch has not yet been included in Vim, thus
line 119: "^I^I^I    these changes are removed in the next version.
line 120: "   7.3_v10 (fd09a9c8468e): Fix error E684 when converting a range wholly inside
line 121: "^I^I^I    multiple nested folds with dynamic folding on.
line 122: "^I^I^I    Also fix problem with foldtext in this situation.
line 123: "   7.3_v9  (0877b8d6370e): Add html_pre_wrap option active with html_use_css
line 124: "^I^I^I    and without html_no_pre, default value same as
line 125: "^I^I^I    'wrap' option, (Andy Spencer). Don't use
line 126: "^I^I^I    'fileencoding' for converted document encoding if
line 127: "^I^I^I    'buftype' indicates a special buffer which isn't
line 128: "^I^I^I    written.
line 129: "   7.3_v8  (85c5a72551e2): Add html_expand_tabs option to allow leaving tab
line 130: "^I^I^I    characters in generated output (Andy Spencer).
line 131: "^I^I^I    Escape text that looks like a modeline so Vim
line 132: "^I^I^I    doesn't use anything in the converted HTML as a
line 133: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts
line 134: "^I^I^I    before the conversion range. Remove fold column when
line 135: "^I^I^I    there are no folds.
line 136: "   7.3_v7  (840c3cadb842): see betas released on vim_dev below:
line 137: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
line 138: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not
line 139: "^I^I^I    supported by all major browsers according to
line 140: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and
line 141: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make
line 142: "^I^I^I    HTML encoding to Vim encoding detection be
line 143: "^I^I^I    case-insensitive for built-in pairs.
line 144: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be
line 145: "^I^I^I    called in restricted mode (Andy Spencer). Use
line 146: "^I^I^I    'fencoding' instead of 'encoding' to determine by
line 147: "^I^I^I    charset, and make sure the 'fenc' of the generated
line 148: "^I^I^I    file matches its indicated charset. Add charsets for
line 149: "^I^I^I    all of Vim's natively supported encodings.
line 150: "   7.3_v6  (0d3f0e3d289b): Really fix bug with 'nowrapscan', 'magic' and other
line 151: "^I^I^I    user settings interfering with diff mode generation,
line 152: "^I^I^I    trailing whitespace (e.g. line number column) when
line 153: "^I^I^I    using html_no_pre, and bugs when using
line 154: "^I^I^I    html_hover_unfold.
line 155: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
line 156: "^I^I^I    folds in diff mode when first line was folded.
line 157: "   7.3_v4  (7e008c174cc3): Bugfixes, especially for xhtml markup, and diff mode
line 158: "   7.3_v3  (a29075150aee): Refactor option handling and make html_use_css
line 159: "^I^I^I    default to true when not set to anything. Use strict
line 160: "^I^I^I    doctypes where possible. Rename use_xhtml option to
line 161: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension
line 162: "^I^I^I    when using this option. Add meta tag for settings.
line 163: "   7.3_v2  (80229a724a11): Fix syntax highlighting in diff mode to use both the
line 164: "^I^I^I    diff colors and the normal syntax colors
line 165: "   7.3_v1  (e7751177126b): Add conceal support and meta tags in output
line 166: "   Pre-v1 baseline: Mercurial changeset 3c9324c0800e
line 167: "}}}
line 168: "}}}
line 169: 
line 170: " Define the :TOhtml command when:
line 171: " - 'compatible' is not set
line 172: " - this plugin was not already loaded
line 173: " - user commands are available. {{{
line 174: if !&cp && !exists(":TOhtml") && has("user_commands")
line 175:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
line 176: endif "}}}
line 177: 
line 178: " Make sure any patches will probably use consistent indent
line 179: "   vim: ts=8 sw=2 sts=2 noet fdm=marker
finished sourcing /usr/share/vim/vim74/plugin/tohtml.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/vimballPlugin.vim"
line 1: " vimballPlugin : construct a file containing both paths and files
line 2: " Author: Charles E. Campbell, Jr.
line 3: " Copyright: (c) 2004-2010 by Charles E. Campbell, Jr.
line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".
line 6: "            No warranty, express or implied.
line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***
line 8: "
line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
line 10: "      judge. For in that which you judge another, you condemn yourself. For
line 11: "      you who judge practice the same things.
line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
line 13: 
line 14: " ---------------------------------------------------------------------
line 15: "  Load Once: {{{1
line 16: if &cp || exists("g:loaded_vimballPlugin")
line 17:  finish
line 18: endif
line 19: let g:loaded_vimballPlugin = "v35"
line 20: let s:keepcpo              = &cpo
line 21: set cpo&vim
line 22: 
line 23: " ------------------------------------------------------------------------------
line 24: " Public Interface: {{{1
line 25: com! -ra   -complete=file -na=+ -bang MkVimball^I^I^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
line 26: com! -na=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)
line 27: com! -na=0                VimballList^I^I^I^I^I^Icall vimball#Vimball(0)
line 28: com! -na=* -complete=dir  RmVimball^I^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
line 29: au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")
line 30: au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if expand("%")!=expand("<afile>")|close|endif
line 31: au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 32: au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")
line 33: au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if expand("%")!=expand("<afile>")|close|endif
line 34: au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 35: 
line 36: " =====================================================================
line 37: " Restoration And Modelines: {{{1
line 38: " vim: fdm=marker
line 39: let &cpo= s:keepcpo
line 40: unlet s:keepcpo
finished sourcing /usr/share/vim/vim74/plugin/vimballPlugin.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^IJun 07, 2013
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " License:^I^IVim License  (see vim's :help license)
line 6: " Copyright:    Copyright (C) 2005-2013 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 18: " ---------------------------------------------------------------------
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_zipPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_zipPlugin = "v27"
line 24: let s:keepcpo          = &cpo
line 25: set cpo&vim
line 26: 
line 27: " ---------------------------------------------------------------------
line 28: " Options: {{{1
line 29: if !exists("g:zipPlugin_ext")
line 30:  let g:zipPlugin_ext= '*.zip,*.jar,*.xpi,*.ja,*.war,*.ear,*.celzip,*.oxt,*.kmz,*.wsz,*.xap,*.docx,*.docm,*.dotx,*.dotm,*.potx,*.potm,*.ppsx,*.ppsm,*.pptx,*.pptm,*.ppam,*.sldx,*.thmx,*.xlam,*.xlsx,*.xlsm,*.xlsb,*.xltx,*.xltm,*.xlam,*.crtx,*.vdw,*.glox,*.gcsx,*.gqsx'
line 31: endif
line 32: 
line 33: " ---------------------------------------------------------------------
line 34: " Public Interface: {{{1
line 35: augroup zip
line 36:  au!
line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41: 
line 42:  if has("unix")
line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:  endif
line 48: 
line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 49: au BufReadCmd *.zip,*.jar,*.xpi,*.ja,*.war,*.ear,*.celzip,*.oxt,*.kmz,*.wsz,*.xap,*.docx,*.docm,*.dotx,*.dotm,*.potx,*.potm,*.ppsx,*.ppsm,*.pptx,*.pptm,*.ppam,*.sldx,*.thmx,*.xlam,*.xlsx,*.xlsm,*.xlsb,*.xltx,*.xltm,*.xlam,*.crtx,*.vdw,*.glox,*.gcsx,*.gqsx call zip#Browse(expand("<amatch>"))
line 50: augroup END
line 51: 
line 52: " ---------------------------------------------------------------------
line 53: "  Restoration And Modelines: {{{1
line 54: "  vim: fdm=marker
line 55: let &cpo= s:keepcpo
line 56: unlet s:keepcpo
finished sourcing /usr/share/vim/vim74/plugin/zipPlugin.vim
Searching for "/usr/share/vim/vimfiles/after/plugin/**/*.vim"
Searching for "/var/lib/vim/addons/after/plugin/**/*.vim"
Searching for "/home/max/.vim/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/Vundle.vim/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/vundle/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/vim-rails/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim//after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/L9/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/command-t/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/syntastic/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/vim-golang/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/scss-syntax.vim/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/vim-coffee-script/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/LaTeX-Box/after/plugin/**/*.vim"
Searching for "/home/max/.vim/bundle/google.vim/after/plugin/**/*.vim"
Opening the X display took 0 msec
Reading viminfo file "/home/max/.viminfo" info oldfiles
Opening the X display took 24 msec
Executing BufWinEnter Auto commands for "*"
autocommand if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif

line 0: if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif
calling function <SNR>33_can_diffoff(1)

line 1:   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))
function <SNR>33_can_diffoff returning #0

continuing in BufWinEnter Auto commands for "*"

line 0:    call s:diffoff() | endif
line 0:  endif
Executing BufEnter Auto commands for "*"
autocommand if exists("b:rails_root")|silent doau User BufEnterRails|endif

line 0: if exists("b:rails_root")|silent doau User BufEnterRails|endif
line 0: silent doau User BufEnterRails|endif
line 0: endif
Executing BufEnter Auto commands for "*"
autocommand call s:updateBufTimes()

line 0: call s:updateBufTimes()
calling function <SNR>40_updateBufTimes()

line 1:   let s:bufTimes[bufnr('%')] = localtime()
function <SNR>40_updateBufTimes returning #0

continuing in BufEnter Auto commands for "*"

Executing BufEnter Auto commands for "*"
autocommand call s:BufEnterHook()

line 0: call s:BufEnterHook()
calling function <SNR>71_BufEnterHook()

line 1:     call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: BufEnter, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))) . ', &buftype = ' . string(&buftype))
calling function <SNR>71_BufEnterHook..syntastic#log#debug(8, 'autocmd: BufEnter, buffer 1 = '''', &buftype = ''''')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>71_BufEnterHook..syntastic#log#debug..<SNR>72__isDebugEnabled_smart(8)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>71_BufEnterHook..syntastic#log#debug..<SNR>72__isDebugEnabled_smart returning #0

continuing in function <SNR>71_BufEnterHook..syntastic#log#debug

line 2:         return
function <SNR>71_BufEnterHook..syntastic#log#debug returning #0

continuing in function <SNR>71_BufEnterHook

line 4:     if &buftype == ''
line 5:         call s:notifiers.refresh(g:SyntasticLoclist.current())
calling function <SNR>71_BufEnterHook..261()

line 1:     if !exists("b:syntastic_loclist") || empty(b:syntastic_loclist)
line 2:         let b:syntastic_loclist = g:SyntasticLoclist.New([])
calling function <SNR>71_BufEnterHook..261..260([])

line 1:     let newObj = copy(self)
line 2: 
line 3:     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
line 4: 
line 5:     for e in llist
line 6:         if get(e, 'type', '') == ''
line 7:             let e['type'] = 'E'
line 8:         endif
line 9:     endfor
line 10: 
line 11:     let newObj._rawLoclist = llist
line 12:     let newObj._name = ''
line 13:     let newObj._owner = bufnr('')
line 14:     let newObj._sorted = 0
line 15:     let newObj._columns = g:syntastic_cursor_columns
line 16: 
line 17:     return newObj
function <SNR>71_BufEnterHook..261..260 returning {'_sorted': 0, 'decorate': function('...columns': 1, 'setName': function('273')}

continuing in function <SNR>71_BufEnterHook..261

line 3:     endif
line 4:     return b:syntastic_loclist
function <SNR>71_BufEnterHook..261 returning {'_sorted': 0, 'decorate': function('...columns': 1, 'setName': function('273')}

continuing in function <SNR>71_BufEnterHook

calling function <SNR>71_BufEnterHook..296({'_sorted': 0, 'decorate': function('...columns': 1, 'setName': function('273')})

line 1:     if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
calling function <SNR>71_BufEnterHook..296..264()

line 1:     return empty(self._rawLoclist)
function <SNR>71_BufEnterHook..296..264 returning #1

continuing in function <SNR>71_BufEnterHook..296

line 2:         " loclist not fully constructed yet
line 3:         return
line 4:     endif
line 5: 
line 6:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'notifiers: refresh')
calling function <SNR>71_BufEnterHook..296..syntastic#log#debug(4, 'notifiers: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>71_BufEnterHook..296..syntastic#log#debug..<SNR>72__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>71_BufEnterHook..296..syntastic#log#debug..<SNR>72__isDebugEnabled_smart returning #0

continuing in function <SNR>71_BufEnterHook..296..syntastic#log#debug

line 2:         return
function <SNR>71_BufEnterHook..296..syntastic#log#debug returning #0

continuing in function <SNR>71_BufEnterHook..296

line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>71_BufEnterHook..296..311()

line 1:     return has('signs') && syntastic#util#var('enable_signs')
calling function <SNR>71_BufEnterHook..296..311..syntastic#util#var('enable_signs')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>71_BufEnterHook..296..311..syntastic#util#var returning #1

continuing in function <SNR>71_BufEnterHook..296..311

function <SNR>71_BufEnterHook..296..311 returning #1

continuing in function <SNR>71_BufEnterHook..296

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
calling function <SNR>71_BufEnterHook..296..265([])

line 1:     if !exists("self._stamp")
line 2:         let self._stamp = []
line 3:         return 0
function <SNR>71_BufEnterHook..296..265 returning #0

continuing in function <SNR>71_BufEnterHook..296

calling function <SNR>71_BufEnterHook..296..264()

line 1:     return empty(self._rawLoclist)
function <SNR>71_BufEnterHook..296..264 returning #1

continuing in function <SNR>71_BufEnterHook..296

line 16:                     call self._notifier[type].refresh(a:loclist)
calling function <SNR>71_BufEnterHook..296..312({'_sorted': 0, 'decorate': function('...columns': 1, 'setName': function('273')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'signs: refresh')
calling function <SNR>71_BufEnterHook..296..312..syntastic#log#debug(4, 'signs: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>71_BufEnterHook..296..312..syntastic#log#debug..<SNR>72__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>71_BufEnterHook..296..312..syntastic#log#debug..<SNR>72__isDebugEnabled_smart returning #0

continuing in function <SNR>71_BufEnterHook..296..312..syntastic#log#debug

line 2:         return
function <SNR>71_BufEnterHook..296..312..syntastic#log#debug returning #0

continuing in function <SNR>71_BufEnterHook..296..312

line 2:     let old_signs = copy(self._bufSignIds())
calling function <SNR>71_BufEnterHook..296..312..316()

line 1:     if !exists("b:syntastic_sign_ids")
line 2:         let b:syntastic_sign_ids = []
line 3:     endif
line 4:     return b:syntastic_sign_ids
function <SNR>71_BufEnterHook..296..312..316 returning []

continuing in function <SNR>71_BufEnterHook..296..312

line 3:     if self.enabled()
calling function <SNR>71_BufEnterHook..296..312..311()

line 1:     return has('signs') && syntastic#util#var('enable_signs')
calling function <SNR>71_BufEnterHook..296..312..311..syntastic#util#var('enable_signs')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>71_BufEnterHook..296..312..311..syntastic#util#var returning #1

continuing in function <SNR>71_BufEnterHook..296..312..311

function <SNR>71_BufEnterHook..296..312..311 returning #1

continuing in function <SNR>71_BufEnterHook..296..312

line 4:         call self._signErrors(a:loclist)
calling function <SNR>71_BufEnterHook..296..312..314({'_sorted': 0, 'decorate': function('...columns': 1, 'setName': function('273')})

line 1:     let loclist = a:loclist
line 2:     if !loclist.isEmpty()
calling function <SNR>71_BufEnterHook..296..312..314..264()

line 1:     return empty(self._rawLoclist)
function <SNR>71_BufEnterHook..296..312..314..264 returning #1

continuing in function <SNR>71_BufEnterHook..296..312..314

line 3: 
line 4:         let buf = bufnr('')
line 5:         if !bufloaded(buf)
line 6:             " signs can be placed only in loaded buffers
line 7:             return
line 8:         endif
line 9: 
line 10:         " errors come first, so that they are not masked by warnings
line 11:         let issues = copy(loclist.errors())
line 12:         call extend(issues, loclist.warnings())
line 13:         call filter(issues, 'v:val["bufnr"] == buf')
line 14:         let seen = {}
line 15: 
line 16:         for i in issues
line 17:             if i['lnum'] > 0 && !has_key(seen, i['lnum'])
line 18:                 let seen[i['lnum']] = 1
line 19: 
line 20:                 let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
line 21:                 let sign_subtype = get(i, 'subtype', '')
line 22:                 let sign_type = 'Syntastic' . sign_subtype . sign_severity
line 23: 
line 24:                 execute "sign place " . s:next_sign_id . " line=" . i['lnum'] . " name=" . sign_type . " buffer=" . i['bufnr']
line 25:                 call add(self._bufSignIds(), s:next_sign_id)
line 26:                 let s:next_sign_id += 1
line 27:             endif
line 28:         endfor
line 29:     endif
function <SNR>71_BufEnterHook..296..312..314 returning #0

continuing in function <SNR>71_BufEnterHook..296..312

line 5:     endif
line 6:     call self._removeSigns(old_signs)
calling function <SNR>71_BufEnterHook..296..312..315([])

line 1:     if has('signs')
line 2:         for s in reverse(copy(a:ids))
line 3:             execute "sign unplace " . s
line 4:             call remove(self._bufSignIds(), index(self._bufSignIds(), s))
line 5:         endfor
line 6:     endif
function <SNR>71_BufEnterHook..296..312..315 returning #0

continuing in function <SNR>71_BufEnterHook..296..312

function <SNR>71_BufEnterHook..296..312 returning #0

continuing in function <SNR>71_BufEnterHook..296

line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
calling function <SNR>71_BufEnterHook..296..syntastic#util#stamp()

line 1:     return reltime(g:syntastic_start)
function <SNR>71_BufEnterHook..296..syntastic#util#stamp returning [0, 68727]

continuing in function <SNR>71_BufEnterHook..296

line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>71_BufEnterHook..296..232()

line 1:     return has('balloon_eval') && syntastic#util#var('enable_balloons')
calling function <SNR>71_BufEnterHook..296..232..syntastic#util#var('enable_balloons')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>71_BufEnterHook..296..232..syntastic#util#var returning #1

continuing in function <SNR>71_BufEnterHook..296..232

function <SNR>71_BufEnterHook..296..232 returning #1

continuing in function <SNR>71_BufEnterHook..296

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
calling function <SNR>71_BufEnterHook..296..265([])

line 1:     if !exists("self._stamp")
line 2:         let self._stamp = []
line 3:         return 0
line 4:     endif
line 5:     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0
calling function <SNR>71_BufEnterHook..296..265..syntastic#util#compareLexi([], [])

line 1:     for idx in range(max([len(a:a), len(a:b)]))
line 2:         let a_element = str2nr(get(a:a, idx, 0))
line 3:         let b_element = str2nr(get(a:b, idx, 0))
line 4:         if a_element != b_element
line 5:             return a_element > b_element ? 1 : -1
line 6:         endif
line 7:     endfor
line 8:     " Everything matched, so it is at least the required version.
line 9:     return 0
function <SNR>71_BufEnterHook..296..265..syntastic#util#compareLexi returning #0

continuing in function <SNR>71_BufEnterHook..296..265

function <SNR>71_BufEnterHook..296..265 returning #0

continuing in function <SNR>71_BufEnterHook..296

calling function <SNR>71_BufEnterHook..296..264()

line 1:     return empty(self._rawLoclist)
function <SNR>71_BufEnterHook..296..264 returning #1

continuing in function <SNR>71_BufEnterHook..296

line 16:                     call self._notifier[type].refresh(a:loclist)
calling function <SNR>71_BufEnterHook..296..233({'_sorted': 0, 'decorate': function('...columns': 1, 'setName': function('273')})

line 1:     let b:syntastic_balloons = {}
line 2:     if self.enabled() && !a:loclist.isEmpty()
calling function <SNR>71_BufEnterHook..296..233..232()

line 1:     return has('balloon_eval') && syntastic#util#var('enable_balloons')
calling function <SNR>71_BufEnterHook..296..233..232..syntastic#util#var('enable_balloons')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>71_BufEnterHook..296..233..232..syntastic#util#var returning #1

continuing in function <SNR>71_BufEnterHook..296..233..232

function <SNR>71_BufEnterHook..296..233..232 returning #1

continuing in function <SNR>71_BufEnterHook..296..233

calling function <SNR>71_BufEnterHook..296..233..264()

line 1:     return empty(self._rawLoclist)
function <SNR>71_BufEnterHook..296..233..264 returning #1

continuing in function <SNR>71_BufEnterHook..296..233

line 3:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'balloons: refresh')
line 4:         let buf = bufnr('')
line 5:         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
line 6:         if !empty(issues)
line 7:             for i in issues
line 8:                 if has_key(b:syntastic_balloons, i['lnum'])
line 9:                     let b:syntastic_balloons[i['lnum']] .= "\n" . i['text']
line 10:                 else
line 11:                     let b:syntastic_balloons[i['lnum']] = i['text']
line 12:                 endif
line 13:             endfor
line 14:             set beval bexpr=SyntasticBalloonsExprNotifier()
line 15:         endif
line 16:     endif
function <SNR>71_BufEnterHook..296..233 returning #0

continuing in function <SNR>71_BufEnterHook..296

line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
calling function <SNR>71_BufEnterHook..296..syntastic#util#stamp()

line 1:     return reltime(g:syntastic_start)
function <SNR>71_BufEnterHook..296..syntastic#util#stamp returning [0, 69311]

continuing in function <SNR>71_BufEnterHook..296

line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>71_BufEnterHook..296..255()

line 1:     return s:has_highlighting && syntastic#util#var('enable_highlighting')
calling function <SNR>71_BufEnterHook..296..255..syntastic#util#var('enable_highlighting')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>71_BufEnterHook..296..255..syntastic#util#var returning #1

continuing in function <SNR>71_BufEnterHook..296..255

function <SNR>71_BufEnterHook..296..255 returning #1

continuing in function <SNR>71_BufEnterHook..296

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
calling function <SNR>71_BufEnterHook..296..256({'_sorted': 0, 'decorate': function('...columns': 1, 'setName': function('273')})

line 1:     if self.enabled()
calling function <SNR>71_BufEnterHook..296..256..255()

line 1:     return s:has_highlighting && syntastic#util#var('enable_highlighting')
calling function <SNR>71_BufEnterHook..296..256..255..syntastic#util#var('enable_highlighting')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>71_BufEnterHook..296..256..255..syntastic#util#var returning #1

continuing in function <SNR>71_BufEnterHook..296..256..255

function <SNR>71_BufEnterHook..296..256..255 returning #1

continuing in function <SNR>71_BufEnterHook..296..256

line 2:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'highlighting: refresh')
calling function <SNR>71_BufEnterHook..296..256..syntastic#log#debug(4, 'highlighting: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>71_BufEnterHook..296..256..syntastic#log#debug..<SNR>72__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>71_BufEnterHook..296..256..syntastic#log#debug..<SNR>72__isDebugEnabled_smart returning #0

continuing in function <SNR>71_BufEnterHook..296..256..syntastic#log#debug

line 2:         return
function <SNR>71_BufEnterHook..296..256..syntastic#log#debug returning #0

continuing in function <SNR>71_BufEnterHook..296..256

line 3:         call self._reset()
calling function <SNR>71_BufEnterHook..296..256..259()

line 1:     for match in getmatches()
line 2:         if stridx(match['group'], 'Syntastic') == 0
line 3:             call matchdelete(match['id'])
line 4:         endif
line 5:     endfor
function <SNR>71_BufEnterHook..296..256..259 returning #0

continuing in function <SNR>71_BufEnterHook..296..256

line 4:         let buf = bufnr('')
line 5:         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
calling function <SNR>71_BufEnterHook..296..256..266()

line 1:     return copy(self._rawLoclist)
function <SNR>71_BufEnterHook..296..256..266 returning []

continuing in function <SNR>71_BufEnterHook..296..256

line 6:         for item in issues
line 7:             let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
line 8: 
line 9:             " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
line 10:             " used to override default highlighting.
line 11:             if has_key(item, 'hl')
line 12:                 call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
line 13:             elseif get(item, 'col', 0)
line 14:                 if get(item, 'vcol', 0)
line 15:                     let lastcol = virtcol([item['lnum'], '$'])
line 16:                     let coltype = 'v'
line 17:                 else
line 18:                     let lastcol = col([item['lnum'], '$'])
line 19:                     let coltype = 'c'
line 20:                 endif
line 21:                 let lcol = min([lastcol, item['col']])
line 22: 
line 23:                 call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
line 24:             endif
line 25:         endfor
line 26:     endif
function <SNR>71_BufEnterHook..296..256 returning #0

continuing in function <SNR>71_BufEnterHook..296

line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
calling function <SNR>71_BufEnterHook..296..251()

line 1:     return syntastic#util#var('echo_current_error')
calling function <SNR>71_BufEnterHook..296..251..syntastic#util#var('echo_current_error')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>71_BufEnterHook..296..251..syntastic#util#var returning #1

continuing in function <SNR>71_BufEnterHook..296..251

function <SNR>71_BufEnterHook..296..251 returning #1

continuing in function <SNR>71_BufEnterHook..296

line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
calling function <SNR>71_BufEnterHook..296..252({'_sorted': 0, 'decorate': function('...columns': 1, 'setName': function('273')})

line 1:     if self.enabled() && !a:loclist.isEmpty()
calling function <SNR>71_BufEnterHook..296..252..251()

line 1:     return syntastic#util#var('echo_current_error')
calling function <SNR>71_BufEnterHook..296..252..251..syntastic#util#var('echo_current_error')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>71_BufEnterHook..296..252..251..syntastic#util#var returning #1

continuing in function <SNR>71_BufEnterHook..296..252..251

function <SNR>71_BufEnterHook..296..252..251 returning #1

continuing in function <SNR>71_BufEnterHook..296..252

calling function <SNR>71_BufEnterHook..296..252..264()

line 1:     return empty(self._rawLoclist)
function <SNR>71_BufEnterHook..296..252..264 returning #1

continuing in function <SNR>71_BufEnterHook..296..252

line 2:         call syntastic#log#debug(g:SyntasticDebugNotifications, 'cursor: refresh')
line 3:         let b:syntastic_messages = copy(a:loclist.messages(bufnr('')))
line 4:         let b:syntastic_line = -1
line 5:         let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
line 6:         autocmd! syntastic CursorMoved
line 7:         autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
line 8:     endif
function <SNR>71_BufEnterHook..296..252 returning #0

continuing in function <SNR>71_BufEnterHook..296

line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
calling function <SNR>71_BufEnterHook..296..229({'_sorted': 0, 'decorate': function('...columns': 1, 'setName': function('273')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'autoloclist: refresh')
calling function <SNR>71_BufEnterHook..296..229..syntastic#log#debug(4, 'autoloclist: refresh')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>71_BufEnterHook..296..229..syntastic#log#debug..<SNR>72__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>71_BufEnterHook..296..229..syntastic#log#debug..<SNR>72__isDebugEnabled_smart returning #0

continuing in function <SNR>71_BufEnterHook..296..229..syntastic#log#debug

line 2:         return
function <SNR>71_BufEnterHook..296..229..syntastic#log#debug returning #0

continuing in function <SNR>71_BufEnterHook..296..229

line 2:     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)
calling function <SNR>71_BufEnterHook..296..229..230({'_sorted': 0, 'decorate': function('...columns': 1, 'setName': function('273')})

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'autoloclist: toggle')
calling function <SNR>71_BufEnterHook..296..229..230..syntastic#log#debug(4, 'autoloclist: toggle')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>71_BufEnterHook..296..229..230..syntastic#log#debug..<SNR>72__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>71_BufEnterHook..296..229..230..syntastic#log#debug..<SNR>72__isDebugEnabled_smart returning #0

continuing in function <SNR>71_BufEnterHook..296..229..230..syntastic#log#debug

line 2:         return
function <SNR>71_BufEnterHook..296..229..230..syntastic#log#debug returning #0

continuing in function <SNR>71_BufEnterHook..296..229..230

line 2:     if !a:loclist.isEmpty()
calling function <SNR>71_BufEnterHook..296..229..230..264()

line 1:     return empty(self._rawLoclist)
function <SNR>71_BufEnterHook..296..229..230..264 returning #1

continuing in function <SNR>71_BufEnterHook..296..229..230

line 3:         if syntastic#util#var('auto_loc_list') == 1
line 4:             call a:loclist.show()
line 5:         endif
line 6:     else
line 7:         if syntastic#util#var('auto_loc_list') > 0
calling function <SNR>71_BufEnterHook..296..229..230..syntastic#util#var('auto_loc_list')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>71_BufEnterHook..296..229..230..syntastic#util#var returning #0

continuing in function <SNR>71_BufEnterHook..296..229..230

line 8: 
line 9:             "TODO: this will close the loc list window if one was opened by
line 10:             "something other than syntastic
line 11:             lclose
line 12:         endif
line 13:     endif
function <SNR>71_BufEnterHook..296..229..230 returning #0

continuing in function <SNR>71_BufEnterHook..296..229

function <SNR>71_BufEnterHook..296..229 returning #0

continuing in function <SNR>71_BufEnterHook..296

line 21:             endif
line 22:         endif
line 23:     endfor
line 7:     for type in self._enabled_types
line 8:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 9:         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
line 10:             if index(s:persistent_notifiers, type) > -1
line 11:                 " refresh only if loclist has changed since last call
line 12:                 if !exists('b:syntastic_' . type . '_stamp')
line 13:                     let b:syntastic_{type}_stamp = []
line 14:                 endif
line 15:                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
line 16:                     call self._notifier[type].refresh(a:loclist)
line 17:                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
line 18:                 endif
line 19:             else
line 20:                 call self._notifier[type].refresh(a:loclist)
line 21:             endif
line 22:         endif
line 23:     endfor
function <SNR>71_BufEnterHook..296 returning #0

continuing in function <SNR>71_BufEnterHook

line 6:     elseif &buftype == 'quickfix'
line 7:         " TODO: this is needed because in recent versions of Vim lclose
line 8:         " can no longer be called from BufWinLeave
line 9:         " TODO: at this point there is no b:syntastic_loclist
line 10:         let loclist = filter(copy(getloclist(0)), 'v:val["valid"] == 1')
line 11:         let owner = str2nr(getbufvar(bufnr(""), 'syntastic_owner_buffer'))
line 12:         let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
line 13:         if !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
line 14:             call SyntasticLoclistHide()
line 15:         endif
line 16:     endif
function <SNR>71_BufEnterHook returning #0

continuing in BufEnter Auto commands for "*"

Executing BufEnter Auto commands for "*"
autocommand cal s:record(expand('<abuf>', 1))

line 0: cal s:record(expand('<abuf>', 1))
calling function <SNR>75_record('1')

line 1: ^Iif s:locked | retu | en
line 1:  retu | en
line 1:  en
line 2: ^Ilet bufnr = a:bufnr + 0
line 3: ^Ilet bufname = bufname(bufnr)
line 4: ^Iif bufnr > 0 && !empty(bufname)
line 5: ^I^Ical filter(s:mrbs, 'v:val != bufnr')
line 6: ^I^Ical insert(s:mrbs, bufnr)
line 7: ^I^Ical s:addtomrufs(bufname)
line 8: ^Ien
function <SNR>75_record returning #0

continuing in BufEnter Auto commands for "*"

Executing BufEnter Auto commands for "*"
autocommand sil! call s:LocalBrowse(expand("<amatch>"))

line 0: sil! call s:LocalBrowse(expand("<amatch>"))
calling function <SNR>80_LocalBrowse('')

line 1:   " unfortunate interaction -- debugging calls can't be used here;
line 2:   " the BufEnter event causes triggering when attempts to write to
line 3:   " the DBG buffer are made.
line 4:   if !exists("s:vimentered")
line 5:    return
function <SNR>80_LocalBrowse returning #0

continuing in BufEnter Auto commands for "*"

Executing VimEnter Auto commands for "*"
autocommand if expand('<amatch>')==''|call fugitive#detect(getcwd())|endif

line 0: if expand('<amatch>')==''|call fugitive#detect(getcwd())|endif
line 0: call fugitive#detect(getcwd())|endif
calling function fugitive#detect('/home/max/.vim/bundle')

line 1:   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
line 2:     unlet b:git_dir
line 3:   endif
line 4:   if !exists('b:git_dir')
line 5:     let dir = fugitive#extract_git_dir(a:path)
calling function fugitive#detect..fugitive#extract_git_dir('/home/max/.vim/bundle')

line 1:   if s:shellslash(a:path) =~# '^fugitive://.*//'
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>33_shellslash('/home/max/.vim/bundle')

line 1:   if s:winshell()
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>33_shellslash..<SNR>33_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function fugitive#detect..fugitive#extract_git_dir..<SNR>33_shellslash..<SNR>33_winshell returning #0

continuing in function fugitive#detect..fugitive#extract_git_dir..<SNR>33_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function fugitive#detect..fugitive#extract_git_dir..<SNR>33_shellslash returning '/home/max/.vim/bundle'

continuing in function fugitive#detect..fugitive#extract_git_dir

line 2:     return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
line 3:   endif
line 4:   let root = s:shellslash(simplify(fnamemodify(a:path, ':p:s?[\/]$??')))
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>33_shellslash('/home/max/.vim/bundle')

line 1:   if s:winshell()
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>33_shellslash..<SNR>33_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function fugitive#detect..fugitive#extract_git_dir..<SNR>33_shellslash..<SNR>33_winshell returning #0

continuing in function fugitive#detect..fugitive#extract_git_dir..<SNR>33_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function fugitive#detect..fugitive#extract_git_dir..<SNR>33_shellslash returning '/home/max/.vim/bundle'

continuing in function fugitive#detect..fugitive#extract_git_dir

line 5:   let previous = ""
line 6:   while root !=# previous
line 7:     if root =~# '\v^//%([^/]+/?)?$'
line 8:       " This is for accessing network shares from Cygwin Vim. There won't be
line 9:       " any git directory called //.git or //serverName/.git so let's avoid
line 10:       " checking for them since such checks are extremely slow.
line 11:       break
line 12:     endif
line 13:     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
line 14:       break
line 15:     endif
line 16:     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
line 17:       return $GIT_DIR
line 18:     endif
line 19:     let dir = s:sub(root, '[\/]$', '') . '/.git'
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>33_sub('/home/max/.vim/bundle', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect..fugitive#extract_git_dir..<SNR>33_sub returning '/home/max/.vim/bundle'

continuing in function fugitive#detect..fugitive#extract_git_dir

line 20:     let type = getftype(dir)
line 21:     if type ==# 'dir' && fugitive#is_git_dir(dir)
line 22:       return dir
line 23:     elseif type ==# 'link' && fugitive#is_git_dir(dir)
line 24:       return resolve(dir)
line 25:     elseif type !=# '' && filereadable(dir)
line 26:       let line = get(readfile(dir, '', 1), 0, '')
line 27:       if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
line 28:         return simplify(root.'/'.line[8:-1])
line 29:       elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
line 30:         return line[8:-1]
line 31:       endif
line 32:     elseif fugitive#is_git_dir(root)
calling function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir('/home/max/.vim/bundle')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir..<SNR>33_sub('/home/max/.vim/bundle', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir..<SNR>33_sub returning '/home/max/.vim/bundle'

continuing in function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir returning #0

continuing in function fugitive#detect..fugitive#extract_git_dir

line 33:       return root
line 34:     endif
line 35:     let previous = root
line 36:     let root = fnamemodify(root, ':h')
line 37:   endwhile
line 6:   while root !=# previous
line 7:     if root =~# '\v^//%([^/]+/?)?$'
line 8:       " This is for accessing network shares from Cygwin Vim. There won't be
line 9:       " any git directory called //.git or //serverName/.git so let's avoid
line 10:       " checking for them since such checks are extremely slow.
line 11:       break
line 12:     endif
line 13:     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
line 14:       break
line 15:     endif
line 16:     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
line 17:       return $GIT_DIR
line 18:     endif
line 19:     let dir = s:sub(root, '[\/]$', '') . '/.git'
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>33_sub('/home/max/.vim', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect..fugitive#extract_git_dir..<SNR>33_sub returning '/home/max/.vim'

continuing in function fugitive#detect..fugitive#extract_git_dir

line 20:     let type = getftype(dir)
line 21:     if type ==# 'dir' && fugitive#is_git_dir(dir)
line 22:       return dir
line 23:     elseif type ==# 'link' && fugitive#is_git_dir(dir)
line 24:       return resolve(dir)
line 25:     elseif type !=# '' && filereadable(dir)
line 26:       let line = get(readfile(dir, '', 1), 0, '')
line 27:       if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
line 28:         return simplify(root.'/'.line[8:-1])
line 29:       elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
line 30:         return line[8:-1]
line 31:       endif
line 32:     elseif fugitive#is_git_dir(root)
calling function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir('/home/max/.vim')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir..<SNR>33_sub('/home/max/.vim', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir..<SNR>33_sub returning '/home/max/.vim'

continuing in function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir returning #0

continuing in function fugitive#detect..fugitive#extract_git_dir

line 33:       return root
line 34:     endif
line 35:     let previous = root
line 36:     let root = fnamemodify(root, ':h')
line 37:   endwhile
line 6:   while root !=# previous
line 7:     if root =~# '\v^//%([^/]+/?)?$'
line 8:       " This is for accessing network shares from Cygwin Vim. There won't be
line 9:       " any git directory called //.git or //serverName/.git so let's avoid
line 10:       " checking for them since such checks are extremely slow.
line 11:       break
line 12:     endif
line 13:     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
line 14:       break
line 15:     endif
line 16:     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
line 17:       return $GIT_DIR
line 18:     endif
line 19:     let dir = s:sub(root, '[\/]$', '') . '/.git'
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>33_sub('/home/max', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect..fugitive#extract_git_dir..<SNR>33_sub returning '/home/max'

continuing in function fugitive#detect..fugitive#extract_git_dir

line 20:     let type = getftype(dir)
line 21:     if type ==# 'dir' && fugitive#is_git_dir(dir)
line 22:       return dir
line 23:     elseif type ==# 'link' && fugitive#is_git_dir(dir)
line 24:       return resolve(dir)
line 25:     elseif type !=# '' && filereadable(dir)
line 26:       let line = get(readfile(dir, '', 1), 0, '')
line 27:       if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
line 28:         return simplify(root.'/'.line[8:-1])
line 29:       elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
line 30:         return line[8:-1]
line 31:       endif
line 32:     elseif fugitive#is_git_dir(root)
calling function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir('/home/max')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir..<SNR>33_sub('/home/max', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir..<SNR>33_sub returning '/home/max'

continuing in function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir returning #0

continuing in function fugitive#detect..fugitive#extract_git_dir

line 33:       return root
line 34:     endif
line 35:     let previous = root
line 36:     let root = fnamemodify(root, ':h')
line 37:   endwhile
line 6:   while root !=# previous
line 7:     if root =~# '\v^//%([^/]+/?)?$'
line 8:       " This is for accessing network shares from Cygwin Vim. There won't be
line 9:       " any git directory called //.git or //serverName/.git so let's avoid
line 10:       " checking for them since such checks are extremely slow.
line 11:       break
line 12:     endif
line 13:     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
line 14:       break
line 15:     endif
line 16:     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
line 17:       return $GIT_DIR
line 18:     endif
line 19:     let dir = s:sub(root, '[\/]$', '') . '/.git'
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>33_sub('/home', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect..fugitive#extract_git_dir..<SNR>33_sub returning '/home'

continuing in function fugitive#detect..fugitive#extract_git_dir

line 20:     let type = getftype(dir)
line 21:     if type ==# 'dir' && fugitive#is_git_dir(dir)
line 22:       return dir
line 23:     elseif type ==# 'link' && fugitive#is_git_dir(dir)
line 24:       return resolve(dir)
line 25:     elseif type !=# '' && filereadable(dir)
line 26:       let line = get(readfile(dir, '', 1), 0, '')
line 27:       if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
line 28:         return simplify(root.'/'.line[8:-1])
line 29:       elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
line 30:         return line[8:-1]
line 31:       endif
line 32:     elseif fugitive#is_git_dir(root)
calling function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir('/home')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir..<SNR>33_sub('/home', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir..<SNR>33_sub returning '/home'

continuing in function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir returning #0

continuing in function fugitive#detect..fugitive#extract_git_dir

line 33:       return root
line 34:     endif
line 35:     let previous = root
line 36:     let root = fnamemodify(root, ':h')
line 37:   endwhile
line 6:   while root !=# previous
line 7:     if root =~# '\v^//%([^/]+/?)?$'
line 8:       " This is for accessing network shares from Cygwin Vim. There won't be
line 9:       " any git directory called //.git or //serverName/.git so let's avoid
line 10:       " checking for them since such checks are extremely slow.
line 11:       break
line 12:     endif
line 13:     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
line 14:       break
line 15:     endif
line 16:     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
line 17:       return $GIT_DIR
line 18:     endif
line 19:     let dir = s:sub(root, '[\/]$', '') . '/.git'
calling function fugitive#detect..fugitive#extract_git_dir..<SNR>33_sub('/', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect..fugitive#extract_git_dir..<SNR>33_sub returning ''

continuing in function fugitive#detect..fugitive#extract_git_dir

line 20:     let type = getftype(dir)
line 21:     if type ==# 'dir' && fugitive#is_git_dir(dir)
line 22:       return dir
line 23:     elseif type ==# 'link' && fugitive#is_git_dir(dir)
line 24:       return resolve(dir)
line 25:     elseif type !=# '' && filereadable(dir)
line 26:       let line = get(readfile(dir, '', 1), 0, '')
line 27:       if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
line 28:         return simplify(root.'/'.line[8:-1])
line 29:       elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
line 30:         return line[8:-1]
line 31:       endif
line 32:     elseif fugitive#is_git_dir(root)
calling function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir('/')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir..<SNR>33_sub('/', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir..<SNR>33_sub returning ''

continuing in function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect..fugitive#extract_git_dir..fugitive#is_git_dir returning #0

continuing in function fugitive#detect..fugitive#extract_git_dir

line 33:       return root
line 34:     endif
line 35:     let previous = root
line 36:     let root = fnamemodify(root, ':h')
line 37:   endwhile
line 6:   while root !=# previous
line 7:     if root =~# '\v^//%([^/]+/?)?$'
line 8:       " This is for accessing network shares from Cygwin Vim. There won't be
line 9:       " any git directory called //.git or //serverName/.git so let's avoid
line 10:       " checking for them since such checks are extremely slow.
line 11:       break
line 12:     endif
line 13:     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
line 14:       break
line 15:     endif
line 16:     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
line 17:       return $GIT_DIR
line 18:     endif
line 19:     let dir = s:sub(root, '[\/]$', '') . '/.git'
line 20:     let type = getftype(dir)
line 21:     if type ==# 'dir' && fugitive#is_git_dir(dir)
line 22:       return dir
line 23:     elseif type ==# 'link' && fugitive#is_git_dir(dir)
line 24:       return resolve(dir)
line 25:     elseif type !=# '' && filereadable(dir)
line 26:       let line = get(readfile(dir, '', 1), 0, '')
line 27:       if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
line 28:         return simplify(root.'/'.line[8:-1])
line 29:       elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
line 30:         return line[8:-1]
line 31:       endif
line 32:     elseif fugitive#is_git_dir(root)
line 33:       return root
line 34:     endif
line 35:     let previous = root
line 36:     let root = fnamemodify(root, ':h')
line 37:   endwhile
line 38:   return ''
function fugitive#detect..fugitive#extract_git_dir returning ''

continuing in function fugitive#detect

line 6:     if dir !=# ''
line 7:       let b:git_dir = dir
line 8:     endif
line 9:   endif
line 10:   if exists('b:git_dir')
line 11:     silent doautocmd User FugitiveBoot
line 12:     cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
line 13:     nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
line 14:     let buffer = fugitive#buffer()
line 15:     if expand('%:p') =~# '//'
line 16:       call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
line 17:     endif
line 18:     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
line 19:       if filereadable(b:git_dir.'/tags')
line 20:         call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
line 21:       endif
line 22:       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
line 23:         call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
line 24:       endif
line 25:     endif
line 26:     silent doautocmd User Fugitive
line 27:   endif
function fugitive#detect returning #0

continuing in VimEnter Auto commands for "*"

line 0: endif
Executing VimEnter Auto commands for "*"
autocommand if empty(expand("<amatch>")) && RailsDetect(getcwd()) |   call rails#buffer_setup() |   silent doau User BufEnterRails | endif

line 0: if empty(expand("<amatch>")) && RailsDetect(getcwd()) |   call rails#buffer_setup() |   silent doau User BufEnterRails | endif
calling function RailsDetect('/home/max/.vim/bundle')

line 1:   if exists('b:rails_root')
line 2:     return 1
line 3:   endif
line 4:   let fn = fnamemodify(a:0 ? a:1 : expand('%'), ':p')
line 5:   if !isdirectory(fn)
line 6:     let fn = fnamemodify(fn, ':h')
line 7:   endif
line 8:   let file = findfile('config/environment.rb', escape(fn, ', ').';')
line 9:   if !empty(file)
line 10:     let b:rails_root = fnamemodify(file, ':p:h:h')
line 11:     return 1
line 12:   endif
function RailsDetect returning #0

continuing in VimEnter Auto commands for "*"

line 0:    call rails#buffer_setup() |   silent doau User BufEnterRails | endif
Searching for "autoload/rails.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/FuzzyFind
Searching for "/home/max/.vim/autoload/rails.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/rails.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/rails.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/rails.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/rails.vim"
chdir(/home/max/.vim/bundle/vim-rails/autoload)
fchdir() to previous dir
line 0: sourcing "/home/max/.vim/bundle/vim-rails/autoload/rails.vim"
line 1: " autoload/rails.vim
line 2: " Author:       Tim Pope <http://tpo.pe/>
line 3: 
line 4: " Install this file as autoload/rails.vim.
line 5: 
line 6: if exists('g:autoloaded_rails') || &cp
line 7:   finish
line 8: endif
line 9: let g:autoloaded_rails = '5.1'
line 10: 
line 11: " Utility Functions {{{1
line 12: 
line 13: let s:app_prototype = {}
line 14: let s:file_prototype = {}
line 15: let s:buffer_prototype = {}
line 16: let s:readable_prototype = {}
line 17: 
line 18: function! s:add_methods(namespace, method_names)
line 23: 
line 24: function! s:function(name)
line 27: 
line 28: function! s:sub(str,pat,rep)
line 31: 
line 32: function! s:gsub(str,pat,rep)
line 35: 
line 36: function! s:startswith(string,prefix)
line 39: 
line 40: function! s:endswith(string,suffix)
line 43: 
line 44: function! s:uniq(list) abort
line 60: 
line 61: function! s:getlist(arg, key)
line 65: 
line 66: function! s:split(arg, ...)
line 69: 
line 70: function! rails#lencmp(i1, i2) abort
line 73: 
line 74: function! s:escarg(p)
line 77: 
line 78: function! s:esccmd(p)
line 81: 
line 82: function! s:rquote(str)
line 91: 
line 92: function! s:fnameescape(file) abort
line 99: 
line 100: function! s:sname()
line 103: 
line 104: function! s:pop_command()
line 109: 
line 110: function! s:push_chdir(...)
line 120: 
line 121: function! s:app_path(...) dict
line 124: 
line 125: function! s:app_has_path(path) dict
line 128: 
line 129: function! s:app_has_file(file) dict
line 132: 
line 133: function! s:app_find_file(name, ...) dict abort
line 168: 
line 169: call s:add_methods('app',['path','has_path','has_file','find_file'])
calling function <SNR>87_add_methods('app', ['path', 'has_path', 'has_file', 'find_file'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_path')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_path')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_has_path')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_has_path')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_has_file')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_has_file')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_find_file')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_find_file')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 170: 
line 171: " Split a path into a list.
line 172: function! s:pathsplit(path) abort
line 176: 
line 177: " Convert a list to a path.
line 178: function! s:pathjoin(...) abort
line 191: 
line 192: function! s:readable_end_of(lnum) dict abort
line 218: 
line 219: function! s:endof(lnum)
line 222: 
line 223: function! s:readable_last_opening_line(start,pattern,limit) dict abort
line 239: 
line 240: function! s:lastopeningline(pattern,limit,start)
line 243: 
line 244: function! s:readable_define_pattern() dict abort
line 260: 
line 261: function! s:readable_last_method_line(start) dict abort
line 264: 
line 265: function! s:lastmethodline(start)
line 268: 
line 269: function! s:readable_last_method(start) dict abort
line 281: 
line 282: function! s:lastmethod(...)
line 285: 
line 286: function! s:readable_format(start) dict abort
line 313: 
line 314: function! s:format()
line 317: 
line 318: call s:add_methods('readable',['end_of','last_opening_line','last_method_line','last_method','format','define_pattern'])
calling function <SNR>87_add_methods('readable', ['end_of', 'last_opening_line', 'last...ast_method', 'format', 'define_pattern'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_end_of')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_end_of')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_last_opening_line')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_last_opening_line')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_last_method_line')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_last_method_line')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_last_method')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_last_method')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_format')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_format')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_define_pattern')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_define_pattern')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 319: 
line 320: function! s:readable_find_affinity() dict abort
line 335: 
line 336: function! s:controller(...)
line 339: 
line 340: function! s:readable_controller_name(...) dict abort
line 384: 
line 385: function! s:model(...)
line 388: 
line 389: function! s:readable_model_name(...) dict abort
line 425: 
line 426: call s:add_methods('readable', ['find_affinity', 'controller_name', 'model_name'])
calling function <SNR>87_add_methods('readable', ['find_affinity', 'controller_name', 'model_name'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_find_affinity')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_find_affinity')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_controller_name')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_controller_name')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_model_name')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_model_name')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 427: 
line 428: function! s:readfile(path,...)
line 443: 
line 444: function! s:file_lines() dict abort
line 452: 
line 453: function! s:file_getline(lnum,...) dict abort
line 460: 
line 461: function! s:buffer_lines() dict abort
line 464: 
line 465: function! s:buffer_getline(...) dict abort
line 472: 
line 473: function! s:readable_line_count() dict abort
line 476: 
line 477: function! s:environment()
line 486: 
line 487: function! s:Complete_environments(...)
line 490: 
line 491: function! s:warn(str)
line 499: 
line 500: function! s:error(str)
line 506: 
line 507: function! s:debug(str)
line 514: 
line 515: function! s:buffer_getvar(varname) dict abort
line 518: 
line 519: function! s:buffer_setvar(varname, val) dict abort
line 522: 
line 523: call s:add_methods('buffer',['getvar','setvar'])
calling function <SNR>87_add_methods('buffer', ['getvar', 'setvar'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:buffer_getvar')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_buffer_getvar')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:buffer_setvar')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_buffer_setvar')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 524: 
line 525: " }}}1
line 526: " Public Interface {{{1
line 527: 
line 528: function! rails#underscore(str)
line 535: 
line 536: function! rails#camelize(str)
line 541: 
line 542: function! rails#singularize(word)
line 559: 
line 560: function! rails#pluralize(word)
line 573: 
line 574: function! rails#app(...)
line 586: 
line 587: function! rails#buffer(...)
line 591: 
line 592: function! s:buffer_app() dict abort
line 599: 
line 600: function! s:readable_app() dict abort
line 603: 
line 604: function! RailsRevision()
line 607: 
line 608: function! RailsRoot()
line 615: 
line 616: function! s:app_file(name) dict abort
line 619: 
line 620: function! s:readable_relative() dict abort
line 623: 
line 624: function! s:readable_absolute() dict abort
line 627: 
line 628: function! s:readable_spec() dict abort
line 631: 
line 632: function! s:file_path() dict abort
line 635: 
line 636: function! s:file_name() dict abort
line 639: 
line 640: function! s:buffer_number() dict abort
line 643: 
line 644: function! s:buffer_path() dict abort
line 647: 
line 648: function! s:buffer_name() dict abort
line 666: 
line 667: function! RailsFilePath()
line 674: 
line 675: function! RailsFile()
line 678: 
line 679: function! RailsFileType()
line 686: 
line 687: function! s:readable_calculate_file_type() dict abort
line 801: 
line 802: function! s:buffer_type_name(...) dict abort
line 809: 
line 810: function! s:readable_type_name(...) dict abort
line 814: 
line 815: function! s:match_type(type,...)
line 822: 
line 823: function! s:app_environments() dict
line 829: 
line 830: function! s:app_default_locale() dict abort
line 840: 
line 841: function! s:app_stylesheet_suffix() dict abort
line 852: 
line 853: function! s:app_has(feature) dict
line 873: 
line 874: " Returns the subset of ['test', 'spec'] present on the app.
line 875: function! s:app_test_suites() dict
line 878: 
line 879: call s:add_methods('app',['default_locale','environments','file','has','stylesheet_suffix','test_suites'])
calling function <SNR>87_add_methods('app', ['default_locale', 'environments', 'f...as', 'stylesheet_suffix', 'test_suites'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_default_locale')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_default_locale')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_environments')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_environments')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_file')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_file')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_has')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_has')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_stylesheet_suffix')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_stylesheet_suffix')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_test_suites')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_test_suites')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 880: call s:add_methods('file',['path','name','lines','getline'])
calling function <SNR>87_add_methods('file', ['path', 'name', 'lines', 'getline'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:file_path')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_file_path')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:file_name')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_file_name')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:file_lines')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_file_lines')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:file_getline')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_file_getline')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 881: call s:add_methods('buffer',['app','number','path','name','lines','getline','type_name'])
calling function <SNR>87_add_methods('buffer', ['app', 'number', 'path', 'name', 'lines', 'getline', 'type_name'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:buffer_app')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_buffer_app')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:buffer_number')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_buffer_number')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:buffer_path')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_buffer_path')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:buffer_name')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_buffer_name')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:buffer_lines')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_buffer_lines')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:buffer_getline')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_buffer_getline')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:buffer_type_name')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_buffer_type_name')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 882: call s:add_methods('readable',['app','relative','absolute','spec','calculate_file_type','type_name','line_count'])
calling function <SNR>87_add_methods('readable', ['app', 'relative', 'absolute', 'spec...e_file_type', 'type_name', 'line_count'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_app')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_app')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_relative')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_relative')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_absolute')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_absolute')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_spec')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_spec')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_calculate_file_type')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_calculate_file_type')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_type_name')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_type_name')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_line_count')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_line_count')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 883: 
line 884: " }}}1
line 885: " Ruby Execution {{{1
line 886: 
line 887: function! s:app_ruby_command(cmd) dict abort
line 890: 
line 891: function! s:app_ruby_script_command(cmd) dict abort
line 898: 
line 899: function! s:app_prepare_rails_command(cmd) dict abort
line 915: 
line 916: function! s:app_start_rails_command(cmd, ...) dict abort
line 941: 
line 942: function! s:app_execute_rails_command(cmd) dict abort
line 951: 
line 952: function! s:app_lightweight_ruby_eval(ruby,...) dict abort
line 962: 
line 963: function! s:app_eval(ruby,...) dict abort
line 978: 
line 979: call s:add_methods('app', ['ruby_command','ruby_script_command','prepare_rails_command','execute_rails_command','start_rails_command','lightweight_ruby_eval','eval'])
calling function <SNR>87_add_methods('app', ['ruby_command', 'ruby_script_command...mmand', 'lightweight_ruby_eval', 'eval'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_ruby_command')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_ruby_command')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_ruby_script_command')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_ruby_script_command')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_prepare_rails_command')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_prepare_rails_command')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_execute_rails_command')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_execute_rails_command')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_start_rails_command')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_start_rails_command')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_lightweight_ruby_eval')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_lightweight_ruby_eval')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_eval')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_eval')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 980: 
line 981: " }}}1
line 982: " Commands {{{1
line 983: 
line 984: function! s:BufCommands()
line 1017: 
line 1018: function! s:Log(bang,arg)
line 1031: 
line 1032: function! rails#new_app_command(bang,...) abort
line 1075: 
line 1076: function! s:app_tags_command() dict abort
line 1108: 
line 1109: call s:add_methods('app',['tags_command'])
calling function <SNR>87_add_methods('app', ['tags_command'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_tags_command')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_tags_command')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 1110: 
line 1111: function! s:Refresh(bang)
line 1140: 
line 1141: function! s:RefreshBuffer()
line 1148: 
line 1149: " }}}1
line 1150: " Rake {{{1
line 1151: 
line 1152: function! s:app_rake_tasks() dict abort
line 1170: 
line 1171: call s:add_methods('app', ['rake_tasks'])
calling function <SNR>87_add_methods('app', ['rake_tasks'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_rake_tasks')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_rake_tasks')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 1172: 
line 1182: let g:rails#rake_errorformat = '%D(in\ %f),'.'%\\s%#from\ %f:%l:%m,'.'%\\s%#from\ %f:%l:,'.'%\\s#{RAILS_ROOT}/%f:%l:\ %#%m,'.'%\\s%##\ %f:%l:%m,'.'%\\s%##\ %f:%l,'.'%\\s%#[%f:%l:\ %#%m,'.'%\\s%#%f:%l:\ %#%m,'.'%\\s%#%f:%l:,'.'%m\ [%f:%l]:'
line 1183: 
line 1184: function! s:make(bang, args, ...)
line 1194: 
line 1195: function! s:Rake(bang,lnum,arg)
line 1245: 
line 1246: function! s:readable_test_file_candidates() dict abort
line 1302: 
line 1303: function! s:readable_test_file() dict abort
line 1312: 
line 1313: function! s:readable_default_rake_task(...) dict abort
line 1421: 
line 1422: function! s:app_rake_command(...) dict abort
line 1433: 
line 1434: function! rails#complete_rake(A,L,P)
line 1437: 
line 1438: call s:add_methods('readable', ['test_file_candidates', 'test_file', 'default_rake_task'])
calling function <SNR>87_add_methods('readable', ['test_file_candidates', 'test_file', 'default_rake_task'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_test_file_candidates')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_test_file_candidates')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_test_file')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_test_file')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_default_rake_task')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_default_rake_task')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 1439: call s:add_methods('app', ['rake_command'])
calling function <SNR>87_add_methods('app', ['rake_command'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_rake_command')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_rake_command')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 1440: 
line 1441: " }}}1
line 1442: " Preview {{{1
line 1443: 
line 1444: function! s:initOpenURL()
line 1463: 
line 1464: function! s:scanlineforuris(line)
line 1479: 
line 1480: function! s:readable_preview_urls(lnum) dict abort
line 1527: 
line 1528: call s:add_methods('readable', ['preview_urls'])
calling function <SNR>87_add_methods('readable', ['preview_urls'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_preview_urls')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_preview_urls')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 1529: 
line 1530: function! s:app_server_binding() dict abort
line 1555: 
line 1556: call s:add_methods('app', ['server_binding'])
calling function <SNR>87_add_methods('app', ['server_binding'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_server_binding')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_server_binding')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 1557: 
line 1558: function! s:Preview(bang, lnum, uri) abort
line 1602: 
line 1603: function! s:Complete_preview(A,L,P)
line 1606: 
line 1607: " }}}1
line 1608: " Script Wrappers {{{1
line 1609: 
line 1610: function! s:BufScriptWrappers()
line 1625: 
line 1626: function! s:app_generators() dict abort
line 1647: 
line 1648: function! s:app_script_command(bang,...) dict
line 1664: 
line 1665: function! s:readable_runner_command(bang, count, arg) dict abort
line 1742: 
line 1743: call s:add_methods('readable', ['runner_command'])
calling function <SNR>87_add_methods('readable', ['runner_command'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_runner_command')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_runner_command')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 1744: 
line 1745: function! s:app_output_command(count, code) dict
line 1760: 
line 1761: function! rails#get_binding_for(pid)
line 1786: 
line 1787: function! s:app_server_command(bang,arg) dict
line 1815: 
line 1816: function! s:color_efm(pre, before, after)
line 1820: 
line 1830: let s:efm_generate = s:color_efm('%-G', 'invoke', '%f') . s:color_efm('%-G', 'conflict', '%f') . s:color_efm('%-G', 'run', '%f') . s:color_efm('%-G', 'create', ' ') . s:color_efm('%-G', 'exist', ' ') . s:color_efm('Overwrite%.%#', '%m', '%f') . s:color_efm('', '%m', ' %f') . s:color_efm('', '%m', '%f') . '%-G%.%#'
calling function <SNR>87_color_efm('%-G', 'invoke', '%f')

line 1:    return a:pre . '%\S%\+  %#' . a:before . "\e[0m  %#" . a:after . ',' . a:pre . '%\s %#'.a:before.'  %#'.a:after . ','
function <SNR>87_color_efm returning '%-G%\S%\+  %#invoke^[[0m  %#%f,%-G%\s %#invoke  %#%f,'

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

calling function <SNR>87_color_efm('%-G', 'conflict', '%f')

line 1:    return a:pre . '%\S%\+  %#' . a:before . "\e[0m  %#" . a:after . ',' . a:pre . '%\s %#'.a:before.'  %#'.a:after . ','
function <SNR>87_color_efm returning '%-G%\S%\+  %#conflict^[[0m  %#%f,%-G%\s %#conflict  %#%f,'

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

calling function <SNR>87_color_efm('%-G', 'run', '%f')

line 1:    return a:pre . '%\S%\+  %#' . a:before . "\e[0m  %#" . a:after . ',' . a:pre . '%\s %#'.a:before.'  %#'.a:after . ','
function <SNR>87_color_efm returning '%-G%\S%\+  %#run^[[0m  %#%f,%-G%\s %#run  %#%f,'

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

calling function <SNR>87_color_efm('%-G', 'create', ' ')

line 1:    return a:pre . '%\S%\+  %#' . a:before . "\e[0m  %#" . a:after . ',' . a:pre . '%\s %#'.a:before.'  %#'.a:after . ','
function <SNR>87_color_efm returning '%-G%\S%\+  %#create^[[0m  %# ,%-G%\s %#create  %# ,'

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

calling function <SNR>87_color_efm('%-G', 'exist', ' ')

line 1:    return a:pre . '%\S%\+  %#' . a:before . "\e[0m  %#" . a:after . ',' . a:pre . '%\s %#'.a:before.'  %#'.a:after . ','
function <SNR>87_color_efm returning '%-G%\S%\+  %#exist^[[0m  %# ,%-G%\s %#exist  %# ,'

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

calling function <SNR>87_color_efm('Overwrite%.%#', '%m', '%f')

line 1:    return a:pre . '%\S%\+  %#' . a:before . "\e[0m  %#" . a:after . ',' . a:pre . '%\s %#'.a:before.'  %#'.a:after . ','
function <SNR>87_color_efm returning 'Overwrite%.%#%\S%\+  %#%m^[[0m  %#%f,Overwrite%.%#%\s %#%m  %#%f,'

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

calling function <SNR>87_color_efm('', '%m', ' %f')

line 1:    return a:pre . '%\S%\+  %#' . a:before . "\e[0m  %#" . a:after . ',' . a:pre . '%\s %#'.a:before.'  %#'.a:after . ','
function <SNR>87_color_efm returning '%\S%\+  %#%m^[[0m  %# %f,%\s %#%m  %# %f,'

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

calling function <SNR>87_color_efm('', '%m', '%f')

line 1:    return a:pre . '%\S%\+  %#' . a:before . "\e[0m  %#" . a:after . ',' . a:pre . '%\s %#'.a:before.'  %#'.a:after . ','
function <SNR>87_color_efm returning '%\S%\+  %#%m^[[0m  %#%f,%\s %#%m  %#%f,'

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 1831: 
line 1832: function! s:app_generator_command(bang,...) dict
line 1854: 
line 1855: call s:add_methods('app', ['generators','script_command','output_command','server_command','generator_command'])
calling function <SNR>87_add_methods('app', ['generators', 'script_command', 'out..., 'server_command', 'generator_command'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_generators')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_generators')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_script_command')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_script_command')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_output_command')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_output_command')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_server_command')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_server_command')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_generator_command')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_generator_command')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 1856: 
line 1857: function! s:Complete_script(ArgLead,CmdLine,P)
line 1905: 
line 1906: function! s:CustomComplete(A,L,P,cmd)
line 1911: 
line 1912: function! s:Complete_server(A,L,P)
line 1915: 
line 1916: function! s:Complete_console(A,L,P)
line 1919: 
line 1920: function! s:Complete_generate(A,L,P)
line 1923: 
line 1924: function! s:Complete_destroy(A,L,P)
line 1927: 
line 1928: function! s:Complete_ruby(A,L,P)
line 1931: 
line 1932: " }}}1
line 1933: " Navigation {{{1
line 1934: 
line 1935: function! s:BufNavCommands()
line 1954: 
line 1955: function! s:djump(def)
line 1997: 
line 1998: function! s:Find(count,cmd,...)
line 2020: 
line 2021: function! s:Edit(count,cmd,...)
line 2035: 
line 2036: function! s:fuzzyglob(arg)
line 2039: 
line 2040: function! s:Complete_find(ArgLead, CmdLine, CursorPos)
line 2053: 
line 2054: function! s:Complete_edit(ArgLead, CmdLine, CursorPos)
line 2057: 
line 2058: function! s:Complete_cd(ArgLead, CmdLine, CursorPos)
line 2063: 
line 2064: function! RailsIncludeexpr()
line 2072: 
line 2073: function! s:linepeak()
line 2079: 
line 2080: function! s:matchcursor(pat)
line 2093: 
line 2094: function! s:findit(pat,repl)
line 2102: 
line 2103: function! s:findamethod(func,repl)
line 2106: 
line 2107: function! s:findasymbol(sym,repl)
line 2110: 
line 2111: function! s:findfromview(func,repl)
line 2115: 
line 2116: function! s:RailsFind()
line 2247: 
line 2248: function! s:app_named_route_file(route) dict abort
line 2255: 
line 2256: function! s:app_route_names() dict abort
line 2271: 
line 2272: call s:add_methods('app', ['route_names','named_route_file'])
calling function <SNR>87_add_methods('app', ['route_names', 'named_route_file'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_route_names')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_route_names')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_named_route_file')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_named_route_file')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 2273: 
line 2274: function! s:RailsIncludefind(str,...)
line 2372: 
line 2373: " }}}1
line 2374: " Projection Commands {{{1
line 2375: 
line 2376: function! s:app_commands() dict abort
line 2454: 
line 2455: call s:add_methods('app', ['commands'])
calling function <SNR>87_add_methods('app', ['commands'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_commands')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_commands')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 2456: 
line 2457: function! s:addfilecmds(type)
line 2464: 
line 2465: function! s:BufProjectionCommands()
line 2482: 
line 2483: function! s:completion_filter(results, A, ...) abort
line 2505: 
line 2506: function! s:autocamelize(files,test)
line 2513: 
line 2514: function! s:app_relglob(path,glob,...) dict
line 2537: 
line 2538: call s:add_methods('app', ['relglob'])
calling function <SNR>87_add_methods('app', ['relglob'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_relglob')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_relglob')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 2539: 
line 2540: function! s:relglob(...)
line 2543: 
line 2544: function! s:controllerList(A,L,P)
line 2549: 
line 2550: function! s:viewList(A,L,P)
line 2560: 
line 2561: function! s:layoutList(A,L,P)
line 2564: 
line 2565: function! s:stylesheetList(A,L,P)
line 2575: 
line 2576: function! s:javascriptList(A,L,P)
line 2582: 
line 2583: function! s:fixturesList(A,L,P)
line 2591: 
line 2592: function! s:localeList(A,L,P)
line 2595: 
line 2596: function! s:migrationList(A,L,P)
line 2606: 
line 2607: function! s:schemaList(A,L,P)
line 2614: 
line 2615: function! s:specList(A,L,P)
line 2618: 
line 2619: function! s:Navcommand(bang,...)
line 2635: 
line 2636: function! s:define_navcommand(name, projection, ...) abort
line 2654: 
line 2655: function! s:CommandList(A,L,P)
line 2673: 
line 2674: function! s:CommandEdit(cmd, name, projections, ...)
line 2682: 
line 2683: function! s:LegacyCommandEdit(cmd, target, prefix, suffix)
line 2701: 
line 2702: function! s:app_migration(file) dict
line 2739: 
line 2740: call s:add_methods('app', ['migration'])
calling function <SNR>87_add_methods('app', ['migration'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_migration')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_migration')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 2741: 
line 2742: function! s:migrationEdit(cmd,...)
line 2764: 
line 2765: function! s:schemaEdit(cmd,...)
line 2777: 
line 2778: function! s:fixturesEdit(cmd,...)
line 2798: 
line 2799: function! s:localeEdit(cmd,...)
line 2808: 
line 2809: function! s:dotcmp(i1, i2)
line 2812: 
line 2813: let s:view_types = split('rhtml,erb,rxml,builder,rjs,haml',',')
line 2814: 
line 2815: function! s:readable_resolve_view(name, ...) dict abort
line 2844: 
line 2845: function! s:readable_resolve_layout(name, ...) dict abort
line 2857: 
line 2858: call s:add_methods('readable', ['resolve_view', 'resolve_layout'])
calling function <SNR>87_add_methods('readable', ['resolve_view', 'resolve_layout'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_resolve_view')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_resolve_view')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_resolve_layout')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_resolve_layout')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 2859: 
line 2860: function! s:findview(name)
line 2863: 
line 2864: function! s:findlayout(name)
line 2867: 
line 2868: function! s:viewEdit(cmd, ...) abort
line 2904: 
line 2905: function! s:layoutEdit(cmd,...)
line 2915: 
line 2916: function! s:controllerEdit(cmd,...)
line 2937: 
line 2938: function! s:stylesheetEdit(cmd,...)
line 2957: 
line 2958: function! s:javascriptEdit(cmd,...)
line 2977: 
line 2978: function! s:specEdit(cmd,...) abort
line 2984: 
line 2985: " }}}1
line 2986: " Alternate/Related {{{1
line 2987: 
line 2988: function! s:findcmdfor(cmd)
line 3016: 
line 3017: function! s:editcmdfor(cmd)
line 3023: 
line 3024: function! s:projection_pairs(options)
line 3041: 
line 3042: function! s:readable_open_command(cmd, argument, name, projections) dict abort
line 3118: 
line 3119: call s:add_methods('readable', ['open_command'])
calling function <SNR>87_add_methods('readable', ['open_command'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_open_command')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_open_command')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 3120: 
line 3121: function! s:findedit(cmd,files,...) abort
line 3158: 
line 3159: function! s:edit(cmd,file,...)
line 3170: 
line 3171: function! s:Alternate(cmd,line1,line2,count,...)
line 3192: 
line 3193: function! s:Related(cmd,line1,line2,count,...)
line 3200: 
line 3201: function! s:Complete_related(A,L,P)
line 3208: 
line 3209: function! s:readable_alternate_candidates(...) dict abort
line 3346: 
line 3347: function! s:readable_alternate(...) dict abort
line 3356: 
line 3357: " For backwards compatibility
line 3358: function! s:readable_related(...) dict abort
line 3361: 
line 3362: call s:add_methods('readable', ['alternate_candidates', 'alternate', 'related'])
calling function <SNR>87_add_methods('readable', ['alternate_candidates', 'alternate', 'related'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_alternate_candidates')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_alternate_candidates')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_alternate')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_alternate')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_related')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_related')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 3363: 
line 3364: " }}}1
line 3365: " Extraction {{{1
line 3366: 
line 3367: function! s:Extract(bang,...) range abort
line 3470: 
line 3471: function! s:RubyExtract(bang, root, before, name) range abort
line 3490: 
line 3491: " }}}1
line 3492: " Migration Inversion {{{1
line 3493: 
line 3494: function! s:mkeep(str)
line 3498: 
line 3499: function! s:mextargs(str,num)
line 3506: 
line 3507: function! s:migspc(line)
line 3510: 
line 3511: function! s:invertrange(beg,end)
line 3576: 
line 3577: function! s:Invert(bang)
line 3612: 
line 3613: " }}}1
line 3614: " Cache {{{1
line 3615: 
line 3616: let s:cache_prototype = {'dict': {}}
line 3617: 
line 3618: function! s:cache_clear(...) dict
line 3625: 
line 3626: function! rails#cache_clear(...)
line 3631: 
line 3632: function! s:cache_get(...) dict
line 3639: 
line 3640: function! s:cache_has(key) dict
line 3643: 
line 3644: function! s:cache_needs(key) dict
line 3647: 
line 3648: function! s:cache_set(key,value) dict
line 3651: 
line 3652: call s:add_methods('cache', ['clear','needs','has','get','set'])
calling function <SNR>87_add_methods('cache', ['clear', 'needs', 'has', 'get', 'set'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:cache_clear')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_cache_clear')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:cache_needs')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_cache_needs')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:cache_has')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_cache_has')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:cache_get')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_cache_get')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:cache_set')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_cache_set')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 3653: 
line 3654: let s:app_prototype.cache = s:cache_prototype
line 3655: 
line 3656: " }}}1
line 3657: " Syntax {{{1
line 3658: 
line 3659: function! s:resetomnicomplete()
line 3668: 
line 3669: function! s:helpermethods()
line 3693: 
line 3694: function! s:app_user_classes() dict
line 3708: 
line 3709: function! s:app_user_assertions() dict
line 3720: 
line 3721: call s:add_methods('app', ['user_classes','user_assertions'])
calling function <SNR>87_add_methods('app', ['user_classes', 'user_assertions'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_user_classes')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_user_classes')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_user_assertions')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_user_assertions')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 3722: 
line 3723: function! rails#buffer_syntax()
line 3874: 
line 3875: function! s:HiDefaults()
line 3921: 
line 3922: function! rails#log_syntax()
line 3963: 
line 3964: function! rails#log_setup() abort
line 3977: 
line 3978: " }}}1
line 3979: " Mappings {{{1
line 3980: 
line 3981: function! s:BufMappings()
line 3996: 
line 3997: " }}}1
line 3998: " Database {{{1
line 3999: 
line 4000: function! s:extractdbvar(str,arg)
line 4003: 
line 4004: function! s:app_dbext_settings(environment) dict
line 4054: 
line 4055: function! s:BufDatabase(level, ...)
line 4087: 
line 4088: call s:add_methods('app', ['dbext_settings'])
calling function <SNR>87_add_methods('app', ['dbext_settings'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_dbext_settings')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_dbext_settings')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 4089: 
line 4090: " }}}1
line 4091: " Abbreviations {{{1
line 4092: 
line 4093: function! s:selectiveexpand(pat,good,default,...)
line 4111: 
line 4112: function! s:AddSelectiveExpand(abbr,pat,expn,...)
line 4121: 
line 4122: function! s:AddTabExpand(abbr,expn)
line 4125: 
line 4126: function! s:AddBracketExpand(abbr,expn)
line 4129: 
line 4130: function! s:AddColonExpand(abbr,expn)
line 4133: 
line 4134: function! s:AddParenExpand(abbr,expn,...)
line 4141: 
line 4142: if !exists('g:rails_no_abbreviations') && type(get(g:, 'rails_abbreviations', {})) == type(0)
line 4143:   call s:error('Use rails_no_abbreviations not rails_abbreviations to disable abbreviations')
line 4144:   let g:rails_no_abbreviations = 1
line 4145: endif
line 4146: 
line 4147: function! s:BufAbbreviations()
line 4238: 
line 4239: function! s:Abbrev(bang,...) abort
line 4291: 
line 4292: " }}}1
line 4293: " Projections {{{1
line 4294: 
line 4295: function! rails#json_parse(string) abort
line 4307: 
line 4308: function! s:app_gems() dict abort
line 4315: 
line 4316: function! s:app_has_gem(gem) dict abort
line 4328: 
line 4329: function! s:app_engines() dict abort
line 4342: 
line 4343: function! s:extend_projection(dest, src)
line 4356: 
line 4357: function! s:combine_projections(dest, src, ...) abort
line 4369: 
line 4370: let s:projections_for_gems = {}
line 4371: function! s:app_projections() dict abort
line 4413: 
line 4414: call s:add_methods('app', ['gems', 'has_gem', 'engines', 'projections'])
calling function <SNR>87_add_methods('app', ['gems', 'has_gem', 'engines', 'projections'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_gems')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_gems')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_has_gem')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_has_gem')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_engines')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_engines')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:app_projections')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_app_projections')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 4415: 
line 4416: let s:transformations = {}
line 4417: 
line 4418: function! s:transformations.dot(input, o) abort
line 4421: 
line 4422: function! s:transformations.underscore(input, o) abort
line 4425: 
line 4426: function! s:transformations.colons(input, o) abort
line 4429: 
line 4430: function! s:transformations.hyphenate(input, o) abort
line 4433: 
line 4434: function! s:transformations.blank(input, o) abort
line 4437: 
line 4438: function! s:transformations.uppercase(input, o) abort
line 4441: 
line 4442: function! s:transformations.camelcase(input, o) abort
line 4445: 
line 4446: function! s:transformations.capitalize(input, o) abort
line 4449: 
line 4450: function! s:transformations.dirname(input, o) abort
line 4453: 
line 4454: function! s:transformations.basename(input, o) abort
line 4457: 
line 4458: function! s:transformations.plural(input, o) abort
line 4461: 
line 4462: function! s:transformations.singular(input, o) abort
line 4465: 
line 4466: function! s:transformations.open(input, o) abort
line 4469: 
line 4470: function! s:transformations.close(input, o) abort
line 4473: 
line 4474: function! s:expand_placeholder(placeholder, expansions) abort
line 4491: 
line 4492: function! s:expand_placeholders(string, placeholders)
line 4501: 
line 4502: function! s:readable_projected(key, ...) dict abort
line 4531: 
line 4532: call s:add_methods('readable', ['projected'])
calling function <SNR>87_add_methods('readable', ['projected'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>87_add_methods..<SNR>87_function('s:readable_projected')

line 1:     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>87_add_methods..<SNR>87_function returning function('<SNR>87_readable_projected')

continuing in function <SNR>87_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>87_add_methods returning #0

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 4533: 
line 4534: function! s:Set(bang,...)
line 4537: 
line 4538: " }}}1
line 4539: " Detection {{{1
line 4540: 
line 4541: function! s:SetBasePath() abort
line 4579: 
line 4580: function! rails#buffer_setup() abort
line 4661: 
line 4662: " }}}1
line 4663: " Autocommands {{{1
line 4664: 
line 4665: augroup railsPluginAuto
line 4666:   autocmd!
line 4667:   autocmd User BufEnterRails call s:RefreshBuffer()
line 4668:   autocmd User BufEnterRails call s:resetomnicomplete()
line 4669:   autocmd User BufEnterRails call s:BufDatabase(-1)
line 4670:   autocmd User dbextPreConnection call s:BufDatabase(1)
line 4671:   autocmd BufWritePost */config/database.yml      call rails#cache_clear("dbext_settings")
line 4672:   autocmd BufWritePost */config/projections.json  call rails#cache_clear("projections")
line 4673:   autocmd BufWritePost */test/test_helper.rb      call rails#cache_clear("user_assertions")
line 4674:   autocmd BufWritePost */config/routes.rb         call rails#cache_clear("named_routes")
line 4675:   autocmd BufWritePost */config/application.rb    call rails#cache_clear("default_locale")
line 4676:   autocmd BufWritePost */config/application.rb    call rails#cache_clear("stylesheet_suffix")
line 4677:   autocmd BufWritePost */config/environments/*.rb call rails#cache_clear("environments")
line 4678:   autocmd BufWritePost */tasks/**.rake            call rails#cache_clear("rake_tasks")
line 4679:   autocmd BufWritePost */generators/**            call rails#cache_clear("generators")
line 4680: augroup END
line 4681: 
line 4682: " }}}1
line 4683: " Initialization {{{1
line 4684: 
line 4685: map <SID>xx <SID>xx
line 4686: let s:sid = s:sub(maparg("<SID>xx"),'xx$','')
calling function <SNR>87_sub('<SNR>87_xx', 'xx$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function <SNR>87_sub returning '<SNR>87_'

continuing in /home/max/.vim/bundle/vim-rails/autoload/rails.vim

line 4687: unmap <SID>xx
line 4688: let s:file = expand('<sfile>:p')
line 4689: 
line 4690: if !exists('s:apps')
line 4691:   let s:apps = {}
line 4692: endif
line 4693: 
line 4694: " }}}1
line 4695: " vim:set sw=2 sts=2:
finished sourcing /home/max/.vim/bundle/vim-rails/autoload/rails.vim
continuing in VimEnter Auto commands for "*"
line 0:    silent doau User BufEnterRails | endif
line 0:  endif
Executing VimEnter Auto commands for "*"
autocommand call s:abolish_setup()

line 0: call s:abolish_setup()
calling function <SNR>35_abolish_setup()

line 1:   if exists('g:Abolish') && has_key(g:Abolish,'Coercions')
line 2:     if !has_key(g:Abolish.Coercions,'l')
line 3:       let g:Abolish.Coercions.l = s:function('s:abolish_l')
line 4:     endif
line 5:     if !has_key(g:Abolish.Coercions,'t')
line 6:       let g:Abolish.Coercions.t = s:function('s:abolish_t')
line 7:     endif
line 8:   endif
function <SNR>35_abolish_setup returning #0

continuing in VimEnter Auto commands for "*"

Executing VimEnter Auto commands for "*"
autocommand call youcompleteme#Enable()

line 0: call youcompleteme#Enable()
Searching for "autoload/youcompleteme.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/F
Searching for "/home/max/.vim/autoload/youcompleteme.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/youcompleteme.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/youcompleteme.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/youcompleteme.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/youcompleteme.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/youcompleteme.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/youcompleteme.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/youcompleteme.vim"
Searching for "/home/max/.vim/bundle/command-t/autoload/youcompleteme.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim"
chdir(/home/max/.vim/bundle/YouCompleteMe/autoload)
fchdir() to previous dir
line 0: sourcing "/home/max/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim"
line 1: " Copyright (C) 2011, 2012  Google Inc.
line 2: "
line 3: " This file is part of YouCompleteMe.
line 4: "
line 5: " YouCompleteMe is free software: you can redistribute it and/or modify
line 6: " it under the terms of the GNU General Public License as published by
line 7: " the Free Software Foundation, either version 3 of the License, or
line 8: " (at your option) any later version.
line 9: "
line 10: " YouCompleteMe is distributed in the hope that it will be useful,
line 11: " but WITHOUT ANY WARRANTY; without even the implied warranty of
line 12: " MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
line 13: " GNU General Public License for more details.
line 14: "
line 15: " You should have received a copy of the GNU General Public License
line 16: " along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.
line 17: 
line 18: " This is basic vim plugin boilerplate
line 19: let s:save_cpo = &cpo
line 20: set cpo&vim
line 21: 
line 22: " This needs to be called outside of a function
line 23: let s:script_folder_path = escape( expand( '<sfile>:p:h' ), '\' )
line 24: let s:omnifunc_mode = 0
line 25: 
line 26: let s:old_cursor_position = []
line 27: let s:cursor_moved = 0
line 28: let s:moved_vertically_in_insert_mode = 0
line 29: let s:previous_num_chars_on_current_line = -1
line 30: 
line 37: let s:diagnostic_ui_filetypes = { 'cpp': 1, 'cs': 1, 'c': 1, 'objc': 1, 'objcpp': 1, }
line 38: 
line 39: 
line 40: function! youcompleteme#Enable()
line 93: 
line 94: 
line 95: function youcompleteme#EnableCursorMovedAutocommands()
line 102: 
line 103: 
line 104: function youcompleteme#DisableCursorMovedAutocommands()
line 108: 
line 109: 
line 110: function! s:SetUpPython() abort
line 140: 
line 141: 
line 142: function! s:SetUpKeyMappings()
line 192: 
line 193: 
line 194: function! s:SetUpSigns()
line 227: 
line 228: 
line 229: function! s:SetUpSyntaxHighlighting()
line 249: 
line 250: 
line 251: function! s:SetUpBackwardsCompatibility()
line 265: 
line 266: 
line 267: " Needed so that YCM is used instead of Syntastic
line 268: function! s:TurnOffSyntasticForCFamily()
line 274: 
line 275: 
line 276: function! s:DiagnosticUiSupportedForCurrentFiletype()
line 279: 
line 280: 
line 281: function! s:AllowedToCompleteInCurrentFile()
line 294: 
line 295: 
line 296: function! s:SetUpCpoptions()
line 307: 
line 308: 
line 309: function! s:SetUpCompleteopt()
line 331: 
line 332: 
line 333: " For various functions/use-cases, we want to keep track of whether the buffer
line 334: " has changed since the last time they were invoked. We keep the state of
line 335: " b:changedtick of the last time the specific function was called in
line 336: " b:ycm_changedtick.
line 337: function! s:SetUpYcmChangedTick()
line 343: 
line 344: 
line 345: function! s:OnVimLeave()
line 348: 
line 349: 
line 350: function! s:OnBufferVisit()
line 365: 
line 366: 
line 367: function! s:OnBufferUnload( deleted_buffer_file )
line 374: 
line 375: 
line 376: function! s:OnCursorHold()
line 384: 
line 385: 
line 386: function! s:OnFileReadyToParse()
line 403: 
line 404: 
line 405: function! s:SetCompleteFunc()
line 421: 
line 422: 
line 423: function! s:OnCursorMovedInsertMode()
line 458: 
line 459: 
line 460: function! s:OnCursorMovedNormalMode()
line 468: 
line 469: 
line 470: function! s:OnInsertLeave()
line 483: 
line 484: 
line 485: function! s:OnInsertEnter()
line 492: 
line 493: 
line 494: function! s:UpdateCursorMoved()
line 503: 
line 504: 
line 505: function! s:BufferTextChangedSinceLastMoveInInsertMode()
line 524: 
line 525: 
line 526: function! s:ClosePreviewWindowIfNeeded()
line 540: 
line 541: 
line 542: function! s:UpdateDiagnosticNotifications()
line 553: 
line 554: 
line 555: function! s:IdentifierFinishedOperations()
line 562: 
line 563: 
line 564: " Returns 1 when inside comment and 2 when inside string
line 565: function! s:InsideCommentOrString()
line 580: 
line 581: 
line 582: function! s:InsideCommentOrStringAndShouldStop()
line 594: 
line 595: 
line 596: function! s:OnBlankLine()
line 599: 
line 600: 
line 601: function! s:InvokeCompletion()
line 631: 
line 632: 
line 633: python << EOF
line 644: 
line 645: 
line 646: function! s:GetCompletions()
line 651: 
line 652: 
line 653: " This is our main entry point. This is what vim calls to get completions.
line 654: function! youcompleteme#Complete( findstart, base )
line 682: 
line 683: 
line 684: function! youcompleteme#OmniComplete( findstart, base )
line 696: 
line 697: 
line 698: function! youcompleteme#ServerPid()
line 701: 
line 702: 
line 703: function! s:RestartServer()
line 706: 
line 707: command! YcmRestartServer call s:RestartServer()
line 708: 
line 709: 
line 710: function! s:ShowDetailedDiagnostic()
line 713: 
line 714: command! YcmShowDetailedDiagnostic call s:ShowDetailedDiagnostic()
line 715: 
line 716: 
line 717: function! s:DebugInfo()
line 724: 
line 725: command! YcmDebugInfo call s:DebugInfo()
line 726: 
line 727: 
line 728: function! s:CompleterCommand(...)
line 749: 
line 750: 
line 751: function! youcompleteme#OpenGoToList()
line 759: 
line 760: 
line 762: command! -nargs=* -complete=custom,youcompleteme#SubCommandsComplete YcmCompleter call s:CompleterCommand(<f-args>)
line 763: 
line 764: function! youcompleteme#SubCommandsComplete( arglead, cmdline, cursorpos )
line 768: 
line 769: 
line 770: function! s:ForceCompile()
line 790: 
line 791: 
line 792: function! s:ForceCompileAndDiagnostics()
line 801: 
line 802: command! YcmForceCompileAndDiagnostics call s:ForceCompileAndDiagnostics()
line 803: 
line 804: 
line 805: function! s:ShowDiagnostics()
line 823: 
line 824: command! YcmDiags call s:ShowDiagnostics()
line 825: 
line 826: 
line 827: " This is basic vim plugin boilerplate
line 828: let &cpo = s:save_cpo
line 829: unlet s:save_cpo
finished sourcing /home/max/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim
continuing in VimEnter Auto commands for "*"
calling function youcompleteme#Enable()

line 1:   " When vim is in diff mode, don't run
line 2:   if &diff
line 3:     return
line 4:   endif
line 5: 
line 6:   call s:SetUpBackwardsCompatibility()
calling function youcompleteme#Enable..<SNR>88_SetUpBackwardsCompatibility()

line 1:   let complete_in_comments_and_strings = get( g:, 'ycm_complete_in_comments_and_strings', 0 )
line 3: 
line 4:   if complete_in_comments_and_strings
line 5:     let g:ycm_complete_in_strings = 1
line 6:     let g:ycm_complete_in_comments = 1
line 7:   endif
line 8: 
line 9:   " ycm_filetypes_to_completely_ignore is the old name for fileype_blacklist
line 10:   if has_key( g:, 'ycm_filetypes_to_completely_ignore' )
line 11:     let g:filetype_blacklist =  g:ycm_filetypes_to_completely_ignore
line 12:   endif
function youcompleteme#Enable..<SNR>88_SetUpBackwardsCompatibility returning #0

continuing in function youcompleteme#Enable

line 7: 
line 8:   " This can be 0 if YCM libs are old or -1 if an exception occured while
line 9:   " executing the function.
line 10:   if s:SetUpPython() != 1
calling function youcompleteme#Enable..<SNR>88_SetUpPython()

line 1:   py import sys
line 2:   py import vim
line 3:   exe 'python sys.path.insert( 0, "' . s:script_folder_path . '/../python" )'
line 3: python sys.path.insert( 0, "/home/max/.vim/bundle/YouCompleteMe/autoload/../python" )
line 4:   exe 'python sys.path.insert( 0, "' . s:script_folder_path . '/../third_party/ycmd" )'
line 4: python sys.path.insert( 0, "/home/max/.vim/bundle/YouCompleteMe/autoload/../third_party/ycmd" )
line 6:   py from ycmd import utils
line 7:   exe 'py utils.AddNearestThirdPartyFoldersToSysPath("' . s:script_folder_path . '")'
line 7: py utils.AddNearestThirdPartyFoldersToSysPath("/home/max/.vim/bundle/YouCompleteMe/autoload")
line 9: 
line 10:   " We need to import ycmd's third_party folders as well since we import and
line 11:   " use ycmd code in the client.
line 12:   py utils.AddNearestThirdPartyFoldersToSysPath( utils.__file__ )
line 13:   py from ycm import base
line 14:   py base.LoadJsonDefaultsIntoVim()
line 15:   py from ycmd import user_options_store
line 16:   py user_options_store.SetAll( base.BuildServerConf() )
line 17:   py from ycm import vimsupport
line 18: 
line 19:   if !pyeval( 'base.CompatibleWithYcmCore()')
line 20:     echohl WarningMsg | echomsg "YouCompleteMe unavailable: YCM support libs too old, PLEASE RECOMPILE" | echohl None
line 20:  echomsg "YouCompleteMe unavailable: YCM support libs too old, PLEASE RECOMPILE" | echohl None
line 20:  echohl None
line 23:     return 0
line 24:   endif
line 25: 
line 26:   py from ycm.youcompleteme import YouCompleteMe
line 27:   py ycm_state = YouCompleteMe( user_options_store.GetAll() )
line 28:   return 1
function youcompleteme#Enable..<SNR>88_SetUpPython returning #1

continuing in function youcompleteme#Enable

line 11:     return
line 12:   endif
line 13: 
line 14:   call s:SetUpCpoptions()
calling function youcompleteme#Enable..<SNR>88_SetUpCpoptions()

line 1:   " Without this flag in cpoptions, critical YCM mappings do not work. There's
line 2:   " no way to not have this and have YCM working, so force the flag.
line 3:   set cpoptions+=B
line 4: 
line 5:   " This prevents the display of "Pattern not found" & similar messages during
line 6:   " completion. This is only available since Vim 7.4.314
line 7:   if pyeval( 'vimsupport.VimVersionAtLeast("7.4.314")' )
line 8:     set shortmess+=c
line 9:   endif
function youcompleteme#Enable..<SNR>88_SetUpCpoptions returning #0

continuing in function youcompleteme#Enable

line 15:   call s:SetUpCompleteopt()
calling function youcompleteme#Enable..<SNR>88_SetUpCompleteopt()

line 1:   " Some plugins (I'm looking at you, vim-notes) change completeopt by for
line 2:   " instance adding 'longest'. This breaks YCM. So we force our settings.
line 3:   " There's no two ways about this: if you want to use YCM then you have to
line 4:   " have these completeopt settings, otherwise YCM won't work at all.
line 5: 
line 6:   " We need menuone in completeopt, otherwise when there's only one candidate
line 7:   " for completion, the menu doesn't show up.
line 8:   set completeopt-=menu
line 9:   set completeopt+=menuone
line 10: 
line 11:   " This is unnecessary with our features. People use this option to insert
line 12:   " the common prefix of all the matches and then add more differentiating chars
line 13:   " so that they can select a more specific match. With our features, they
line 14:   " don't need to insert the prefix; they just type the differentiating chars.
line 15:   " Also, having this option set breaks the plugin.
line 16:   set completeopt-=longest
line 17: 
line 18:   if g:ycm_add_preview_to_completeopt
line 19:     set completeopt+=preview
line 20:   endif
function youcompleteme#Enable..<SNR>88_SetUpCompleteopt returning #0

continuing in function youcompleteme#Enable

line 16:   call s:SetUpKeyMappings()
calling function youcompleteme#Enable..<SNR>88_SetUpKeyMappings()

line 1:   " The g:ycm_key_select_completion and g:ycm_key_previous_completion used to
line 2:   " exist and are now here purely for the sake of backwards compatibility; we
line 3:   " don't want to break users if we can avoid it.
line 4: 
line 5:   if exists('g:ycm_key_select_completion') && index(g:ycm_key_list_select_completion,       g:ycm_key_select_completion) == -1
line 8:     call add(g:ycm_key_list_select_completion, g:ycm_key_select_completion)
line 9:   endif
line 10: 
line 11:   if exists('g:ycm_key_previous_completion') && index(g:ycm_key_list_previous_completion,       g:ycm_key_previous_completion) == -1
line 14:     call add(g:ycm_key_list_previous_completion, g:ycm_key_previous_completion)
line 15:   endif
line 16: 
line 17:   for key in g:ycm_key_list_select_completion
line 18:     " With this command, when the completion window is visible, the tab key
line 19:     " (default) will select the next candidate in the window. In vim, this also
line 20:     " changes the typed-in text to that of the candidate completion.
line 21:     exe 'inoremap <expr>' . key . ' pumvisible() ? "\<C-n>" : "\' . key .'"'
line 21: inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
line 23:   endfor
line 17:   for key in g:ycm_key_list_select_completion
line 18:     " With this command, when the completion window is visible, the tab key
line 19:     " (default) will select the next candidate in the window. In vim, this also
line 20:     " changes the typed-in text to that of the candidate completion.
line 21:     exe 'inoremap <expr>' . key . ' pumvisible() ? "\<C-n>" : "\' . key .'"'
line 21: inoremap <expr><Down> pumvisible() ? "\<C-n>" : "\<Down>"
line 23:   endfor
line 17:   for key in g:ycm_key_list_select_completion
line 18:     " With this command, when the completion window is visible, the tab key
line 19:     " (default) will select the next candidate in the window. In vim, this also
line 20:     " changes the typed-in text to that of the candidate completion.
line 21:     exe 'inoremap <expr>' . key . ' pumvisible() ? "\<C-n>" : "\' . key .'"'
line 23:   endfor
line 24: 
line 25: 
line 26:   for key in g:ycm_key_list_previous_completion
line 27:     " This selects the previous candidate for shift-tab (default)
line 28:     exe 'inoremap <expr>' . key . ' pumvisible() ? "\<C-p>" : "\' . key .'"'
line 28: inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<S-TAB>"
line 30:   endfor
line 26:   for key in g:ycm_key_list_previous_completion
line 27:     " This selects the previous candidate for shift-tab (default)
line 28:     exe 'inoremap <expr>' . key . ' pumvisible() ? "\<C-p>" : "\' . key .'"'
line 28: inoremap <expr><Up> pumvisible() ? "\<C-p>" : "\<Up>"
line 30:   endfor
line 26:   for key in g:ycm_key_list_previous_completion
line 27:     " This selects the previous candidate for shift-tab (default)
line 28:     exe 'inoremap <expr>' . key . ' pumvisible() ? "\<C-p>" : "\' . key .'"'
line 30:   endfor
line 31: 
line 32:   if !empty( g:ycm_key_invoke_completion )
line 33:     let invoke_key = g:ycm_key_invoke_completion
line 34: 
line 35:     " Inside the console, <C-Space> is passed as <Nul> to Vim
line 36:     if invoke_key ==# '<C-Space>' && !has('gui_running')
line 37:       let invoke_key = '<Nul>'
line 38:     endif
line 39: 
line 40:     " <c-x><c-o> trigger omni completion, <c-p> deselects the first completion
line 41:     " candidate that vim selects by default
line 42:     silent! exe 'inoremap <unique> ' . invoke_key .  ' <C-X><C-O><C-P>'
line 42: inoremap <unique> <Nul> <C-X><C-O><C-P>
line 43:   endif
line 44: 
line 45:   if !empty( g:ycm_key_detailed_diagnostics )
line 46:     silent! exe 'nnoremap <unique> ' . g:ycm_key_detailed_diagnostics . ' :YcmShowDetailedDiagnostic<cr>'
line 46: nnoremap <unique> <leader>d :YcmShowDetailedDiagnostic<cr>
Error detected while processing function youcompleteme#Enable..<SNR>88_SetUpKeyMappings:
line   46:
E227: mapping already exists for \d
line 48:   endif
function youcompleteme#Enable..<SNR>88_SetUpKeyMappings returning #0

continuing in function youcompleteme#Enable

line 17: 
line 18:   if g:ycm_show_diagnostics_ui
line 19:     call s:TurnOffSyntasticForCFamily()
calling function youcompleteme#Enable..<SNR>88_TurnOffSyntasticForCFamily()

line 1:   let g:syntastic_cpp_checkers = []
line 2:   let g:syntastic_c_checkers = []
line 3:   let g:syntastic_objc_checkers = []
line 4:   let g:syntastic_objcpp_checkers = []
function youcompleteme#Enable..<SNR>88_TurnOffSyntasticForCFamily returning #0

continuing in function youcompleteme#Enable

line 20:   endif
line 21: 
line 22:   call s:SetUpSigns()
calling function youcompleteme#Enable..<SNR>88_SetUpSigns()

line 1:   " We try to ensure backwards compatibility with Syntastic if the user has
line 2:   " already defined styling for Syntastic highlight groups.
line 3: 
line 4:   if !hlexists( 'YcmErrorSign' )
line 5:     if hlexists( 'SyntasticErrorSign')
line 6:       highlight link YcmErrorSign SyntasticErrorSign
line 7:     else
line 8:       highlight link YcmErrorSign error
line 9:     endif
line 10:   endif
line 11: 
line 12:   if !hlexists( 'YcmWarningSign' )
line 13:     if hlexists( 'SyntasticWarningSign')
line 14:       highlight link YcmWarningSign SyntasticWarningSign
line 15:     else
line 16:       highlight link YcmWarningSign todo
line 17:     endif
line 18:   endif
line 19: 
line 20:   if !hlexists( 'YcmErrorLine' )
line 21:     highlight link YcmErrorLine SyntasticErrorLine
line 22:   endif
line 23: 
line 24:   if !hlexists( 'YcmWarningLine' )
line 25:     highlight link YcmWarningLine SyntasticWarningLine
line 26:   endif
line 27: 
line 28:   exe 'sign define YcmError text=' . g:ycm_error_symbol . ' texthl=YcmErrorSign linehl=YcmErrorLine'
line 28: sign define YcmError text=>> texthl=YcmErrorSign linehl=YcmErrorLine
line 30:   exe 'sign define YcmWarning text=' . g:ycm_warning_symbol . ' texthl=YcmWarningSign linehl=YcmWarningLine'
line 30: sign define YcmWarning text=>> texthl=YcmWarningSign linehl=YcmWarningLine
function youcompleteme#Enable..<SNR>88_SetUpSigns returning #0

continuing in function youcompleteme#Enable

line 23:   call s:SetUpSyntaxHighlighting()
calling function youcompleteme#Enable..<SNR>88_SetUpSyntaxHighlighting()

line 1:   " We try to ensure backwards compatibility with Syntastic if the user has
line 2:   " already defined styling for Syntastic highlight groups.
line 3: 
line 4:   if !hlexists( 'YcmErrorSection' )
line 5:     if hlexists( 'SyntasticError' )
line 6:       highlight link YcmErrorSection SyntasticError
line 7:     else
line 8:       highlight link YcmErrorSection SpellBad
line 9:     endif
line 10:   endif
line 11: 
line 12:   if !hlexists( 'YcmWarningSection' )
line 13:     if hlexists( 'SyntasticWarning' )
line 14:       highlight link YcmWarningSection SyntasticWarning
line 15:     else
line 16:       highlight link YcmWarningSection SpellCap
line 17:     endif
line 18:   endif
function youcompleteme#Enable..<SNR>88_SetUpSyntaxHighlighting returning #0

continuing in function youcompleteme#Enable

line 24: 
line 25:   if g:ycm_allow_changing_updatetime && &updatetime > 2000
line 26:     set ut=2000
line 27:   endif
line 28: 
line 29:   call youcompleteme#EnableCursorMovedAutocommands()
calling function youcompleteme#Enable..youcompleteme#EnableCursorMovedAutocommands()

line 1:     augroup ycmcompletemecursormove
line 2:         autocmd!
line 3:         autocmd CursorMovedI * call s:OnCursorMovedInsertMode()
line 4:         autocmd CursorMoved * call s:OnCursorMovedNormalMode()
line 5:     augroup END
function youcompleteme#Enable..youcompleteme#EnableCursorMovedAutocommands returning #0

continuing in function youcompleteme#Enable

line 30:   augroup youcompleteme
line 31:     autocmd!
line 32:     " Note that these events will NOT trigger for the file vim is started with;
line 33:     " so if you do "vim foo.cc", these events will not trigger when that buffer
line 34:     " is read. This is because youcompleteme#Enable() is called on VimEnter and
line 35:     " that happens *after" BufRead/BufEnter has already triggered for the
line 36:     " initial file.
line 37:     " We also need to trigger buf init code on the FileType event because when
line 38:     " the user does :enew and then :set ft=something, we need to run buf init
line 39:     " code again.
line 40:     autocmd BufRead,BufEnter,FileType * call s:OnBufferVisit()
line 41:     autocmd BufUnload * call s:OnBufferUnload( expand( '<afile>:p' ) )
line 42:     autocmd CursorHold,CursorHoldI * call s:OnCursorHold()
line 43:     autocmd InsertLeave * call s:OnInsertLeave()
line 44:     autocmd InsertEnter * call s:OnInsertEnter()
line 45:     autocmd VimLeave * call s:OnVimLeave()
line 46:   augroup END
line 47: 
line 48:   " Calling this once solves the problem of BufRead/BufEnter not triggering for
line 49:   " the first loaded file. This should be the last command executed in this
line 50:   " function!
line 51:   call s:OnBufferVisit()
calling function youcompleteme#Enable..<SNR>88_OnBufferVisit()

line 1:   " We need to do this even when we are not allowed to complete in the current
line 2:   " file because we might be allowed to complete in the future! The canonical
line 3:   " example is creating a new buffer with :enew and then setting a filetype.
line 4:   call s:SetUpYcmChangedTick()
calling function youcompleteme#Enable..<SNR>88_OnBufferVisit..<SNR>88_SetUpYcmChangedTick()

line 1:   let b:ycm_changedtick  = get( b:, 'ycm_changedtick', {   'file_ready_to_parse' : -1, } )
function youcompleteme#Enable..<SNR>88_OnBufferVisit..<SNR>88_SetUpYcmChangedTick returning #0

continuing in function youcompleteme#Enable..<SNR>88_OnBufferVisit

line 5: 
line 6:   if !s:AllowedToCompleteInCurrentFile()
calling function youcompleteme#Enable..<SNR>88_OnBufferVisit..<SNR>88_AllowedToCompleteInCurrentFile()

line 1:   if empty( &filetype ) || getbufvar( winbufnr( winnr() ), "&buftype" ) ==# 'nofile' || &filetype ==# 'qf'
line 4:     return 0
function youcompleteme#Enable..<SNR>88_OnBufferVisit..<SNR>88_AllowedToCompleteInCurrentFile returning #0

continuing in function youcompleteme#Enable..<SNR>88_OnBufferVisit

line 7:     return
function youcompleteme#Enable..<SNR>88_OnBufferVisit returning #0

continuing in function youcompleteme#Enable

function youcompleteme#Enable returning #0

continuing in VimEnter Auto commands for "*"

Executing VimEnter Auto commands for "*"
autocommand sil! call s:VimEnter(expand("<amatch>"))

line 0: sil! call s:VimEnter(expand("<amatch>"))
calling function <SNR>80_VimEnter('')

line 1: "  call Decho("VimEnter(dirname<".a:dirname.">){")
line 2:   let curwin       = winnr()
line 3:   let s:vimentered = 1
line 4:   windo if a:dirname != expand("%")|call s:LocalBrowse(expand("%:p"))|endif
line 4: if a:dirname != expand("%")|call s:LocalBrowse(expand("%:p"))|endif
line 4: call s:LocalBrowse(expand("%:p"))|endif
line 4: endif
line 5:   exe curwin."wincmd w"
line 5: 1wincmd w
line 6: "  call Decho("|return VimEnter }")
function <SNR>80_VimEnter returning #0

continuing in VimEnter Auto commands for "*"

Executing CursorMoved Auto commands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>79_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     3match none
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let c = getline(c_lnum)[c_col - 1]
line 19:   let plist = split(&matchpairs, '.\zs[:,]')
line 20:   let i = index(plist, c)
line 21:   if i < 0
line 22:     " not found, in Insert mode try character before the cursor
line 23:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 24:       let before = 1
line 25:       let c = getline(c_lnum)[c_col - 2]
line 26:       let i = index(plist, c)
line 27:     endif
line 28:     if i < 0
line 29:       " not found, nothing to do
line 30:       return
function <SNR>79_Highlight_Matching_Pair returning #0

continuing in CursorMoved Auto commands for "*"

Executing CursorMoved Auto commands for "*"
autocommand call s:OnCursorMovedNormalMode()

line 0: call s:OnCursorMovedNormalMode()
calling function <SNR>88_OnCursorMovedNormalMode()

line 1:   if !s:AllowedToCompleteInCurrentFile()
calling function <SNR>88_OnCursorMovedNormalMode..<SNR>88_AllowedToCompleteInCurrentFile()

line 1:   if empty( &filetype ) || getbufvar( winbufnr( winnr() ), "&buftype" ) ==# 'nofile' || &filetype ==# 'qf'
line 4:     return 0
function <SNR>88_OnCursorMovedNormalMode..<SNR>88_AllowedToCompleteInCurrentFile returning #0

continuing in function <SNR>88_OnCursorMovedNormalMode

line 2:     return
function <SNR>88_OnCursorMovedNormalMode returning #0

continuing in CursorMoved Auto commands for "*"


Executing QuitPre Auto commands for "*"
autocommand call s:QuitPreHook()

line 0: call s:QuitPreHook()
calling function <SNR>71_QuitPreHook()

line 1:     call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: QuitPre, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))))
calling function <SNR>71_QuitPreHook..syntastic#log#debug(8, 'autocmd: QuitPre, buffer 1 = ''''')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>71_QuitPreHook..syntastic#log#debug..<SNR>72__isDebugEnabled_smart(8)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>71_QuitPreHook..syntastic#log#debug..<SNR>72__isDebugEnabled_smart returning #0

continuing in function <SNR>71_QuitPreHook..syntastic#log#debug

line 2:         return
function <SNR>71_QuitPreHook..syntastic#log#debug returning #0

continuing in function <SNR>71_QuitPreHook

line 3:     let b:syntastic_skip_checks = get(b:, 'syntastic_skip_checks', 0) || !syntastic#util#var('check_on_wq')
calling function <SNR>71_QuitPreHook..syntastic#util#var('check_on_wq')

line 1:     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''
function <SNR>71_QuitPreHook..syntastic#util#var returning #1

continuing in function <SNR>71_QuitPreHook

line 4:     call SyntasticLoclistHide()
calling function <SNR>71_QuitPreHook..SyntasticLoclistHide()

line 1:     call syntastic#log#debug(g:SyntasticDebugNotifications, 'loclist: hide')
calling function <SNR>71_QuitPreHook..SyntasticLoclistHide..syntastic#log#debug(4, 'loclist: hide')

line 1:     if !s:isDebugEnabled(a:level)
calling function <SNR>71_QuitPreHook..SyntasticLoclistHide..syntastic#log#debug..<SNR>72__isDebugEnabled_smart(4)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>71_QuitPreHook..SyntasticLoclistHide..syntastic#log#debug..<SNR>72__isDebugEnabled_smart returning #0

continuing in function <SNR>71_QuitPreHook..SyntasticLoclistHide..syntastic#log#debug

line 2:         return
function <SNR>71_QuitPreHook..SyntasticLoclistHide..syntastic#log#debug returning #0

continuing in function <SNR>71_QuitPreHook..SyntasticLoclistHide

line 2:     silent! lclose
function <SNR>71_QuitPreHook..SyntasticLoclistHide returning #0

continuing in function <SNR>71_QuitPreHook

function <SNR>71_QuitPreHook returning #0

continuing in QuitPre Auto commands for "*"

Executing BufWinLeave Auto commands for "*"
autocommand execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')

line 0: execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
line 0: 
Executing BufWinLeave Auto commands for "*"
autocommand if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif

line 0: if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif
calling function <SNR>33_can_diffoff(1)

line 1:   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))
function <SNR>33_can_diffoff returning #0

continuing in BufWinLeave Auto commands for "*"

line 0:    call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif
line 0:  endif
Executing BufUnload Auto commands for "*"
autocommand call s:OnBufferUnload( expand( '<afile>:p' ) )

line 0: call s:OnBufferUnload( expand( '<afile>:p' ) )
calling function <SNR>88_OnBufferUnload('')

line 1:   if !s:AllowedToCompleteInCurrentFile() || empty( a:deleted_buffer_file )
calling function <SNR>88_OnBufferUnload..<SNR>88_AllowedToCompleteInCurrentFile()

line 1:   if empty( &filetype ) || getbufvar( winbufnr( winnr() ), "&buftype" ) ==# 'nofile' || &filetype ==# 'qf'
line 4:     return 0
function <SNR>88_OnBufferUnload..<SNR>88_AllowedToCompleteInCurrentFile returning #0

continuing in function <SNR>88_OnBufferUnload

line 2:     return
function <SNR>88_OnBufferUnload returning #0

continuing in BufUnload Auto commands for "*"

Executing VimLeavePre Auto commands for "*"
autocommand cal s:savetofile(s:mergelists())

line 0: cal s:savetofile(s:mergelists())
calling function <SNR>75_mergelists()

line 1: ^Ilet diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
calling function <SNR>75_mergelists..ctrlp#mrufiles#cachefile()

line 1: ^Iif !exists('s:cadir') || !exists('s:cafile')
line 2: ^I^Ilet s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
Searching for "autoload/ctrlp/utils.vim" in "/home/max/.vim,/home/max/.vim/bundle/vundle,/home/max/.vim/bundle/vim-fugitive,/home/max/.vim/bundle/vim-easymotion,/home/max/.vim/bundle/vim-rails,/home/max/.vim/bundle/sparkup/vim/,/home/max/.vim/bundle/L9,/home/max/.vim/bundle/FuzzyFinder,/home/max/.vim/bundle/command-t,/home/max/.vim/bundle/YouCompleteMe,/home/max/.vim/bundle/syntastic,/home/max/.vim/bundle/ctrlp.vim,/home/max/.vim/bundle/vim-golang,/home/max/.vim/bundle/scss-syntax.vim,/home/max/.vim/bundle/vim-coffee-script,/home/max/.vim/bundle/LaTeX-Box,/home/max/.vim/bundle/google.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/max/.vim/after,/home/max/.vim/bundle/Vundle.vim,/home/max/.vim/bundle/vundle/after,/home/max/.vim/bundle/vim-fugitive/after,/home/max/.vim/bundle/vim-easymotion/after,/home/max/.vim/bundle/vim-rails/after,/home/max/.vim/bundle/sparkup/vim//after,/home/max/.vim/bundle/L9/after,/home/max/.vim/bundle/Fuz
Searching for "/home/max/.vim/autoload/ctrlp/utils.vim"
Searching for "/home/max/.vim/bundle/vundle/autoload/ctrlp/utils.vim"
Searching for "/home/max/.vim/bundle/vim-fugitive/autoload/ctrlp/utils.vim"
Searching for "/home/max/.vim/bundle/vim-easymotion/autoload/ctrlp/utils.vim"
Searching for "/home/max/.vim/bundle/vim-rails/autoload/ctrlp/utils.vim"
Searching for "/home/max/.vim/bundle/sparkup/vim/autoload/ctrlp/utils.vim"
Searching for "/home/max/.vim/bundle/L9/autoload/ctrlp/utils.vim"
Searching for "/home/max/.vim/bundle/FuzzyFinder/autoload/ctrlp/utils.vim"
Searching for "/home/max/.vim/bundle/command-t/autoload/ctrlp/utils.vim"
Searching for "/home/max/.vim/bundle/YouCompleteMe/autoload/ctrlp/utils.vim"
Searching for "/home/max/.vim/bundle/syntastic/autoload/ctrlp/utils.vim"
Searching for "/home/max/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim"
chdir(/home/max/.vim/bundle/ctrlp.vim/autoload/ctrlp)
fchdir() to previous dir
line 2: sourcing "/home/max/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim"
line 1: " =============================================================================
line 2: " File:          autoload/ctrlp/utils.vim
line 3: " Description:   Utilities
line 4: " Author:        Kien Nguyen <github.com/kien>
line 5: " =============================================================================
line 6: 
line 7: " Static variables {{{1
line 8: fu! ctrlp#utils#lash()
line 11: 
line 12: fu! s:lash(...)
line 15: 
line 16: fu! ctrlp#utils#opts()
line 30: cal ctrlp#utils#opts()
calling function ctrlp#utils#opts()

line 1: ^Ilet s:lash = ctrlp#utils#lash()
calling function ctrlp#utils#opts..ctrlp#utils#lash()

line 1: ^Iretu &ssl || !exists('+ssl') ? '/' : '\'
function ctrlp#utils#opts..ctrlp#utils#lash returning '/'

continuing in function ctrlp#utils#opts

line 2: ^Ilet usrhome = $HOME . s:lash( $HOME )
calling function ctrlp#utils#opts..<SNR>89_lash('/home/max')

line 1: ^Iretu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''
function ctrlp#utils#opts..<SNR>89_lash returning '/'

continuing in function ctrlp#utils#opts

line 3: ^Ilet cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
line 4: ^Ilet cadir = isdirectory(usrhome.'.ctrlp_cache') ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
calling function ctrlp#utils#opts..<SNR>89_lash('/home/max/.cache')

line 1: ^Iretu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''
function ctrlp#utils#opts..<SNR>89_lash returning '/'

continuing in function ctrlp#utils#opts

line 6: ^Iif exists('g:ctrlp_cache_dir')
line 7: ^I^Ilet cadir = expand(g:ctrlp_cache_dir, 1)
line 8: ^I^Iif isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
line 9: ^I^I^Ilet cadir = cadir.s:lash(cadir).'.ctrlp_cache'
line 10: ^I^Ien
line 11: ^Ien
line 12: ^Ilet s:cache_dir = cadir
function ctrlp#utils#opts returning #0

continuing in /home/max/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim

line 31: 
line 32: let s:wig_cond = v:version > 702 || ( v:version == 702 && has('patch051') )
line 33: " Files and Directories {{{1
line 34: fu! ctrlp#utils#cachedir()
line 37: 
line 38: fu! ctrlp#utils#cachefile(...)
line 43: 
line 44: fu! ctrlp#utils#readfile(file)
line 55: 
line 56: fu! ctrlp#utils#mkdir(dir)
line 62: 
line 63: fu! ctrlp#utils#writecache(lines, ...)
line 68: 
line 69: fu! ctrlp#utils#glob(...)
line 73: 
line 74: fu! ctrlp#utils#globpath(...)
line 77: 
line 78: fu! ctrlp#utils#fnesc(path, type, ...)
line 108: "}}}
line 109: 
line 110: " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
finished sourcing /home/max/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim
continuing in function <SNR>75_mergelists..ctrlp#mrufiles#cachefile
calling function <SNR>75_mergelists..ctrlp#mrufiles#cachefile..ctrlp#utils#cachedir()

line 1: ^Iretu s:cache_dir
function <SNR>75_mergelists..ctrlp#mrufiles#cachefile..ctrlp#utils#cachedir returning '/home/max/.cache/ctrlp'

continuing in function <SNR>75_mergelists..ctrlp#mrufiles#cachefile

calling function <SNR>75_mergelists..ctrlp#mrufiles#cachefile..ctrlp#utils#lash()

line 1: ^Iretu &ssl || !exists('+ssl') ? '/' : '\'
function <SNR>75_mergelists..ctrlp#mrufiles#cachefile..ctrlp#utils#lash returning '/'

continuing in function <SNR>75_mergelists..ctrlp#mrufiles#cachefile

line 3: ^I^Ilet s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
calling function <SNR>75_mergelists..ctrlp#mrufiles#cachefile..ctrlp#utils#lash()

line 1: ^Iretu &ssl || !exists('+ssl') ? '/' : '\'
function <SNR>75_mergelists..ctrlp#mrufiles#cachefile..ctrlp#utils#lash returning '/'

continuing in function <SNR>75_mergelists..ctrlp#mrufiles#cachefile

line 4: ^Ien
line 5: ^Iretu s:cafile
function <SNR>75_mergelists..ctrlp#mrufiles#cachefile returning '/home/max/.cache/ctrlp/mru/cache.txt'

continuing in function <SNR>75_mergelists

calling function <SNR>75_mergelists..ctrlp#utils#readfile('/home/max/.cache/ctrlp/mru/cache.txt')

line 1: ^Iif filereadable(a:file)
line 2: ^I^Ilet data = readfile(a:file)
line 3: ^I^Iif empty(data) || type(data) != 3
line 4: ^I^I^Iunl data
line 5: ^I^I^Ilet data = []
line 6: ^I^Ien
line 7: ^I^Iretu data
function <SNR>75_mergelists..ctrlp#utils#readfile returning ['/home/max/syntastic.log', '/home/ma...ding.txt', '/home/max/gowiki/edit.html']

continuing in function <SNR>75_mergelists

line 2: ^Ical filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
line 3: ^Ilet mrufs = s:mrufs + diskmrufs
line 4: ^Iretu s:chop(mrufs)
calling function <SNR>75_mergelists..<SNR>75_chop(['/home/max/syntastic.log', '/home/ma...ding.txt', '/home/max/gowiki/edit.html'])

line 1: ^Iif len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
line 1:  cal remove(a:mrufs, {s:max}, -1) | en
line 1:  en
line 2: ^Iretu a:mrufs
function <SNR>75_mergelists..<SNR>75_chop returning ['/home/max/syntastic.log', '/home/ma...ding.txt', '/home/max/gowiki/edit.html']

continuing in function <SNR>75_mergelists

function <SNR>75_mergelists returning ['/home/max/syntastic.log', '/home/ma...ding.txt', '/home/max/gowiki/edit.html']

continuing in VimLeavePre Auto commands for "*"

calling function <SNR>75_savetofile(['/home/max/syntastic.log', '/home/ma...ding.txt', '/home/max/gowiki/edit.html'])

line 1: ^Ical ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)
calling function <SNR>75_savetofile..ctrlp#utils#writecache(['/home/max/syntastic.log', '/home/ma...ding.txt', '/home/max/gowiki/edit.html'], '/home/max/.cache/ctrlp/mru', '/home/max/.cache/ctrlp/mru/cache.txt')

line 1: ^Iif isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
calling function <SNR>75_savetofile..ctrlp#utils#writecache..ctrlp#utils#mkdir('/home/max/.cache/ctrlp/mru')

line 1: ^Iif exists('*mkdir') && !isdirectory(a:dir)
line 2: ^I^Isil! cal mkdir(a:dir, 'p')
line 3: ^Ien
line 4: ^Iretu a:dir
function <SNR>75_savetofile..ctrlp#utils#writecache..ctrlp#utils#mkdir returning '/home/max/.cache/ctrlp/mru'

continuing in function <SNR>75_savetofile..ctrlp#utils#writecache

line 2: ^I^Isil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
line 3: ^Ien
function <SNR>75_savetofile..ctrlp#utils#writecache returning #0

continuing in function <SNR>75_savetofile

function <SNR>75_savetofile returning #0

continuing in VimLeavePre Auto commands for "*"

Writing viminfo file "/home/max/.viminfo"
Executing VimLeave Auto commands for "*"
autocommand call s:OnVimLeave()

line 0: call s:OnVimLeave()
calling function <SNR>88_OnVimLeave()

line 1:   py ycm_state.OnVimLeave()
function <SNR>88_OnVimLeave returning #0

continuing in VimLeave Auto commands for "*"
