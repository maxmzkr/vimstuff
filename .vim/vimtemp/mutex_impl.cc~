#include <iostream>
#include <stdexcept>
#include "./thread.h"
#include "./thread_impl.h"
#include "./mutex.h"
#include "./mutex_impl.h"
#include "./cpu_impl.h"

bool mutex::impl::get_locked() { return locked; }

void mutex::impl::set_locked(bool set_locked) { locked = set_locked; }

void mutex::impl::add_blocked_thread(thread::impl* add_thread) {
  blocked_queue.push(add_thread);
}

thread::impl* mutex::impl::get_blocked_thread() {
  thread::impl* blocked_thread = blocked_queue.front();
  blocked_queue.pop();
  return blocked_thread;
}

bool mutex::impl::blocked_thread() { return !blocked_queue.empty(); }

void mutex::impl::unlock() {
  // error checking
  thread::impl* current_thread = thread::impl::self();
  try {
    // if mutex wasn't locked, it shouldn't be unlocked
    if (get_locked() == false) {
      throw 1;
    } else if (get_locker_thread_id() != current_thread->id()) {
      // if mutex was locked by one thread, it shouldn't be unlocked by another
      throw 2;
    }
  }
  catch (int n) {
    if (n == 1) {
	  cpu::impl::release_guard();
	  cpu::interrupt_enable();
      throw std::runtime_error("cannot unlock an unlocked mutex");
    } else if (n == 2) {
	  cpu::impl::release_guard();
	  cpu::interrupt_enable();
      throw std::runtime_error(
          "cannot unlock a mutex locked by another thread");
    }
  }

  if (blocked_thread()) {
    // something is blocked, move to ready queue
    thread::impl* ready_thread = get_blocked_thread();
    thread::impl::add_thread_to_ready_queue(ready_thread);
    set_locked(true);
    set_locker_thread_id(ready_thread->get_id());
  } else {
    // mutex is unlocked, so no thread is the locker thread, no thread should have id = -1
    set_locker_thread_id(-1);

		// change status, check blocked_queue
		set_locked(false);
  }
}

void mutex::impl::set_locker_thread_id(int id) {
  locker_thread_id = id;
}

int mutex::impl::get_locker_thread_id() { return locker_thread_id; }
