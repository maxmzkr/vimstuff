#include <iostream>
#include "./thread.h"
#include "./thread_impl.h"
#include "./cpu.h"
#include "./cpu_impl.h"
#include "./mutex.h"
#include "./mutex_impl.h"

mutex::mutex() {
	impl_ptr = new impl();
}

mutex::~mutex() {
	delete impl_ptr;
}

// use the guard in cpu.h
void mutex::lock() {
  // page 109 of lecture notes
  // we will have yield but we'll have the guard as per pg 109
  cpu::interrupt_disable();

  // check guard
  cpu::impl::get_guard();

  // check status
  if (!impl_ptr->get_locked()) {
    impl_ptr->set_locked(true);

    // save this thread as the one who locked it
    thread::impl* current_thread = thread::impl::self();
    impl_ptr->set_locker_thread_id(current_thread->get_id());

  } else {
    // add thread to blocked_queue
    cpu* current_cpu = cpu::self();
    thread::impl* current_thread = current_cpu->impl_ptr->current_thread();
    impl_ptr->add_blocked_thread(current_thread);

    // switch to next ready thread
    current_thread->set_blocked(true);
    current_cpu->impl_ptr->run_next_thread();
  }

  cpu::impl::release_guard();  // is this how you set guard to 0 ??
  cpu::interrupt_enable();
}

// use the guard in cpu.h
void mutex::unlock() {
  // page 110 of leacture notes
  cpu::interrupt_disable();

  // check guard
  cpu::impl::get_guard();

  impl_ptr->unlock();

  cpu::impl::release_guard();  // is this how you set guard to 0 ??

  cpu::interrupt_enable();
}
