#ifndef CPU_IMPL_H_
#define CPU_IMPL_H_

#include <queue>
#include "./thread.h"

void ipi_interrupt();

void cpu_interrupt();

class cpu::impl {
 public:
  explicit impl(thread::impl* first_thread);
  ~impl();

  // getters

  bool suspended();
  thread::impl* first_thread();
  thread::impl* current_thread();
  int id();

  // setters

  void set_suspended(bool suspended);

  // Set's the current thread and saves the previous thread in the right spot
  // If the previous thread was a cpu::init thread, then it saves it to
  // first_thread
  // Otherwise it saves it to the previous thread's context
  // To return from this, another thread needs to swap back to the previous
  // context
	// Upon returning, the finished_queue is cleared
  void set_current_thread(thread::impl* current_thread, bool first_thread);

	// general purpose functions

  // Checks if there is anything on the ready queue.
  // If there is something on the ready queue, then it set's that as the current
  // thread on the cpu
  // If there is nothing on the ready queue, then it set's the first_thread of
  // the cpu as the current thread on the cpu
  void run_next_thread();

	// Checks if there is a cpu on the cpu queue
	// If there is something on the cpu queue, then it signals it
	// other wise it returns
  static void signal_cpu();

	// Adds the cpu passed to the suspended cpu queue
  static void add_cpu_to_suspended_queue(cpu* suspended_cpu);

  // returns true if the suspened cpu queue is empty
  static bool suspended_queue_empty();

  // returns the top suspended cpu and pops it off
  static cpu* get_cpu_from_suspended_queue();

	// returns the previous value of the guard and sets it to true
  static bool test_set();

  // waits until test_set returns false
  static void get_guard();

  // sets the guard to 0
  static void release_guard();

 private:
	// private memeber variables
  thread::impl* current_thread_;
  thread::impl* first_thread_;
  bool suspended_;
  int id_;

	// private static variables
  static std::queue<cpu*> suspended_queue_;
  static int id_count_;
  static int guard_count_;
};

#endif  // CPU_IMPL_H_
