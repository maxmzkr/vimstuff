
\documentclass{article}
\usepackage[utf8]{luainputenc}
\usepackage{geometry}
\geometry{verbose}
\usepackage{amsmath}
\usepackage{amssymb}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{enumerate}
\usepackage{amsfonts}\usepackage{amsthm}

%%This optional package allows you to use TikZ to typeset automata
%\usepackage{tikz}
%\usetikzlibrary{automata}
%
%%This optional package allows you to use xypic to typeset automata
%\usepackage[all]{xy}
%
%%This optional package allows you to include external graphics
%\usepackage{graphicx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%    FILL THESE FIELDS IN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\name}{Max Mizikar}                     % FILL THIS IN


\newcommand{\hwid}{3}                         % change this as necessary

\newcommand{\duetime}{{11:55pm, Wednesday, March 25}}    % change this as necessary (month/day)


%%%% Header definitions, you may skip down to the beginning of the document

% Course information
\newcommand{\courseNumber}{EECS 376}
\newcommand{\courseTitle}{Foundations of Computer Science}
\newcommand{\semester}{Winter 2015}
\newcommand{\duelocation}{Ctools}

% Problem environment
\newenvironment{problem}[1]{\noindent {\bf (\hwid.#1)}}{}
% Proof-making commands and environments
\newcommand{\beginproof}{\medskip\noindent{\bf Proof.~}}
\newcommand{\beginproofof}[1]{\medskip\noindent{\bf Proof of #1.~}}
\newcommand{\finishproof}{\hspace{0.2ex}\rule{1ex}{1ex}}

% homework header
\newcommand{\hwheader}{
\noindent{\Large\bf Due Time: \duetime\hspace{\stretch{1}} Due at \duelocation\\}
\vspace{1ex}
{\courseNumber, \courseTitle \hspace{\stretch{1}}\semester, University of Michigan, Ann Arbor}\\
\rule{\textwidth}{.2ex}
}

\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}

\makeatother

\begin{document}
\hwheader

\begin{center}
{\Large{}EECS 376 Problem Set \hwid} 
\par\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    YOUR SOLUTIONS SHOULD START HERE%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{enumerate}

\item Let $L:=\{\langle M\rangle:\text{ \ensuremath{M} is a TM and 
$L(M) = \emptyset$}\}$.
	\begin{enumerate}[(a)]
    \item    Show that $L$ is undecidable using a diagonal argument. (\emph{Hint}:
Suppose $A$ is a decider for $L$. Design a TM $B$ so that $B(\langle B\rangle)$
is not well-defined.)

Create a turing machine $B$ that takes input $\langle M \rangle$.
\begin{itemize}
	\item Reject if $M \ne B$ or $A$ rejects $\langle M \rangle$
	\item Accept otherwise
\end{itemize}
Run $B$ on $\langle B \rangle$. Since $B = B$, run $A$ on $\langle B \rangle$. If $A$ accepts, then $B$ is accepted. Otherwise, $A$ rejects and $B$ is rejected.
In the case that $A$ accepts, then $B$ is accepted. This means that the language of $B$ is not the empty set, but $A$ accepting $B$ means that the languge of $B$ is the empty set, which is incoherent.
In the case that $A$ rejects, then $B$ is rejected. This means that $B$ rejects all things not equal to $B$ and $B$. Thus the language is the empty set. However, $A$ rejecting $B$ means that $B$ is not the empty set which is also incoherent.

	\item 	Use Rice's Theorem to show that $L$ is undecidable.

		There exists a turing recognizable language that is not the empty set. For example, the language $\{1\}$ is turing recognizable. There is also a turing recognizable language $\emptyset$ that satisfies the property $\{\emptyset\}$. Both $\{1\}$ and $\emptyset$ are clearly turning recognizable as they are also finite languages. This means that the property is non-trivial. Rice's theorem states that the language of turing machinges that satisfy a non-trivial language is undecidable. Thus $L$ is undecidable.
    \end{enumerate}


\item Let $L:=\{\langle M,x\rangle:\text{ \ensuremath{M} is a TM and \ensuremath{M} halts on input \ensuremath{x} in \ensuremath{2^{|x|}} steps }\}$.
Show that $L$ is decidable. (Hint: Use a Universal Turing Machine
$\mathcal{U}$.)

The algorithm that decides $L$ is as follows.

$L =$ ``On input $\langle M, x \rangle$, where $M$ is a Turing Machine and $x$ is a string:
\begin{enumerate}
	\item Simulate $M$ on $x$ for $2^{|x|}$ steps or until it halts.
	\item If $M$ has halted, \textit{accept} if it has accepted and \textit{reject} if it has rejected. If it has not halted, \textit{reject}.''
\end{enumerate}

If $\langle M, x \rangle$ is in $L$ then $M$ runs on $x$ for no more than $2^{|x|}$ steps. Thus it will halt before finishing the first step. Since $M$ accepts $x$ then it is accepted.\\
If $\langle M, x \rangle$ is accepted by the algorithm, then $M$ must halt on $x$ in less than $2^\{|x|\}$ steps. It also must accept $x$ when it halts.\\
Thus the language accepted by the algorithm is equivalent to $L$.


\item Louis Reasoner writes a program $P$ which he claims can determine
whether or not an input C-language source file $Q$ will reach line
23 of its execution when the compiled program is run with no arguments
or other input. Describe the language decided by $P$, and determine
if Louis' claims are possibly correct. Justify your claim.

This is a turing recognizable language.
The algorithm that recognizes it is the following.\\
$L = $ ``On input $\langle Q \rangle$ where $Q$ is a C-language source file
\begin{enumerate}
	\item Simulate $Q$ until $Q$ reaches line 23 or halts
	\item If $Q$ reaches this line, accept.
	\item If $Q$ halts, then reject''
\end{enumerate}
If $w \in L$ then $w$ will reach line 23 before halting, thus it is accepted when it reaches the line.
If $w$ is accepted by the algorithm, then it reached line 23 before halting.
Thus the language described by the algorithm is equivalent to the language accepted by $P$.

The language is not decidable as you can construct $A_{HALT}$ where $A_{HALT}$ decides the language of programs that halt on empty input. The constuction is as follows.
$L = $ ``On input $\langle Q \rangle$ where $Q$ is a C-language source file
\begin{enumerate}
	\item Construct a new source file $R$ from $Q$. With the following changes.
		\begin{enumerate}
			\item Shift all lines from line 22 on, down 2 lines.
			\item Line 22 becomes GOTO line 24
			\item Line 23 becomes HALT
			\item all lines that halt becomes GOTO line 23.
		\end{enumerate}
	\item Run the decider for programs that reach line 23 on $R$
	\item If $R$ is accepted, accept, else reject.''
\end{enumerate}
If $Q$ was going to halt, then it will now reach line 23 and will be accepted. If $Q$ is in the langague accepted by the algorithm, then it reached line 23 at some point which only happens when $Q$ halts.
Thus, the language described by the algorithm is all C-Programs that halt.
Since C-Programs are just turing machine, it is possible to describe an algoithm that decides all turning machines that halt, which is already proven to be impossible. Thus we have a contradiciton and $P$ must not be decidable.

\item 
	\begin{enumerate}[(a)]
	\item Let $L:=\{\langle M\rangle:\text{ \ensuremath{M} is a TM 
	and \ensuremath{M} halts on input $\varepsilon$}\}$. Show $L$ is undecidable.

To show that $L$ is undecidable, we will show that if $L$ is decidable then we can construct $A_{HALT}$ which is the language of $\langle M, x \rangle$ where $M$ halts on $x$ which is already known to be undecidable.

Let $A$ decide $L$.

$S = $ ``On input $\langle M, x \rangle$ where $M$ is a Turning Machine and $x$ is a string
\begin{enumerate}
	\item Construct a new Turing Machine $M_1$ where on input $\varepsilon$ run $x$ on $M$ and accept if $M$ accepts and reject if $M$ rejects.
	\item Run $A$ on $M_1$
	\item If $A$ accepts, accept, else reject''
\end{enumerate}
Since $L$ is decidable and all $S$ does is run a machine on $A$ it must also be a decider.
If $\langle M, x \rangle$ is accepted by $S$,
then $M$ must halt on $x$ and if $\langle M, x \rangle$ is in $L(A_{HALT})$
If $\langle M, x \rangle$ is in $L(A_{HALT})$ then the new $M_1$ constructed will also halt, thus it will be accepted by $S$.
Thus $S$ is a decided for $A_{HALT}$ which is a contradiction. Thus $L$ must not be decidable.

	\item Let $f:\mathbb{N}\to\mathbb{N}$ be the \emph{busy beaver function}:
$f(n)$ is equal to 
\begin{align*}
\max_{\substack{M\text{ is a TM that halts on blank input}\\
M \text{ has $n$ states}
}
}(\text{ \# of steps of \ensuremath{M}'s execution on blank input }).
\end{align*}
Show that $f$ is not computable. (\emph{Hint}: Suppose $f$ is computable and
use $f$ to create a decider for the language from part (a).)

To show $f$ is not computable, we will show that if $f$ is decidable then we can construct a decider for $L$ which is already known to be undecidable

$S = $ ``On input $\langle M, x \rangle$ where $M$ is a Turning Machine
\begin{enumerate}
	\item Construct a new Turning Machine $M_1$ where on input $\epsilon$ run $x$ on $M$ and accept if $M$ accepts and reject if $M$ rejects.
	\item Let $n$ be the number of states in $M_1$.
	\item Run $M_1$ on $x$ for $f(n)$ steps.
	\item if $M_1$ has not halted, then $M$ will never halt thus, reject.
	\item otherwise accept''
\end{enumerate}

If $M$ halts then $M_1$ must halt in $f(n)$ steps because that is the most number of steps any Turning machine runs for according to the Busy Beaver problem. Thus if $M$ halts, then $M$ will be accepted by $S$.

If $M$ is accepted by $S$ then the $M_1$ constructed halts, thus $M$ must halt also.

Thus, $M$ halts iff $S$ accepts $M$.

This is a contradicition sinc the $L$ is undecidable. Thus the Busy Beaver problem is not decidable.

	\end{enumerate}



\item \begin{enumerate}[(a)]
\item Show that if $L\in P$, then $L^*\in P$ (\emph{Hint}: Use dynamic programming, similar to the proof of Sipser 7.16).

	Let $A$ be the decider for $L$

	$D = $ ``On input $w = w_1 \cdots w_n$:
	\begin{enumerate}
		\item For $w = \epsilon$, accept
		\item For i = 1 to n:
		\item \hspace{0.25cm} For j = 1 to n - i + 1
		\item \hspace{0.25cm} \hspace{0.25cm} h = j - i - 1
		\item \hspace{0.25cm} \hspace{0.25cm} Run $A$ on the substring of $w$ from index $j$ to $h$
		\item \hspace{0.25cm} \hspace{0.25cm} If $A$ accepted then set $table(j, h) = true$
		\item \hspace{0.25cm} \hspace{0.25cm} Else For k = j to h - 1:
		\item \hspace{0.25cm} \hspace{0.25cm} \hspace{0.25cm} If $table(j, k) = true$ and $table(k + 1, h) = true$
		\item \hspace{0.25cm} \hspace{0.25cm} \hspace{0.25cm} Then $table(j, h) = true$
		\item if $table(1, n) = true$ then accept, else reject
	\end{enumerate}

  If $w \in P$ then there is some way to break up $w$ such that $w = w_1 \cdots w_n$ and for all $w_i$, $w_i \in P$. If $w = \epsilon$ Then $w$ in $P^*$. Which the program accepts on line $i$.
  Otherwise all $w_h$ with start index $i$ and end index $j$ are marked as strings in $P$.
  Furthermore, each $w_i$ is joined with all previous $w_1 \cdots w_{i-1}$ by line $ix$. Thus in the end, all $w_i$ are joined marking the whole string as true.
  Thus if $w \in P^*$ then $D$ accepts it.

  Suppose $w$ is accepted by $D$. Then all substrings of $w$ are marked as in $P$ if they are in $P$. All conjuntions of two substrings in $P^*$ are marked as in $P^*$, in the end if the whole string is marked as true then it must be in $P^*$. Thus, all $w$ accepted by $D$ are in $P^*$

  The algorithm is polynomial time. The outer for loop runs $n$ times and the inner loop runs up to $n$ times. The decider $A$ runs for some time $n^k$. Thus the whole algorithm runs in time $n^{k+2}$ time.
\item Show that if $L\in NP$, then $L^*\in NP$.

	Let $A$ be a verifier for $L$

	$D = $ ``On input $w = w_1 \cdots w_n$:
	\begin{enumerate}
		\item For $w = \epsilon$, accept
		\item For i = 1 to n:
		\item \hspace{0.25cm} For j = 1 to n - i + 1
		\item \hspace{0.25cm} \hspace{0.25cm} h = j - i - 1
		\item \hspace{0.25cm} \hspace{0.25cm} Run $A$ on the substring of $w$ from index $j$ to $h$
		\item \hspace{0.25cm} \hspace{0.25cm} If $A$ accepted then set $table(j, h) = true$
		\item \hspace{0.25cm} \hspace{0.25cm} Else For k = j to h - 1:
		\item \hspace{0.25cm} \hspace{0.25cm} \hspace{0.25cm} If $table(j, k) = true$ and $table(k + 1, h) = true$
		\item \hspace{0.25cm} \hspace{0.25cm} \hspace{0.25cm} Then $table(j, h) = true$
		\item if $table(1, n) = true$ then accept, else reject
	\end{enumerate}

  The algorithm in this is almost exactly the same as in a except $A$ is the verifier instead of the decider. The alogorithm accepts only $NP^*$ through similar proof as in a. The algorithm is also polynomial time because $A$ is once again $O(n^k)$.
\end{enumerate}


\item 
Use the fact $CLIQUE \in NP$ to solve the following questions, where
\begin{center}
 $CLIQUE =\{ \left<G, k\right> | \text{$G$ is an undirected graph with a $k$-clique} \} $.
\end{center}

\begin{enumerate}[(a)]
\item A clique in a simple undirected graph $G$ is a complete subgraph of $G$,
 i.e. a subgraph in which each vertex is connected to each other vertex. 
 A maximum clique of a graph $G$ is a clique of maximum possible size for $G$. 
 The \emph{Maximum Clique Problem} asks to find out a maximum clique 
 (not the size of the maximum clique) of $G$.

Prove that $P=NP$ if and only if there is a polynomial time algorithm for
finding a maximum clique of an undirected simple graph.

Finding a maximum clique is NP-Hard.

To show this, we will reduce $CLIQUE$ to maxmimum clique. We know $CLIQUE$ is NP-Complete from te book, thus everything in $NP$ is reducable to it.

To reduce $CLIQUE$ to maximum clique,

$D =$ ``On input $\langle G, k \rangle$
\begin{enumerate}
  \item run maximum clique on $\langle G \rangle$
  \item if the size of maximum clique is less then $k$, reject
  \item if the size of maximum clique is greater than or equal to $k$, accept''
\end{enumerate}

This is clearly a polynomial time conversion as all it does is run the maximum clique and check if it is at least $k$.

If $\langle G, k \rangle$ is accepted by $D$ then there is a clique that is greater than or equal in size to $k$. Thus there is also a clique that is equal to size to $k$ because nodes can be removed from a clique and still form a clique.

If $\langle G, k \rangle$ is in $CLIQUE$, then it must have a clique of size $k$. Thus it's maximum clique is atleast size $k$, thus $D$ will accept it.

Thus, $\langle G, k \rangle$ is accepted by $D$ iff it is in $CLIQUE$. Thus $CLIQUE$ is reducable to maximum clique. This means that if maximum clique has a polynomial time algorithm, then all NP is reducable to a polynomial time algorithm. This would mean that a NP-Complete algorithm, like $CLIQUE$ could be run in polynomial time, which would mean $P = NP$.

\item An \emph{independent set} is a set of vertices in a graph, no two of which are adjacent. The $k$-independent-set problem is defined as follows: Given a graph $G$ and an integer $k\geq 0$, does there exist an independent set in $G$ of size $k$? Prove that $k$-independent-set is $NP$-complete by reducing to it from $CLIQUE$.

  To verify that $G$ has an independent set of $k \ge 0$, check that there are atleast $k$ nodesand that all nodes in teh solution are in $G$, then iterate through each edge in the graph, if the edge connects with two nodes in the solutions, then reject, otherwise accept.

  To reduce $CLIQUE$ to independent set,

  $D = $ ``On input $\langle G, k \rangle$
  \begin{enumerate}
    \item 
  \end{enumerate}

\end{enumerate}

\item The traveling salesman problem is defined as follows: Given a connected (\emph{i.e.} there exists a path between each pair of vertices), weighted graph $G$ and and integer $k$, is there a tour in $G$ of weight at most $k$ that visits each vertex once? In other words, we have the language
$$TSP = \left\{\left<G,k\right>: \text{$G$ has a Hamiltonian cycle of weight $\leq k$}\right\}.$$
Prove that $TSP$ is $NP$-complete. (\emph{Hint}: Reduce from $HAMPATH$.)

\item Consider a set $A=\{a_{1},...,a_{n}\}$ and a collection $B_{1},B_{2},...,B_{m}$
of subsets of $A$ (i.e., $B_{i}\subseteq A$ for each $i$). We say
that a set $H\subseteq A$ is a hitting set for the collection $B_{1},B_{2},...,B_{m}$
if $H$ contains at least one element from each $B_{i}$ —that is,
if $H\cap B_{i}$ is not empty for each $i$ (so $H$ “hits” all the
sets $B_{i}$).

The Hitting Set Problem is defined as follows: Given a set
$A=\{a_{1},...,a_{n}\}$, a collection $B_{1},B_{2},...,B_{m}$ of
subsets of $A$ ,and a number $k$, does there exist a hitting
set $H\subseteq A$ for $B_{1},B_{2},...,B_{m}$ such that the size
of $H$ is at most $k$?

Prove that the Hitting Set Problem is NP-complete.


\end{enumerate}

\end{document}
