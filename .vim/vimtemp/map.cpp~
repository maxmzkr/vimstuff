// Holds the implementation of Map

#include <cassert>
#include <cstdio>
#include <cstring>
#include <vector>
#include <string>
#include <iomanip>
#include <iostream>
#include "./map.h"
#include "./P2random.h"
#include "./eecs281_priority_queue.h"
#include "./heap_priority_queue.h"
#include "./poorman_priority_queue.h"
#include "./sorted_priority_queue.h"
#include "./pairing_priority_queue.h"

void print_map(std::vector<std::vector<Tile *>> & map) {
	printf("\n");
  for (auto row : map) {
    for (auto tile : row) {
			std::cout << std::setw(4) << tile->rubble_size();
    }
    printf("\n");
  }
}

Map::Map() {}

Map::~Map() {
  for (auto row : tiles_) {
    for (auto tile : row) {
      delete tile;
    }
  }
	delete[] filename_;
}

void Map::set_filename(const char * filename_in) {
  delete[] filename_;
  filename_ = new char[strlen(filename_in) + 1];
  snprintf(filename_, strlen(filename_in) + 1, "%s", filename_in);
}

void Map::set_input_mode(char input_mode) {
  assert(input_mode == 'M' || input_mode == 'R');
  input_mode_ = input_mode;
}

void Map::set_output_mode(char output_mode) {
  assert(output_mode == 'S' || output_mode == 'P');
  output_mode_ = output_mode;
}

void Map::set_output_size(int output_size) {
  output_size_ = output_size;
}

void Map::set_queue_type(char * queue_type) {
  if (strcmp(queue_type, "BINARY") == 0) {
    queue_type_ = 0;
  } else if (strcmp(queue_type, "POOR_MAN") == 0) {
    queue_type_ = 1;
  } else if (strcmp(queue_type, "SORTED") == 0) {
    queue_type_ = 2;
  } else if (strcmp(queue_type, "PAIRING") == 0) {
    queue_type_ = 3;
  }
}

void Map::set_size(int size) {
  assert(size > 0);
	tiles_.resize(size);
	for (auto & row : tiles_) {
		row.resize(size);
	}
  size_ = size;
}

void Map::set_start_x(int x) {
  start_x_ = x;
}

void Map::set_start_y(int y) {
  start_y_ = y;
}

void Map::set_tile(int x, int y, int rubble_size) {
  assert(x >= 0);
  assert(y >= 0);
  assert(x < size());
  assert(y < size());
  Tile * new_tile = new Tile(x, y, rubble_size);
  tiles_[x][y] = new_tile;
}

int Map::start_x() const {
  return start_x_;
}

int Map::start_y() const {
  return start_y_;
}

int Map::size() const {
  return size_;
}

char * Map::filename() const {
	return filename_;
}

Tile * Map::next_tile() {
  Tile * next_tile = priority_queue_->top();
  priority_queue_->pop();
  return next_tile;
}

void Map::handle_tnt(int x, int y) {
#ifdef DEBUG
	printf("handling tnt\n");
#endif
  heap_priority_queue<Tile *, TileHarder> binary;
  poorman_priority_queue<Tile *, TileHarder> poor_man;
  sorted_priority_queue<Tile *, TileHarder> sorted;
  pairing_priority_queue<Tile *, TileHarder> pairing;
  if (queue_type_ == 0) {
    tnt_queue_ = &binary;
  } else if (queue_type_ == 1) {
    tnt_queue_ = &poor_man;
  } else if (queue_type_ == 2) {
    tnt_queue_ = &sorted;
  } else {
    tnt_queue_ = &pairing;
  }
  tiles_[y][x]->set_tnt_visited(true);
	tnt_queue_->push(tiles_[y][x]);
	while (!tnt_queue_->empty()) {
    Tile * top_tile = tnt_queue_->top();
    tnt_queue_->pop();
    finish_tile(top_tile->x(), top_tile->y(), true);
	}
#ifdef DEBUG
	printf("done handling tnt\n");
#endif
}

void Map::run() {
  input();
  heap_priority_queue<Tile *, TileHarder> binary;
  poorman_priority_queue<Tile *, TileHarder> poor_man;
  sorted_priority_queue<Tile *, TileHarder> sorted;
  pairing_priority_queue<Tile *, TileHarder> pairing;
  if (queue_type_ == 0) {
    priority_queue_ = &binary;
  } else if (queue_type_ == 1) {
    priority_queue_ = &poor_man;
  } else if (queue_type_ == 2) {
    priority_queue_ = &sorted;
  } else if (queue_type_ == 3) {
    priority_queue_ = &pairing;
  }

  Tile * starting_tile = tiles_[start_y()][start_x()];
  priority_queue_->push(starting_tile);
  starting_tile->set_visited(true);

  while (!priority_queue_->empty()) {
    Tile * top_tile = priority_queue_->top();
    priority_queue_->pop();
    finish_tile(top_tile->x(), top_tile->y(), false);
    if (top_tile->x() == 0) {
      break;
    } else if (top_tile->y() == 0) {
      break;
    } else if (top_tile->x() == size() - 1) {
      break;
    } else if (top_tile->y() == size() - 1) {
      break;
    }
  }
  output();
}

char Map::input_mode() const {
  return input_mode_;
}

char Map::output_mode() const {
  return output_mode_;
}

int Map::output_size() const {
  return output_size_;
}

void Map::input_r(FILE * fileptr) {
  char * line = nullptr;
  size_t len = 0;
	ssize_t read;

  int seed = 0;
  read = getline(&line, &len, fileptr);
  if (read != -1) {
    seed = atoi(&line[6]);
  }

  int max_rubble = 0;
  read = getline(&line, &len, fileptr);
	if (read != -1) {
    max_rubble = atoi(&line[12]);
  }

  int tnt_chance = 0;
  read = getline(&line, &len, fileptr);
	if (read != -1) {
    tnt_chance = atoi(&line[5]);
  }
  P2random::seed_mt(seed);
  for (int y = 0; y < size(); ++y) {
    for (int x = 0; x < size(); ++x) {
      int rubble_size = P2random::generate_tile(max_rubble, tnt_chance);
      Tile * new_tile = new Tile(x, y, rubble_size);
      tiles_[y][x] = new_tile;
    }
  }
}

void Map::input_m(FILE * fileptr) {
  char * line = nullptr;
  size_t len = 0;
	ssize_t read;
  int x = 0;
  int y = 0;
  while ((read = getline(&line, &len, fileptr)) != -1) {
		char * pch = strtok(line, " \t\n");
		if (y >= size()) {
			break;
		}
    while (pch != NULL) {
			if (x >= size()) {
				break;
			}
      int rubble_size = atoi(pch);
      Tile * new_tile = new Tile(x, y, rubble_size);
      tiles_[y][x] = new_tile;
      x = x + 1;
			pch = strtok(nullptr, " \t");
    }
		x = 0;
    y = y + 1;
  }
}

void Map::input() {
  FILE * fileptr;
  char * line = nullptr;
  size_t len = 0;
	ssize_t read;
  fileptr = fopen(filename_, "r");

  read = getline(&line, &len, fileptr);
	if (read != -1) {
    set_input_mode(line[0]);
  }

  read = getline(&line, &len, fileptr);
	if (read != -1) {
    set_size(atoi(&line[6]));
  }

  read = getline(&line, &len, fileptr);
  if (read != -1) {
    char * pch;
    pch = strtok(line, " ");
    pch = strtok(NULL, " ");
    set_start_y(atoi(pch));
    pch = strtok(NULL, " ");
    set_start_x(atoi(pch));
  }

  if (input_mode() == 'M') {
    input_m(fileptr);
  } else {
		input_r(fileptr);
	}

  fclose(fileptr);

#ifdef DEBUG
  print_map(tiles_);
#endif
}

void Map::PushTNTSurrounding(int x, int y) {
  if (y > 0) {
    if (!tiles_[y - 1][x]->tnt_visited()) {
			if (tiles_[y - 1][x]->rubble_size() != 0) {
				tnt_queue_->push(tiles_[y - 1][x]);
				tiles_[y - 1][x]->set_tnt_visited(true);
			}
    }
  }
  if (x > 0) {
    if (!tiles_[y][x - 1]->tnt_visited()) {
			if (tiles_[y][x - 1]->rubble_size() != 0) {
				tnt_queue_->push(tiles_[y][x - 1]);
				tiles_[y][x - 1]->set_tnt_visited(true);
			}
    }
  }
  if (y < size() - 1) {
    if (!tiles_[y + 1][x]->tnt_visited()) {
			if (tiles_[y + 1][x]->rubble_size() != 0) {
				tnt_queue_->push(tiles_[y + 1][x]);
				tiles_[y + 1][x]->set_tnt_visited(true);
			}
    }
  }
  if (x < size() - 1) {
    if (!tiles_[y][x + 1]->tnt_visited()) {
			if (tiles_[y][x + 1]->rubble_size() != 0) {
				tnt_queue_->push(tiles_[y][x + 1]);
				tiles_[y][x + 1]->set_tnt_visited(true);
			}
    }
  }
}

void Map::PushSurrounding(
    int x, int y, eecs281_priority_queue<Tile *, TileHarder> * priority_queue) {
  if (y > 0) {
    if (!tiles_[y - 1][x]->visited()) {
      priority_queue->push(tiles_[y - 1][x]);
      tiles_[y - 1][x]->set_visited(true);
    }
  }
  if (x > 0) {
    if (!tiles_[y][x - 1]->visited()) {
      priority_queue->push(tiles_[y][x - 1]);
      tiles_[y][x - 1]->set_visited(true);
    }
  }
  if (y < size() - 1) {
    if (!tiles_[y + 1][x]->visited()) {
      priority_queue->push(tiles_[y + 1][x]);
      tiles_[y + 1][x]->set_visited(true);
    }
  }
  if (x < size() - 1) {
    if (!tiles_[y][x + 1]->visited()) {
      priority_queue->push(tiles_[y][x + 1]);
      tiles_[y][x + 1]->set_visited(true);
    }
  }
}

void Map::push_surrounding(int x, int y) {
  PushSurrounding(x, y, priority_queue_);
}

void Map::finish_tile(int x, int y, bool tnt) {
  Tile * next_tile = tiles_[y][x];
	bool is_tnt = next_tile->is_tnt();
	if (!tnt & is_tnt) {
		handle_tnt(next_tile->x(), next_tile->y());
		priority_queue_->fix();
	}
  if (!next_tile->is_empty()) {
    tile_order_.push_back(next_tile);
  }
  if (next_tile->is_rubble()) {
    cleared_tiles_ = cleared_tiles_ + 1;
    rubble_amount_ = rubble_amount_ + next_tile->rubble_size();
  }
	if (tnt & is_tnt) {
		PushTNTSurrounding(next_tile->x(), next_tile->y());
	} else if (!tnt) {
		push_surrounding(next_tile->x(), next_tile->y());
	}
  next_tile->set_rubble_size(0);
#ifdef DEBUG
	print_map(tiles_);
#endif
}

void Map::output() {
  printf("Cleared %i tiles containing %lu rubble and escaped.\n", cleared_tiles_, rubble_amount_);
  if (output_mode_ == 'S') {
    for (auto tile : tile_order_) {
      tile->set_rubble_size(tile->initial_rubble_size());
    }
    printf("First tiles cleared:\n");
    for (int i = 0; i < output_size_ && i < static_cast<int>(tile_order_.size()); ++i) {
      Tile * queue_tile = tile_order_[i];
      if (queue_tile->initial_rubble_size() == -1) {
        printf("TNT ");
      } else {
        printf("%i ", queue_tile->initial_rubble_size());
      }
      printf("at [%i,%i]\n", queue_tile->y(), queue_tile->x());
    }
    printf("Last tiles cleared:\n");
    for (int i = tile_order_.size() - 1;
         i >= 0 && i >= static_cast<int>(tile_order_.size()) - output_size_;
         --i) {
      Tile * queue_tile = tile_order_[i];
      if (queue_tile->initial_rubble_size() == -1) {
        printf("TNT ");
      } else {
        printf("%i ", queue_tile->initial_rubble_size());
      }
      printf("at [%i,%i]\n", queue_tile->y(), queue_tile->x());
    }
    eecs281_priority_queue<Tile *, TileHarder> * sorted_order_heap;
    heap_priority_queue<Tile *, TileHarder> binary;
    poorman_priority_queue<Tile *, TileHarder> poor_man;
    sorted_priority_queue<Tile *, TileHarder> sorted;
    pairing_priority_queue<Tile *, TileHarder> pairing;
    if (queue_type_ == 0) {
      sorted_order_heap = &binary;
    } else if (queue_type_ == 1) {
      sorted_order_heap = &poor_man;
    } else if (queue_type_ == 2) {
      sorted_order_heap = &sorted;
    } else {
      sorted_order_heap = &pairing;
    }
    for (auto tile : tile_order_) {
      sorted_order_heap->push(tile);
    }
    std::vector<Tile *> sorted_order;
    while (!sorted_order_heap->empty()) {
      sorted_order.push_back(sorted_order_heap->top());
      sorted_order_heap->pop();
    }
    printf("Easiest tiles cleared:\n");
    for (int i = 0; i < output_size_ && i < static_cast<int>(sorted_order.size()); ++i) {
      Tile * queue_tile = sorted_order[i];
      if (queue_tile->initial_rubble_size() == -1) {
        printf("TNT ");
      } else {
        printf("%i ", queue_tile->initial_rubble_size());
      }
      printf("at [%i,%i]\n", queue_tile->y(), queue_tile->x());
    }
    printf("Hardest tiles cleared:\n");
    for (int i = sorted_order.size() - 1;
         i >= 0 && i >= static_cast<int>(sorted_order.size()) - output_size_;
         --i) {
      Tile * queue_tile = sorted_order[i];
      if (queue_tile->initial_rubble_size() == -1) {
        printf("TNT ");
      } else {
        printf("%i ", queue_tile->initial_rubble_size());
      }
      printf("at [%i,%i]\n", queue_tile->y(), queue_tile->x());
    }
  }
}
