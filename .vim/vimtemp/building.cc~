#include <stdio.h>
#include <string.h>
#include <array>
#include <queue>
#include <vector>
#include <stack>
#include <string>
#include "./building.h"

Building::Building() : human_floor_(-1), human_x_(-1), human_y_(-1),
                       length_(0), mode_('\0'), number_of_floors_(0),
                       routing_mode_('\0') {}

// The following are all getter functions
char Building::human_floor() {
  return human_floor_;
}

int Building::human_x() {
  return human_x_;
}

int Building::human_y() {
  return human_y_;
}

char Building::ring_floor() {
  return ring_floor_;
}

int Building::ring_x() {
  return ring_x_;
}

int Building::ring_y() {
  return ring_y_;
}

int Building::length() {
  return length_;
}

char Building::mode() {
  return mode_;
}

char Building::output_mode() {
  return output_mode_;
}

char Building::number_of_floors() {
  return number_of_floors_;
}

std::vector<Room> Building::rooms() {
  return rooms_;
}

char Building::routing_mode() {
  return routing_mode_;
}

std::queue<Coords> Building::route_queue() {
  return route_queue_;
}

std::stack<Coords> Building::constructed_route() {
  return constructed_route_;
}


// The following are all setter functions
void Building::set_human_floor(char floor) {
  human_floor_ = floor;
}

void Building::set_human_y(int y) {
  human_y_ = y;
}

void Building::set_human_x(int x) {
  human_x_ = x;
}

void Building::set_ring_floor(char floor) {
  ring_floor_ = floor;
}

void Building::set_ring_y(int y) {
  ring_y_ = y;
}

void Building::set_ring_x(int x) {
  ring_x_ = x;
}

// One of the only setters of importance
//
// resizes the length of all the rooms to be equal to the length passed
void Building::set_length(int length) {
  for (std::vector<std::vector<Tile>> &room : rooms_) {
    room.resize(length);
    for (std::vector<Tile> &row: room) {
      row.resize(length);
    }
  }
  length_ = length;
}

void Building::set_mode(char mode) {
  mode_ = mode;
}

void Building::set_output_mode(char mode) {
  output_mode_ = mode;
}

void Building::set_number_of_floors(char number) {
  rooms_.resize(number);
  number_of_floors_ = number;
}

void Building::set_routing_mode(char mode) {
  routing_mode_ = mode;
}

// The following are all generic functions
bool Building::IsInBounds(char floor, int y, int x) {
  if (x >= 0 && x < length() && y >= 0 && y < length() &&
      floor >= 0 && floor < number_of_floors()) {
    return true;
  }
  return false;
}

bool Building::IsValidType(char type) {
	int floor = static_cast<int>(type) - 48;
	if (type == '.' || type == '#' || type == 'S' || type == 'R') {
		return true;
	} else if (floor >= 0 && floor <= 9) {
		return true;
	}
	return false;
}

char Building::SetTilesL() {
  char* line = '\0';
  size_t line_length = 0;
  ssize_t current_line_length;

  // Loops through each line and performs the correct function for
  // setting the values given
  while ((current_line_length = getline(&line, &line_length, stdin)) > 0) {
    if (line[0] == '/') {
      continue;
    } else {
      // Using (, ,, ) to split the characters, find the coords given
      // do this for x y floor and char
      // pch == NULL is used to protect against blank lines
      // this is especially useful for files that end with a blank line
      char * pch;
      pch = strtok(line, "(,)");
      int y = atoi(pch);
      pch = strtok(NULL, "(,)");
      if (pch == NULL) {
        continue;
      }
      int x = atoi(pch);
      pch = strtok(NULL, "(,)");
      char floor = atoi(pch);
      pch = strtok(NULL, "(,)");
      char type = pch[0];
      // This is where the input validity is checked and the human and ring
      // are checked for
			if (!IsInBounds(floor, y, x)) {
				exit(1);
      } else {
        if (type == 'S') {
          human_floor_ = floor;
          human_x_ = x;
          human_y_ = y;
          // This next line is used to show that the first spot should not have
          // a referer
          rooms_[human_floor()][human_y()][human_x()].referer = 'B';
        } else if (type == 'R') {
          ring_floor_ = floor;
          ring_x_ = x;
          ring_y_ = y;
				} else if (!IsValidType(type)) {
					return false;
				}
        rooms_[floor][y][x].type = type;
      }
    }
  }
  if (human_x() == -1 || human_y() == -1 || human_floor() == -1) {
    return 2;
  }
  return 0;
}

char Building::SetTilesM() {
  char* line = '\0';
  size_t line_length = 0;
  ssize_t current_line_length;


  char floor = 0;
  int y = 0;
  // for each line, look at each character and as long as it's valid
  // continue on
  while ((current_line_length = getline(&line, &line_length, stdin)) > 0) {
    if (line[0] == '/') {
      continue;
    } else {
      for (int x = 0; line[x] != '\0' && line[x] != '\n'; x++) {
				char type = line[x];
        if (x > length() - 1) {
          return 1;
        }
        rooms_[floor][y][x].type = type;
        // This is where the input validity is checked and the human and ring
        // are checked for
        if (line[x] == 'S') {
          human_floor_ = floor;
          human_x_ = x;
          human_y_ = y;
          // This next line is used to show that the first spot should not have
          // a referer
          rooms_[human_floor()][human_y()][human_x()].referer = 'B';
        } else if (type == 'R') {
          ring_floor_ = floor;
          ring_x_ = x;
          ring_y_ = y;
				} else if (!IsValidType(type)) {
          exit(1);
        }
      }
      y = y + 1;
      if (y == length()) {
        y = 0;
        y = 0;
        floor = floor + 1;
      }
      if (floor > number_of_floors() - 1) {
        return 3;
      }
    }
  }
  if (human_x() == -1 || human_y() == -1 || human_floor() == -1) {
    return 2;
  }
  return 0;
}

char Building::SetTiles() {
  char* line = '\0';
  size_t line_length = 0;
  ssize_t current_line_length;

  int length = 0;

  // This function only sets the input mode, length, and number of floors
  // it then pawns off the responsibilty of reading in the rest of the file
  // to the correct mode setter
  while ((mode() == '\0' || length == 0 || number_of_floors() == 0) &&
         (current_line_length = getline(&line, &line_length, stdin)) > 0) {
    if (line[0] == '/') {
      continue;
    } else if (mode() == '\0') {
			if (line[0] != 'M' && line[0] != 'L') {
				exit(1);
			}
      set_mode(line[0]);
    } else if (length == 0) {
      length = atoi(line);
    } else if (number_of_floors() == 0) {
      set_number_of_floors(atoi(line));
      set_length(length);
    }
  }
  if (mode() == 'M') {
    return SetTilesM();
  }
  return SetTilesL();
}

Coords Building::NextCoords(Coords coords, char direction) {
	if (direction == 'n') {
		return Coords {coords.floor, coords.y - 1, coords.x};
	} else if (direction == 'e') {
		return Coords {coords.floor, coords.y, coords.x + 1};
	} else if (direction == 's') {
		return Coords {coords.floor, coords.y + 1, coords.x};
	}
	return Coords {coords.floor, coords.y, coords.x - 1};
}

Coords Building::PastCoords(Coords coords, char direction) {
  if (direction == 'n') {
    return NextCoords(coords, 's');
  } else if (direction == 'e') {
    return NextCoords(coords, 'w');
  } else if (direction == 's') {
    return NextCoords(coords, 'n');
  } else if (direction == 'w') {
    return NextCoords(coords, 'e');
  }
  char portal_floor = direction - 48;
  return Coords {portal_floor, coords.y, coords.x};
}

inline Coords Building::DataStructureTop(std::stack<Coords> & stack) {
	return stack.top();
}

inline Coords Building::DataStructureTop(std::queue<Coords> & queue) {
	return queue.front();
}

bool Building::ShouldPushCoords(char floor, int y, int x) {
  if (floor > 9 || floor < 0) {
    return false;
  } else if (floor > number_of_floors() - 1) {
    return false;
  } else if (x > length() - 1 || x < 0) {
    return false;
  } else if (y > length() - 1 || y < 0) {
    return false;
  }
  Tile tile = rooms_[floor][y][x];
  char type = tile.type;
  char referer = tile.referer;
  if (referer != '\0') {
    return false;
  } else if (type == '#') {
    return false;
  }
  return true;
}

template <typename DataStructure>
bool Building::MapPath(DataStructure & data_structure) {
  // push new tiles until you find the ring or run out of tiles to push
	while (!data_structure.empty()) {
		Coords current_coords = DataStructureTop(data_structure);
    data_structure.pop();
		char type = rooms_[current_coords.floor][current_coords.y][current_coords.x].type;
		char alt_floor = type - 48;
    // each tiles has 5 adjacent tiles
    // north east south west and portal
		std::array<Coords, 5> directions = {{
      Coords {current_coords.floor, current_coords.y - 1, current_coords.x},
      Coords {current_coords.floor, current_coords.y, current_coords.x + 1},
      Coords {current_coords.floor, current_coords.y + 1, current_coords.x},
      Coords {current_coords.floor, current_coords.y, current_coords.x - 1},
      Coords {alt_floor, current_coords.y, current_coords.x}
    }};
    char character_floor = current_coords.floor + 48;
    std::array<char, 5> direction_chars = {{'n', 'e', 's', 'w', character_floor}};
    // We are going to go through the 5 tiles and push them if they aren't a
    // wall and they don't have a referer
		for (char i = 0; i < 5; ++i) {
			Coords next_coords = directions[i];
      if (ShouldPushCoords(next_coords.floor, next_coords.y, next_coords.x)) {
        data_structure.push(next_coords);
        char next_type = rooms_[next_coords.floor][next_coords.y][next_coords.x].type;
        rooms_[next_coords.floor][next_coords.y][next_coords.x].referer = direction_chars[i];
        // If the tile is the ring then we can end
        if (next_type == 'R') {
          return true;
        }
      }
		}
#ifdef DEBUG
    PrintVisited();
#endif
	}
	return false;
}

bool Building::FindPath() {
  // pases the correct data structure depending on the mode to map path
  if (routing_mode() == 'S') {
    route_stack_.push(Coords {human_floor(), human_y(), human_x()});
    return MapPath(route_stack_);
  }
  route_queue_.push(Coords {human_floor(), human_y(), human_x()});
  return MapPath(route_queue_);
}

void Building::ConstructPath() {
  Coords coords = Coords {ring_floor(), ring_y(), ring_x()};
  constructed_route_.push(coords);
  // keep going until you find the start
  while (true) {
#ifdef DEBUG
    printf("Contructing current %d, %d, %d\n", coords.floor, coords.y, coords.x);
#endif
    Tile tile = rooms_[coords.floor][coords.y][coords.x];
    char referer = tile.referer;
    Coords next_coords = PastCoords(coords, referer);
    char original_type = rooms_[next_coords.floor][next_coords.y][next_coords.x].type;
    // follow each referer back and then push its coords to the
    // constructed_route
    if (next_coords.floor != coords.floor) {
      rooms_[next_coords.floor][next_coords.y][next_coords.x].type = 'p';
    } else {
      rooms_[next_coords.floor][next_coords.y][next_coords.x].type = referer;
    }
    coords = next_coords;
    constructed_route_.push(coords);
    // End when we are at the start
    if (original_type == 'S') {
      return;
    }
  }
}

void Building::PrintMPath() {
  int i = 0;
  for (auto room : rooms_) {
    printf("//room %d\n", i);
    for (auto row : room) {
      for (auto tile : row) {
        printf("%c", tile.type);
      }
      printf("\n");
    }
    i++;
  }
}

void Building::PrintLPath() {
	printf("//path taken\n");
  while (!constructed_route_.empty()) {
    auto coords = constructed_route_.top();
    constructed_route_.pop();
    char direction = rooms_[coords.floor][coords.y][coords.x].type;
    if (!constructed_route_.empty()) {
      printf("(%d,%d,%d,%c)\n", coords.y, coords.x, coords.floor, direction);
    } else {
      break;
    }
  }
}

void Building::PrintVisited() {
  int i = 0;
  for (auto room : rooms_) {
    printf("//room %d\n", i);
    for (auto row : room) {
      for (auto tile : row) {
        if (tile.referer != '\0') {
          printf("%c", tile.referer);
        } else {
          printf("%c", tile.type);
        }
      }
      printf("\n");
    }
    i++;
  }
}

void Building::PrintPath() {
	printf("%d\n", length());
	printf("%d\n", number_of_floors());
  if (output_mode() == 'M') {
    PrintMPath();
  } else {
    PrintLPath();
  }
}
