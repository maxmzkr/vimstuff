#ifndef HEAP_PRIORITY_QUEUE_H_
#define HEAP_PRIORITY_QUEUE_H_

#include <functional>
#include <vector>

#include "./eecs281_priority_queue.h"

// A specialized version of the 'priority_queue' ADT implemented as a binary priority_queue.
template<typename TYPE, typename COMP_FUNCTOR = std::less<TYPE>>
class heap_priority_queue : public eecs281_priority_queue<TYPE, COMP_FUNCTOR> {
 public:
  typedef unsigned size_type;

  // Description: Construct a priority_queue out of an iterator range with an optional
  //              comparison functor.
  // Runtime: O(n) where n is number of elements in range.
  template<typename InputIterator>
  heap_priority_queue(InputIterator start, InputIterator end, COMP_FUNCTOR comp = COMP_FUNCTOR());

  // Description: Construct an empty priority_queue with an optional comparison functor.
  // Runtime: O(1)
  explicit heap_priority_queue(COMP_FUNCTOR comp = COMP_FUNCTOR());

  // Description: Assumes that all elements inside the priority_queue are out of order and
  //              'rebuilds' the priority_queue by fixing the priority_queue invariant.
  // Runtime: O(n)
  virtual void fix();

  // Description: Add a new element to the priority_queue.
  // Runtime: O(log(n))
  virtual void push(const TYPE& val);

  // Description: Remove the most extreme (defined by 'compare') element from
  //              the priority_queue.
  // Note: We will not run tests on your code that would require it to pop an
  // element when the priority_queue is empty. Though you are welcome to if you are
  // familiar with them, you do not need to use exceptions in this project.
  // Runtime: O(log(n))
  virtual void pop();

  // Description: Return the most extreme (defined by 'compare') element of
  //             the priority_queue.
  // Runtime: O(1)
  virtual const TYPE& top() const;

  // Description: Get the number of elements in the priority_queue.
  // Runtime: O(1)
  virtual size_type size() const {
    return data.size();
  }

  // Description: Return true if the priority_queue is empty.
  // Runtime: O(1)
  virtual bool empty() const {
    return data.empty();
  }

 private:
  // Note: This vector *must* be used your priority_queue implementation.
  std::vector<TYPE> data;

 private:
  void swap_elems(int i, int j) {
    TYPE temp = data[i];
    data[i] = data[j];
    data[j] = temp;
    return;
  }

  void fix_down(unsigned int i) {
    if (i*2 >= size()) {
      return;
    }
    unsigned int left = i*2 + 1;
    unsigned int right = i*2 + 2;
    unsigned int smallest = i;
    if (left < size() && this->compare(data[smallest], data[left])) {
      smallest = left;
    }
    if (right < size() && this->compare(data[smallest], data[right])) {
      smallest = right;
    }
    if (smallest != i) {
      swap_elems(i, smallest);
      fix_down(smallest);
    } else {
      return;
    }
  }

  void heapify() {
    int length = size();
    for (int i = length/2 - 1; i >= 0; --i) {
      fix_down(i);
    }
  }

  void fix_up(int i) {
		int parent = (i - 1)/2;
		if (i == parent || !this->compare(data[parent], data[i])) {
			return;
		}
		swap_elems(i, parent);
		fix_up(parent);
	}

  void fix(int i);
};

template<typename TYPE, typename COMP_FUNCTOR>
template<typename InputIterator>
heap_priority_queue<TYPE, COMP_FUNCTOR>::heap_priority_queue(
    InputIterator start, InputIterator end, COMP_FUNCTOR comp) {
  data.assign(start, end);
  this->compare = comp;
  fix();
}

template<typename TYPE, typename COMP_FUNCTOR>
heap_priority_queue<TYPE, COMP_FUNCTOR>::heap_priority_queue(COMP_FUNCTOR comp) {
	this->compare = comp;
}

template<typename TYPE, typename COMP_FUNCTOR>
void heap_priority_queue<TYPE, COMP_FUNCTOR>::fix() {
	heapify();
}

template<typename TYPE, typename COMP_FUNCTOR>
void heap_priority_queue<TYPE, COMP_FUNCTOR>::push(const TYPE& val) {
	data.push_back(val);
	fix_up(size() - 1);
}

template<typename TYPE, typename COMP_FUNCTOR>
void heap_priority_queue<TYPE, COMP_FUNCTOR>::pop() {
	int length = size() - 1;
	swap_elems(0, length);
	data.pop_back();
	fix_down(0);
}

template<typename TYPE, typename COMP_FUNCTOR>
const TYPE& heap_priority_queue<TYPE, COMP_FUNCTOR>::top() const {
	return data[0];
}

#endif  // HEAP_PRIORITY_QUEUE_H_

