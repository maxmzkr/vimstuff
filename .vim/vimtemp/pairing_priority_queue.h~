#ifndef PAIRING_PRIORITY_QUEUE_H_
#define PAIRING_PRIORITY_QUEUE_H_

#include <iostream>
#include <functional>
#include <vector>
#include <cassert>
#include "./eecs281_priority_queue.h"

// A specialized version of the 'priority_queue' ADT implemented as a pairing priority_queue.
template<typename TYPE, typename COMP_FUNCTOR = std::less<TYPE>>
class pairing_priority_queue : public eecs281_priority_queue<TYPE, COMP_FUNCTOR> {
 public:
  typedef unsigned size_type;

  // Description: Construct a priority_queue out of an iterator range with an optional
  //              comparison functor.
  // Runtime: O(n) where n is number of elements in range.
  template<typename InputIterator>
  pairing_priority_queue(
			InputIterator start, InputIterator end, COMP_FUNCTOR comp = COMP_FUNCTOR());

  // Description: Construct an empty priority_queue with an optional comparison functor.
  // Runtime: O(1)
  pairing_priority_queue(COMP_FUNCTOR comp = COMP_FUNCTOR());

  // Description: Copy constructor.
  // Runtime: O(n)
  pairing_priority_queue(const pairing_priority_queue& other);

  // Description: Copy assignment operator.
  // Runtime: O(n)
  pairing_priority_queue& operator=(const pairing_priority_queue& rhs);

  // Description: Destructor
  // Runtime: O(n)
  ~pairing_priority_queue();

  // Description: Assumes that all elements inside the priority_queue are out of order and
  //              'rebuilds' the priority_queue by fixing the priority_queue invariant.
  // Runtime: O(n)
  virtual void fix();

  // Description: Add a new element to the priority_queue. This has been provided for you,
  //              in that you should implement push functionality in the
  //              add_node function.
  // Runtime: Amortized O(1)
  virtual void push(const TYPE& val) { add_node(val); }

  // Description: Remove the most extreme (defined by 'compare') element from
  //              the priority_queue.
  // Note: We will not run tests on your code that would require it to pop an
  // element when the priority_queue is empty. Though you are welcome to if you are
  // familiar with them, you do not need to use exceptions in this project.
  // Runtime: Amortized O(log(n))
  virtual void pop();

  // Description: Return the most extreme (defined by 'compare') element of
  //              the priority_queue.
  // Runtime: O(1)
  virtual const TYPE& top() const;

  // Description: Get the number of elements in the priority_queue.
  // Runtime: O(1)
  virtual size_type size() const {return size_;}

  // Description: Return true if the priority_queue is empty.
  // Runtime: O(1)
  virtual bool empty() const {return size_ == 0;}

  class Node {
    // This node class will allow external users to update the priority of
    // elements that are already inside the priority_queue.
   public:
		explicit Node(const TYPE& val) {
			elt = val;
	  }

		Node() { }

   public:
    // Description: Allows access to the element at that Node's position.
    // Runtime: O(1) - this has been provided for you.
    const TYPE& operator*() const { return elt; }

    // The following line allows you to access any private data members of this
    // Node class from within the pairing_priority_queue class. (ie: myNode.elt is a legal
    // statement in pairing_priority_queue's add_node() function).
    friend pairing_priority_queue;

   private:
    TYPE elt;

   private:
    // ***Add any additional member functions or data you require here.
		Node * child = nullptr;
		Node * next = nullptr;
		Node * previous = nullptr;
  };

  // Description: Updates the priority of an element already in the priority_queue by
  //              replacing the element refered to by the Node with new_value.
  //              Must maintain priority_queue invariants.
  //
  // PRECONDITION: The new priority, given by 'new_value' must be more extreme
  //               (as defined by comp) than the old priority.
  //
  // Runtime: As discussed in reading material.
  void updateElt(Node* node, const TYPE &new_value);

  // Description: Add a new element to the priority_queue. Returns a Node* corresponding
  //              to the newly added element.
  // Runtime: Amortized O(1)
  Node* add_node(const TYPE& val);

 private:
  // ***Add any additional member functions or data you require here.
  // ***We recommend creating a 'meld' function (see the reading).
	unsigned int size_ = 0;
	Node * root_ = nullptr;

	// Can only separate leaf nodes
	void separate(Node * separate_node) {
		// Root node
		assert(separate_node->child == nullptr);
		if (separate_node == nullptr) {
			return;
		}
		Node * previous_node = separate_node->previous;
		Node * next_node = separate_node->next;
		if (previous_node != nullptr) {
			if (previous_node->child == separate_node) {
				previous_node->child = next_node;
				assert(root_->child != separate_node);
			} else {
				previous_node->next = next_node;
				assert(root_->child != separate_node);
			}
			assert(root_->child != separate_node);
		}
		if (next_node != nullptr) {
			next_node->previous = previous_node;
		}
		assert(root_->child != separate_node);
	  separate_node->child = nullptr;
		separate_node->previous = nullptr;
		separate_node->next = nullptr;
	}

	// Push node should have no next or previous
	// Base node should have no next or previous
	void push_front(Node * base_node, Node * push_node) {
		assert(base_node->next == nullptr);
		assert(base_node->previous == nullptr);
		assert(push_node->next == nullptr);
		assert(push_node->previous == nullptr);
		assert(base_node->child != push_node);
		Node * child_node = base_node->child;
		if (child_node != nullptr) {
			push_node->next = child_node;
			child_node->previous = push_node;
		}
		push_node->previous = base_node;
		base_node->child = push_node;
		assert(base_node->next != base_node);
		assert(push_node->next != push_node);
	}

	// meld_node should have no next or previous
	// base_node should have no next or previous
	void meld(Node * &base_node, Node * meld_node) {
		assert(base_node->next == nullptr);
		assert(base_node->previous == nullptr);
		assert(meld_node->next == nullptr);
		assert(meld_node->previous == nullptr);
		if (base_node == nullptr) {
			base_node = meld_node;
		} else {
			if (this->compare(meld_node->elt, base_node->elt)) {
				push_front(base_node, meld_node);
				assert(meld_node->previous == base_node);
			} else {
				push_front(meld_node, base_node);
				assert(base_node->previous == meld_node);
				if (base_node == root_) {
					base_node = meld_node;
					assert(root_ == meld_node);
				} else {
					base_node = meld_node;
				}
			}
		}
		assert(base_node->next != base_node);
		assert(base_node->previous != base_node);
		assert(base_node->child != base_node);
		assert(meld_node->next != meld_node);
		assert(meld_node->previous != meld_node);
		assert(meld_node->child != meld_node);
	}

	// separates all the children nodes, recurse, and pushes them back in
	void push_children(Node * & remerge_node) {
		assert(remerge_node != nullptr);
		Node * child = remerge_node->child;
		Node * next_child = nullptr;
		if (child != nullptr) {
			next_child = child->next;
			push_children(child);
		}

		while (next_child != nullptr) {
			child = next_child;
			next_child = child->next;
			push_children(child);
		}

		separate(remerge_node);
		assert(root_->child != remerge_node);
		meld(root_, remerge_node);
		assert(remerge_node->next != remerge_node);
		assert(remerge_node->previous != remerge_node);
		assert(remerge_node->child != remerge_node);
	}

	void copy_elms(Node * copy_node, Node * copy_to_node) {
    assert(copy_to_node != nullptr);
		if (copy_node == nullptr) {
			copy_to_node = nullptr;
			return;
		}
		copy_to_node->elt = copy_node->elt;
		if (copy_node->child != nullptr) {
      if (copy_to_node->child == nullptr) {
        copy_to_node->child = new Node();
        copy_elms(copy_node->child, copy_to_node->child);
      }
      copy_to_node->child->previous = copy_to_node;
		}
		if (copy_node->next != nullptr) {
      if (copy_to_node->next == nullptr) {
        copy_to_node->next = new Node();
        copy_elms(copy_node->next, copy_to_node->next);
      }
      copy_to_node->next->previous = copy_to_node;
		}
	}

	void delete_children(Node * & delete_node) {
		if (delete_node == nullptr) {
			return;
		}

		if (delete_node->child != nullptr) {
			delete_children(delete_node->child);
		}

		if (delete_node->next != nullptr) {
			delete_children(delete_node->next);
		}

		delete delete_node;
		delete_node = nullptr;
	}
};

template<typename TYPE, typename COMP_FUNCTOR>
template<typename InputIterator>
pairing_priority_queue<TYPE, COMP_FUNCTOR>::pairing_priority_queue(
		InputIterator start, InputIterator end, COMP_FUNCTOR comp) {
	while (start != end) {
		push(*start);
		start++;
	}
	this->compare = comp;
}

template<typename TYPE, typename COMP_FUNCTOR>
pairing_priority_queue<TYPE, COMP_FUNCTOR>::pairing_priority_queue(COMP_FUNCTOR comp) {
	this->compare = comp;
}

template<typename TYPE, typename COMP_FUNCTOR>
pairing_priority_queue<TYPE, COMP_FUNCTOR>::pairing_priority_queue(
		const pairing_priority_queue& other) {
  root_ = new Node();
	copy_elms(other.root_, root_);
	size_ = other.size_;
}

template<typename TYPE, typename COMP_FUNCTOR>
pairing_priority_queue<TYPE, COMP_FUNCTOR>&
pairing_priority_queue<TYPE, COMP_FUNCTOR>::operator=(const pairing_priority_queue& rhs) {
	return pairing_priority_queue(rhs);
}

template<typename TYPE, typename COMP_FUNCTOR>
pairing_priority_queue<TYPE, COMP_FUNCTOR>::~pairing_priority_queue() {
	delete_children(root_);
}

template<typename TYPE, typename COMP_FUNCTOR>
void pairing_priority_queue<TYPE, COMP_FUNCTOR>::fix() {
	if (root_ != nullptr) {
		Node * child = root_->child;
		while (child != nullptr) {
			Node * next_child = child->next;
			push_children(child);
			child = next_child;
		}
	}
}

template<typename TYPE, typename COMP_FUNCTOR>
void pairing_priority_queue<TYPE, COMP_FUNCTOR>::pop() {
	Node * child = root_->child;
	delete root_;
	root_ = child;
	if (root_ != nullptr) {
		child = root_->next;
		root_->next = nullptr;
		root_->previous = nullptr;
	}
	while (child != nullptr) {
		Node * next_child = child->next;
		child->next = nullptr;
		child->previous = nullptr;
		meld(root_, child);
		child = next_child;
	}
	size_ = size_ - 1;
}

template<typename TYPE, typename COMP_FUNCTOR>
const TYPE& pairing_priority_queue<TYPE, COMP_FUNCTOR>::top() const {
	return root_->elt;
}

template<typename TYPE, typename COMP_FUNCTOR>
typename pairing_priority_queue<TYPE, COMP_FUNCTOR>::Node*
pairing_priority_queue<TYPE, COMP_FUNCTOR>::add_node(const TYPE& val) {
	Node * push_node = new Node(val);
	if (root_ == nullptr) {
		root_ = push_node;
	} else {
		meld(root_, push_node);
	}
	size_ = size_ + 1;
	return push_node;
}

template<typename TYPE, typename COMP_FUNCTOR>
void pairing_priority_queue<TYPE, COMP_FUNCTOR>::updateElt(Node* node, const TYPE &new_value) {
	// node is root
	if (node == root_) {
		node->elt = new_value;
		return;
	}
	// node is first child
  node->elt = new_value;
  Node * next_node = node->next;
  Node * previous_node = node->previous;
  if (next_node != nullptr) {
    next_node->previous = previous_node;
  }
	if (previous_node->child == node) {
		previous_node->child = next_node;
	} else {
    previous_node->next = next_node;
  }
  node->next = nullptr;
  node->previous = nullptr;
  meld(root_, node);
	return;
}

#endif  // PAIRING_PRIORITY_QUEUE_H_
