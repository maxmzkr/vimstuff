import os.path
import multiprocessing
import time
import calendar

import deepy.cfg
import deepy.store

def glob_target(target):
    dirname = os.path.dirname(target)
    fns = deepy.store.ls_dir_remote(dirname)

    return fns

def collect_rule_index(name_rdict):
    name, rdict = name_rdict

    out = {}

    queries = rdict.get('queries')
    first_query_target = None
    if queries:
        if type(queries) == type({}):
            qvals = queries.values()
            if qvals:
                qvals.sort()
                first_query = qvals[0]
                first_query_target = first_query.get('target')

    # cubes
    target = rdict.get('target')
    format_args = rdict.get('format_args')
    location = None
    if format_args:
        location = format_args.get('location')

    # cube
    if target:
        meta = rdict.get('meta')
        cube_id = None
        if meta:
            cube_id = meta['cube_id']

        time_step = rdict.get('time_step')
        make_time_step = rdict.get('make_time_step')
        if make_time_step is None:
            make_time_step = time_step

        fns = glob_target(target)
        out =  {'target': target,
                'filenames': fns,
                'time_step': time_step,
                'make_time_step': make_time_step,
                'cube_id': cube_id}

     # bundle 2
    elif location:
        #print 'location', rdict['format_args']['location']
        pass

    # bundle 2a
    elif first_query_target:
        target = first_query_target

        fns = glob_target(target)

        out =  {'target': target,
                'filenames': fns,
                'make_time_step': rdict['make_time_step']}

    else:
        pass
        # FIXME add bundle1

    if out:
        if 'top_list' not in target:
            parse_files(out)

    return name, out

def parse_files(index):
    # sort files
    # find start and end of files
    filenames = index['filenames']

    def is_good(fn):
        return fn.endswith('.h5') or fn.endswith('.npz')
    filenames = filter(is_good, filenames)
    filenames.sort()

    target = index['target']
    time_format, ext = os.path.splitext(os.path.basename(target))

    times = []
    for f in filenames:
        fbase, ext = os.path.splitext(os.path.basename(f))

        try:
            stime = time.strptime(fbase, time_format)
        except Exception,e:
            msg = 'parse_file.bad: {} {} {}'.format(f, time_format, str(e))
            deepy.log.error(msg)
            continue

        secs = calendar.timegm(stime)
        times.append(secs)
    times.sort()

    # calculate file times
    # FIXME calculate missing holes within files?
    if times:
        mts = index['make_time_step']
        if mts != 'month':
            missing = []
            for t in range(times[0], times[-1], mts):
                if t not in times:
                    missing.append(t)
            index['missing'] = missing

    index['times'] = times
    del index['filenames'] # too big

def collect_index(serial=False):
    out = {}
    rules_db = deepy.build.deepy_util.construct_rules()
    if serial:
        out = {}
        for name, rdict in rules_db.iteritems():
            _name, res = collect_rule_index((name, rdict))[1]
            out[name] = res
    else:
        concurrency = len(rules_db)
        pool = multiprocessing.Pool(concurrency)
        results = pool.map(collect_rule_index, rules_db)

        for name, i in results:
            out[name] = i

    return out

def make_index(did, serial=False, show=False):
    # deepy.cfg.init(did)
    # index = collect_index(serial)

    # if show:
    #     import json
    #     print json.dumps(index, indent=2)
    index = {}

    deepy.store.simple_save_json(index, deepy.cfg.data_index, deployment_id=did, force_remote='s3')

