#include <sys/types.h>
#include <cassert>
#include <iostream>
#include "./clock.h"
#include "./os_page_table.h"
#include "./os_page_table_holder.h"
#include "./page_information_table.h"
#include "./vm_arena.h"
#include "./vm_pager.h"

void vm_init(unsigned int memory_pages, unsigned int disk_blocks) {
  clock::init();
  Pit::set_memory_pages(memory_pages);
  Pit::set_disk_blocks(disk_blocks);
}

void vm_create(pid_t pid) {
  page_table_t *page_table = new page_table_t();
  //Creates shadow page
  OSPageTable *os_page_table = new OSPageTable(page_table, pid);

  for (unsigned int i = 0; i < VM_ARENA_SIZE / VM_PAGESIZE; ++i) {
    page_table->ptes[i].read_enable = 0;
    page_table->ptes[i].write_enable = 0;
  }

  OSPageTableHolder::add_page_table(pid, os_page_table);
}

void vm_switch(pid_t pid) {
  OSPageTableHolder::set_current_pid(pid);
  page_table_base_register =
      OSPageTableHolder::get_current_page_table()->page_table_base_register();
}

int vm_fault(void *addr, bool write_flag) {
  OSPageTable *os_page_table = OSPageTableHolder::get_current_page_table();
  Pie *physical_page = os_page_table->get_pie(addr);

  if (physical_page == nullptr) {
    return -1;
  }

  switch (physical_page->state()) {
    case Pie::INIT:
      clock::place(physical_page);
      physical_page->zero_fill();

      if (write_flag) {
        physical_page->set_state(Pie::DIRTY);
      } else {
        physical_page->set_state(Pie::REF_NO_TOUCH);
      }
      break;

    case Pie::REF_NO_TOUCH:
      if (write_flag) {
        physical_page->set_state(Pie::DIRTY);
      } else {
        assert(false);
      }
      break;

    case Pie::NO_REF_NO_TOUCH:
      if (write_flag) {
        physical_page->set_state(Pie::DIRTY);
      } else {
        physical_page->set_state(Pie::REF_NO_TOUCH);
      }
      break;

    case Pie::REF:
      if (write_flag) {
        physical_page->set_state(Pie::DIRTY);
      } else {
        assert(false);
      }
      break;

    case Pie::NO_REF:
      if (write_flag) {
        physical_page->set_state(Pie::DIRTY);
      } else {
        physical_page->set_state(Pie::REF);
      }
      break;

    case Pie::NO_REF_DIRTY:
      // R/W to Dirty
      physical_page->set_state(Pie::DIRTY);
      break;

    case Pie::EVICT:
      physical_page->load_page();

      if (write_flag) {
        physical_page->set_state(Pie::DIRTY);
      } else {
        physical_page->set_state(Pie::REF);
      }
      break;

    default:
      assert(false);
      break;
  }

  return 0;
}

void vm_destroy() {
  OSPageTable *os_page_table = OSPageTableHolder::get_current_page_table();

  delete os_page_table;
}

void *vm_extend(unsigned int share_id) {
  OSPageTable *curr_page = OSPageTableHolder::get_current_page_table();
  return curr_page->extend(share_id);
}

int vm_syslog(void *message, size_t len) {
  OSPageTable* curr_page = OSPageTableHolder::get_current_page_table();
  //TODO: Code Cleanup
  if (len == 0) {
    return -1;
  }

  // check message is in areana
  if (!((uintptr_t)message >= (uintptr_t)VM_ARENA_BASEADDR &&
      (uintptr_t)message < (uintptr_t)VM_ARENA_BASEADDR + VM_ARENA_SIZE)) {
    return -1;
  }

  void* start = (void*)((((intptr_t)message) / VM_PAGESIZE) * VM_PAGESIZE);
  Pie* start_pie = curr_page->get_pie(start);

  // check length based on (areana_end - message) >= len
  if (!(((uintptr_t)VM_ARENA_BASEADDR + VM_ARENA_SIZE - (uintptr_t)message) >= len)) {
    return -1;
  }

  void* end = (void*)((((intptr_t)message + len - 1) / VM_PAGESIZE) * VM_PAGESIZE);
  Pie* end_pie = curr_page->get_pie(end);

  // check if message to message is a valid grouping
  if (start_pie == nullptr || end_pie == nullptr)
    return -1;

  std::string s;
  Pie* curr_pie;
  void* ppage_ptr;
  for (size_t i = 0; i < len; i++) {
    // Get offset for each physical page
    void* curr_addr = (void*)((intptr_t)message + i);
    size_t offset = ((intptr_t) message + i) % VM_PAGESIZE;
    // Get new Pie if offset is 0 or start of loop
    if (offset == 0 || i == 0) {
      curr_pie = curr_page->get_pie(curr_addr);
      if (curr_pie->get_read_from_state() == 0U) {
        vm_fault(curr_addr, false);
      }
      ppage_ptr = curr_pie->get_ppage_ptr();
    }

    // Concatinate value at current Pie's (ppage_ptr + offset) to string
    s += *((char*)ppage_ptr + offset);
  }
  std::cout << "syslog\t\t\t" << s << std::endl;
  return 0;
}
