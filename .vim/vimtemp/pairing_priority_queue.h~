#ifndef PAIRING_PRIORITY_QUEUE_H_
#define PAIRING_PRIORITY_QUEUE_H_

#include <functional>
#include "./eecs281_priority_queue.h"

// A specialized version of the 'priority_queue' ADT implemented as a pairing priority_queue.
template<typename TYPE, typename COMP_FUNCTOR = std::less<TYPE>>
class pairing_priority_queue : public eecs281_priority_queue<TYPE, COMP_FUNCTOR> {
 public:
  typedef unsigned size_type;

  // Description: Construct a priority_queue out of an iterator range with an optional
  //              comparison functor.
  // Runtime: O(n) where n is number of elements in range.
  template<typename InputIterator>
  pairing_priority_queue(
      InputIterator start, InputIterator end, COMP_FUNCTOR comp = COMP_FUNCTOR());

  // Description: Construct an empty priority_queue with an optional comparison functor.
  // Runtime: O(1)
  explicit pairing_priority_queue(COMP_FUNCTOR comp = COMP_FUNCTOR());

  // Description: Copy constructor.
  // Runtime: O(n)
  pairing_priority_queue(const pairing_priority_queue& other);

  // Description: Copy assignment operator.
  // Runtime: O(n)
  pairing_priority_queue& operator=(const pairing_priority_queue& rhs);

  // Description: Destructor
  // Runtime: O(n)
  ~pairing_priority_queue();

  // Description: Assumes that all elements inside the priority_queue are out of order and
  //              'rebuilds' the priority_queue by fixing the priority_queue invariant.
  // Runtime: O(n)
  virtual void fix();

  // Description: Add a new element to the priority_queue. This has been provided for you,
  //              in that you should implement push functionality in the
  //              add_node function.
  // Runtime: Amortized O(1)
  virtual void push(const TYPE& val) {
    add_node(val);
  }

  // Description: Remove the most extreme (defined by 'compare') element from
  //              the priority_queue.
  // Note: We will not run tests on your code that would require it to pop an
  // element when the priority_queue is empty. Though you are welcome to if you are
  // familiar with them, you do not need to use exceptions in this project.
  // Runtime: Amortized O(log(n))
  virtual void pop();

  // Description: Return the most extreme (defined by 'compare') element of
  //              the priority_queue.
  // Runtime: O(1)
  virtual const TYPE& top() const;

  // Description: Get the number of elements in the priority_queue.
  // Runtime: O(1)
  virtual size_type size() const {
    return size_;
  }

  // Description: Return true if the priority_queue is empty.
  // Runtime: O(1)
  virtual bool empty() const {
    return size() == 0;
  }

  class Node {
    // This node class will allow external users to update the priority of
    // elements that are already inside the priority_queue.

   public:
    explicit Node(TYPE val) {
     elt = val;
    }

   public:
    // Description: Allows access to the element at that Node's position.
    // Runtime: O(1) - this has been provided for you.
    const TYPE& operator*() const { return elt; }

    // The following line allows you to access any private data members of this
    // Node class from within the pairing_priority_queue class. (ie: myNode.elt is a legal
    // statement in pairing_priority_queue's add_node() function).
    friend pairing_priority_queue;

   private:
    TYPE elt;

   private:
    Node * previous = nullptr;
    Node * next = nullptr;
    Node * child = nullptr;
  };

  // Description: Updates the priority of an element already in the priority_queue by
  //              replacing the element refered to by the Node with new_value.
  //              Must maintain priority_queue invariants.
  //
  // PRECONDITION: The new priority, given by 'new_value' must be more extreme
  //               (as defined by comp) than the old priority.
  //
  // Runtime: As discussed in reading material.
  // Your code.
  // Your code.
  void updateElt(Node* node, const TYPE &new_value);

  // Description: Add a new element to the priority_queue. Returns a Node* corresponding
  //              to the newly added element.
  // Runtime: Amortized O(1)
  Node* add_node(const TYPE& val);

 private:
  int size_ = 0;
  Node * root_ = nullptr;

  void copy_children_nodes(Node * new_parent_node, Node * copy_node) {
    Node * copy_child = copy_node->child;
    if (copy_child != nullptr) {
      Node * new_child = new Node(copy_child->elt);
      new_parent_node->child = new_child;
      new_child->previous = new_parent_node;
      copy_next_nodes(new_child, copy_child);
      Node * copy_next_node = copy_child->next;
      while (copy_next_node != nullptr) {
        Node * new_next_node = new Node(copy_next_node->elt);
        new_next_node->previous = new_child;
        new_child->next = new_next_node;
        new_child = new_next_node;
        copy_children_nodes(new_next_node, copy_next_node);
        copy_next_node = copy_next_node->next;
      }
    }
  }

  void meld(Node * parent_node_1, Node * parent_node_2) {
    Node * new_top;
    Node * new_child;
    Node * past_child;
    if (this->compare(parent_node_1->elt, parent_node_2->elt)) {
      new_top = parent_node_2;
      new_child = parent_node_1;
    } else {
      new_top = parent_node_1;
      new_child = parent_node_2;
    }
    root_ = new_top;
    past_child = new_top->child;
    new_top->child = new_child;
    new_child->next = past_child;
		if (new_child->next != nullptr) {
			new_child->next->previous = new_child;
		}
    new_child->previous = new_top;
  }

  void delete_children(Node * parent_node) {
    Node * child = parent_node->child;
    while (child != nullptr) {
      delete_children(child);
      child = child->next;
    }
    delete parent_node;
  }

  void remerge_children(Node * parent_node) {
		printf("%i \n", *parent_node->elt);
    Node * child = parent_node->child;
    if (child != nullptr) {
      remerge_children(child);
    }
		Node * next_node = parent_node->next;
		while (next_node != nullptr) {
			Node * future_next_node = next_node->next;
			remerge_children(next_node);
			next_node = future_next_node;
		}
    if (parent_node->previous != nullptr) {
      if (parent_node->previous->child == parent_node) {
        parent_node->previous->child = parent_node->next;
      } else {
        parent_node->previous->next = parent_node->next;
      }
      if (parent_node->next != nullptr) {
        parent_node->next->previous = parent_node->previous;
      }
      parent_node->previous = nullptr;
      parent_node->next = nullptr;
      meld(parent_node, root_);
    }
  }
};

template<typename TYPE, typename COMP_FUNCTOR>
template<typename InputIterator>
pairing_priority_queue<TYPE, COMP_FUNCTOR>::pairing_priority_queue(
    InputIterator start, InputIterator end, COMP_FUNCTOR comp) {
  this->compare = comp;
  while (start != end) {
    push(*start);
    ++start;
  }
}

template<typename TYPE, typename COMP_FUNCTOR>
pairing_priority_queue<TYPE, COMP_FUNCTOR>::pairing_priority_queue(COMP_FUNCTOR comp) {
  this->compare = comp;
}

template<typename TYPE, typename COMP_FUNCTOR>
pairing_priority_queue<TYPE, COMP_FUNCTOR>::pairing_priority_queue(
    const pairing_priority_queue& other) {
  Node * old_top = other.top();
  root_ = new Node(old_top.elt);
  copy_children_nodes(root_, old_top);
}

template<typename TYPE, typename COMP_FUNCTOR>
pairing_priority_queue<TYPE, COMP_FUNCTOR>&
pairing_priority_queue<TYPE, COMP_FUNCTOR>::operator=(const pairing_priority_queue& rhs) {
  this = pairing_priority_queue(rhs);
}

template<typename TYPE, typename COMP_FUNCTOR>
pairing_priority_queue<TYPE, COMP_FUNCTOR>::~pairing_priority_queue() {
	if (root_ != nullptr) {
		delete_children(root_);
	}
}

template<typename TYPE, typename COMP_FUNCTOR>
void pairing_priority_queue<TYPE, COMP_FUNCTOR>::fix() {
  remerge_children(root_);
}

template<typename TYPE, typename COMP_FUNCTOR>
void pairing_priority_queue<TYPE, COMP_FUNCTOR>::pop() {
  Node * old_root = root_;
  root_ = root_->child;
  delete old_root;
	if (root_ != nullptr) {
		root_->previous = nullptr;
		Node * old_next_node = root_->next;
		root_->next = nullptr;
		while (old_next_node != nullptr) {
			Node * merge_node = old_next_node;
			old_next_node = merge_node->next;
			merge_node->next = nullptr;
			merge_node->previous = nullptr;
			meld(root_, merge_node);
		}
	}
	size_ = size_ - 1;
}

template<typename TYPE, typename COMP_FUNCTOR>
const TYPE& pairing_priority_queue<TYPE, COMP_FUNCTOR>::top() const {
  return root_->elt;
}

template<typename TYPE, typename COMP_FUNCTOR>
typename pairing_priority_queue<TYPE, COMP_FUNCTOR>::Node*
pairing_priority_queue<TYPE, COMP_FUNCTOR>::add_node(const TYPE& val) {
	Node * push_node;
  if (root_ == nullptr) {
    push_node = new Node(val);
    root_ = push_node;
  } else {
    push_node = new Node(val);
    meld(root_, push_node);
  }
	size_ = size_ + 1;
	return push_node;
}

template<typename TYPE, typename COMP_FUNCTOR>
void pairing_priority_queue<TYPE, COMP_FUNCTOR>::updateElt(Node* node, const TYPE &new_value) {
  node->elt = new_value;
  fix();
}

#endif  // PAIRING_PRIORITY_QUEUE_H_

