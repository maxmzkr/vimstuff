#include <array>
#include <string>
#include <iostream>
#include "./clock.h"
#include "./page_information_entry.h"
#include "./page_information_table.h"
#include "./vm_pager.h"


Pie::Pie(unsigned int share_id) {
  share_id_ = share_id;
  disk_page_ = Pit::get_next_disk_location();
}

Pie::~Pie() {
  if (get_resident_from_state()) {
  }
}

unsigned int Pie::ppage() {
  return ppage_;
}

unsigned int Pie::share_id() {
  return share_id_;
}

Pie::State Pie::state() {
  return state_;
}

bool Pie::written_to_disk() {
  return written_to_disk_;
}

std::list<Pie*>::iterator Pie::clock_location() {
  return clock_location_;
}

void Pie::set_ppage(unsigned int ppage) {
  ppage_ = ppage;
  for (auto it = shared_ptes_.begin(); it != shared_ptes_.end(); ++it) {
    for (auto pte : it->second) {
      pte->ppage = ppage;
    }
  }
}

void Pie::set_state(State state) {
  if (state == REF || state == REF_NO_TOUCH) {
    set_read_write_bits(1, 0);
  } else if (state == DIRTY) {
    set_read_write_bits(1, 1);
  } else if (state == NO_REF || state == NO_REF_DIRTY ||
             state == NO_REF_NO_TOUCH) {
    set_read_write_bits(0, 0);
  }

  state_ = state;
}

void Pie::set_written_to_disk(bool written_to_disk) {
  written_to_disk_ = written_to_disk;
}

void* Pie::get_ppage_ptr() {
  return static_cast<void*>(static_cast<char*>(vm_physmem) +
                            ppage_ * VM_PAGESIZE);
}

void Pie::set_clock_location(std::list<Pie*>::iterator clock_location) {
  clock_location_ = clock_location;
}

void Pie::load_page() {
  clock::place(this);
  void* ppage_ptr = get_ppage_ptr();
  disk_read(disk_page_, ppage_ptr);
}

void Pie::store_page() {
  void * ppage_ptr = get_ppage_ptr();
  disk_write(disk_page_, ppage_ptr);
}

void Pie::zero_fill() {
  char* start_addr = static_cast<char*>(get_ppage_ptr());
  char* end_addr = static_cast<char*>(start_addr + VM_PAGESIZE);
  char zero = 0;
  for (char* curr_addr = start_addr; curr_addr < end_addr; curr_addr += 1) {
    *curr_addr = zero;
  }
}

void Pie::set_read_write_bits(unsigned int read_enable, unsigned int write_enable) {
  for (auto it = shared_ptes_.begin(); it != shared_ptes_.end(); ++it) {
    for (auto pte : it->second) {
      pte->read_enable = read_enable;
      pte->write_enable = write_enable;
    }
  }
}

void Pie::add_shared_pte(pid_t pid, page_table_entry_t* pte) {
  shared_ptes_[pid].push_back(pte);
}

bool Pie::remove_pid(pid_t pid) {
  shared_ptes_.erase(pid);


  if (shared_ptes_.empty()) {
    if (get_resident_from_state()) {
      clock::erase(this);
    }
    Pit::free_disk_location(disk_page_);
    return true;
  }

  return false;
}

unsigned int Pie::get_read_from_state() {
 if (state_ == NO_REF || state_ == NO_REF_DIRTY ||
     state_ == NO_REF_NO_TOUCH || state_ == EVICT ||
     state_ == INIT) {
    return 0U;
 }
 return 1U;
}

unsigned int Pie::get_write_from_state() {
  if (state_ == DIRTY) {
    return 1U;
  }
  return 0U;
}

unsigned int Pie::get_resident_from_state() {
  if (state_ == EVICT || state_ == INIT) {
    return 0U;
  }
  return 1U;
}

void Pie::print_state() {
  if (static_cast<unsigned int>(state_) >= StateArray.size()) {
    std::cout << state_ << "\n";
  } else {
    std::cout << StateArray[state_] << "\n";
  }
}

std::array<std::string, Pie::EVICT + 1> Pie::StateArray{
    "INIT", "DIRTY",  "REF_NO_TOUCH", "NO_REF_NO_TOUCH",
    "REF",  "NO_REF", "NO_REF_DIRTY", "EVICT"};
